title: 后端理论
author: PanYuKang
cover: 'https://i01piccdn.sogoucdn.com/b383df7c1073cfae'
tags: [后端基础]
categories: [后端技术]
date: 2020-04-25 13:09:00

---

## 网络安全

网络安全访问方面：包括数据篡改、SQL注入、XSS攻击等

### 加密算法

#### 对称加密算法

对称加密算法使用相同的密钥来加密和解密数据，常见的对称加密算法包括AES、DES、3DES等。

#### 非对称加密算法

非对称加密算法使用一对密钥，一个用于加密，一个用于解密，常见的非对称加密算法包括RSA、ECDSA等。
GitHub 上的 SSH（Secure Shell）加密技术也是使用非对称加密。
SSH 使用公钥加密技术进行身份验证和数据传输。在 SSH 中，用户拥有一对密钥，其中一个是私钥，另一个是公钥。

私钥：私钥由用户保存在本地计算机上，用于解密由公钥加密的信息。

公钥：公钥则被上传到远程服务器，用于加密要发送给用户的信息。

这种非对称加密的机制允许用户向远程服务器证明自己的身份，并安全地进行数据传输，因为私钥仅存储在用户的本地计算机上，不会被泄露给其他人。只有拥有相应私钥的用户才能解密由公钥加密的信息，这保证了通信的安全性。

#### 哈希算法

哈希算法可以将任意长度的数据转换为固定长度的哈希值，常见的哈希算法包括MD5、SHA1、SHA256等。

#### 常见的应用场景

哈希算法：
密码学安全性：哈希算法用于保护密码的安全性，如存储用户密码的散列值，以防止密码泄露后的暴力破解。
数据完整性：哈希算法用于验证数据的完整性，确保数据在传输和存储过程中没有被篡改。
数字签名：哈希算法用于生成数字签名，用于验证文件的身份和完整性，常见于数字证书、文件认证等场景。
区块链：区块链中的数据结构依赖于哈希算法，用于保障区块链数据的不可篡改性和完整性。
对称加密算法：

数据加密：对称加密算法用于保护数据的机密性，如加密通信数据、存储数据等，常见于网络通信、文件加密等场景。
会话密钥交换：对称加密算法用于在通信双方之间安全地交换会话密钥，以确保通信的保密性和安全性。
数据存储：对称加密算法用于保护存储在本地设备或云端的敏感数据，如用户密码、个人信息等。
非对称加密算法：

数字签名：非对称加密算法用于生成数字签名，以验证文件的身份和完整性，确保数据的真实性和不可否认性。
安全通信：非对称加密算法用于安全地传输密钥，以确保通信的机密性和安全性，常见于安全协议如 SSL/TLS。
身份验证：非对称加密算法用于实现身份验证，如 HTTPS 中的服务器证书、SSH 中的用户身份验证等。
这些加密算法在网络通信、数据存储、安全协议、数字证书、电子支付等各个领域中都有着重要的作用，是保障网络安全和数据隐私的重要技术手段。

## 互联网协议

网络协议指的是网络中传递、管理信息的一些规范。HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范。但是互联网又不只有 HTTP 协议，它还有很多其他的比如 IP、TCP、UDP、DNS 协议等。

### HTTP与HTTPS区别

HTTP协议传输的数据是明文未加密的，因此对于传输隐私信息非常不安全，为了保证这些隐私数据能加密传输，于是网景公司设计了SSL协议用于对HTTP协议传输的数据进行加密，从而就诞生了HTTPS。
简单来说，HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，要比http协议安全。

**HTTPS和HTTP的区别主要如下：**

1. https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。
2. http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。
3. http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。
4. http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。

### TCP/IP协议簇

TCP/IP 协议是我们程序员接触最多的协议，实际上，TCP/IP 又被称为 TCP/IP 协议簇，它并不特指单纯的 TCP 和 IP 协议，而是容纳了许许多多的网络协议。TPC/IP协议是传输层协议，主要解决数据如何在网络中传输，而HTTP是应用层协议，主要解决如何包装数据。

OSI标准模型将复杂的协议整理并分为了易于理解的 7 层。从下到上分别是物理层、数据链路层、网络层、运输层、会话层、表示层和应用层。但是这显然是有些复杂的，所以在TCP/IP协议中，它们被简化为了四个层次，从下到上分别是通信链路层、网络层、传输层、应用层。

1. **IP协议**

   IP是互联网协议，位于网络层。IP是整个TCP/IP 协议族的核心，也是构成互联网的基础。
2. **ARP协议**

   ARP协议是地址解析协议，它能够根据 IP 地址获取物理地址。
3. **TCP协议**

   TCP是传输控制协议，它是一种面向连接的、可靠的、基于字节流的传输协议，TCP 协议位于传输层，是 TCP/IP 协议簇中的核心协议，它最大的特点就是提供可靠的数据交付，准确性较高，但工作效率较低。
4. **UDP协议**

   UDP协议是用户数据报协议，UDP也是一种传输层的协议，无连接、不可靠、基于报文的传输协议，但是 UDP 具有较好的实时性，工作效率较 TCP 协议高。
5. **FTP协议**

   FTP协议是文件传输协议，应用层协议之一，是 TCP/IP 协议的重要组成之一，FTP 协议分为服务器和客户端两部分，FTP 服务器用来存储文件，FTP 客户端用来访问 FTP 服务器上的文件，FTP 的传输效率比较高，所以一般使用 FTP 来传输大文件。
6. **DNS协议**

   DNS 协议是 域名系统协议，英文全称是 Domain Name System，它也是应用层的协议之一，DNS 协议是一个将域名和 IP 相互映射的分布式数据库系统。DNS 缓存能够加快网络资源的访问。

### TCP/IP分层

分层：应用层、传输层、网络层、数据链路层、物理层

物理层：负责比特流节点之间的传输，通俗来说就是把计算机连接起来的物理手段。
数据链路层：控制网络层和物理层之间的通信，主要功能是保证物理线路上进行可靠的数据传递。
网络层：决定如何将数据从发送路由到接收方。即建立主机到主机的通信。
传输层：该层为两台主机上的应用程序提供端到端的通信。传输层有两个传输协议：TCP(传输控制协议)和 UDP(用户数据报协议)。其中，TCP是一个可靠的面向连接的协议，udp是不可靠的或者说无连接的协议
应用层：应用程序收到传输层的数据后，接下来就要进行解读。解读必须事先规定好格式，而应用层就是规定应用程序的数据格式。主要的协议有：HTTP、FTP、Telent、ssh等。

### TCP与UDP区别

![图片](hexo_post_1.jpg)

（1）TCP：面向连接，可靠的，速度慢，效率低。

（2）UDP：无连接、不可靠、速度快、效率高。

应用场景：当进程需要传输可靠的数据时应使用TCP，当进程需要高效传输数据，可以忽略可靠性时应使用UDP协议。

### TCP的三次握手

为什么需要三次握手，两次不行吗？弄清这个问题，我们需要先弄明白三次握手的目的是什么，能不能只用两次握手来达到同样的目的。

1. 第一次握手：客户端发送网络包，服务端收到了。
   这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。
2. 第二次握手：服务端发包，客户端收到了。
   这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常。
3. 第三次握手：客户端发包，服务端收到了。
   这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常。
   因此，需要三次握手才能确认双方的接收与发送能力是否正常。
4. 四次挥手：
   建立一个连接需要三次握手，而终止一个连接要经过四次挥手（也有将四次挥手叫做四次握手的）。这由TCP的半关闭造成的。所谓的半关闭，其实就是TCP提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力。

> 详情传送门：https://blog.csdn.net/hai_chao/article/details/79626161

### HTTP的请求方式

#### Get请求和Post请求区别

（1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）
（2）post发送的数据更大（get有url长度限制）
（3）post能发送更多的数据类型（get只能发送ASCII字符）
（4）post比get慢
（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据.

总结：GET把参数包含在URL中，POST通过request body传递参数，所以Post更加安全一些；Get的效率比Post高一些，但是Get请求发送的参数是有限的，而Post请求是没有限制的(理论上来讲)。

#### 使用场景

在做数据查询时，建议用Get方式；而在做数据添加、修改或删除时，建议用Post方式；
Get方式的安全性较Post方式要差些，包含机密信息的话，建议用Post数据提交方式；
区别表现如下：

Get是从服务器上获取数据，Post是向服务器传送数据。
Get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。Post是通过HTTP Post机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
对于Get方式，服务器端用Request.QueryString获取变量的值，对于Post方式，服务器端用Request.Form获取提交的数据。
Get传送的数据量较小，不能大于2KB。Post传送的数据量较大，一般被默认为不受限制。但理论上，IIS4中最大量为80KB，IIS5中为100KB。 5. Get安全性非常低，Post安全性较高。但是执行效率却比Post方法好。
Get和Post还有一个重大区别：
Get产生一个TCP数据包；Post产生两个TCP数据包。

对于Get方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据），而对于Post，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。

比如说：Get只需要汽车跑一趟就把货送到了，而Post得跑两趟，第一趟，先去和服务器打个招呼“嗨，我等下要送一批货来，你们打开门迎接我”，然后再回头把货送过去。由于Post需要两步，时间上消耗的要多一点，所以Get比Post更有效率。

## JavaEE和JavaWeb

### JavaWeb

例如 :J DBC，JSP，Servlet，JavaBean，Html，JavaScript，Session/Cookie，MVC设计模式，Tomcat，Eclipse+MyEclipse

### JavaEE

例如：人们常说的SSH =Spring+Struts+Hibernate架构应用整合开发,XML,EJB,WebService,UML/Rose,Ajax,Weblogic,Oracle。
总之：Java EE是企业级应用平台，Java Web是指所有用于web开发的Java技术。

## 持久化

    瞬时状态:保存在内存的程序数据，程序退出后，数据就消失了，称为瞬时状态
	持久状态:保存在磁盘上的程序数据，程序退出后依然存在，称为程序数据的持久状态
	持久化:将程序数据在瞬时状态和持久状态之间相互转换的机制

1. 为什么要持久化？
   持久化技术封装了数据访问细节，为大部分业务逻辑提供面向对象的API。
   通过持久化技术可以减少访问数据库数据次数，增加应用程序执行速度；
   代码重用性高，能够完成大部分数据库操作；
   松散耦合，使持久化不依赖于底层数据库和上层业务逻辑实现，更换数据库时只需修改配置文件而不用修改代码。

## 构造函数

1. 定义：与类名相同，既没有返回类型也没有返回值，不写void,这种特殊的成员方法就叫构造函数。
2. 什么时候使用：想为对象实例化的同时为其初始化。
3. 区别：
   1. 作用不同，构造方法仅用于实例化对象，对成员变量进行初始化，成员方法用于对成员变量进行多种操作。
   2. 调用方式不同，构造方法只能通过new运算符调用，成员方法可以通过对象名调用。
   3. 调用时机不同，构造方法是在创建对象时调用，成员方法是创建对象之后，通过对象名进行调用。

## 面向对象特性

### 封装

封装是对内部信息进行隐藏，不允许外部程序直接访问，只能通过对象提供的方法进行访问，从而达到隐藏类内部信息的目的。

1. 优点：提高安全性、复用性、高内聚低耦合。

### 继承

是指让某一类型的对象获取另一个类型的对象的属性和方法。

1. 继承的原则：1.1	java是单继承的，一个类只能有一个父类。1.2	子类继承父类的实例变量和类变量（静态变量）。1.3	子类继承父类除了构造方法以外的实例成员和类方法（静态方法）。1.4	子类不能继承父类的构造方法，因为父类的构造方法用来创建父类对象，子类需要声明自己的构造方法，用来创建子类自己的对象。1.5	子类可以重新声明父类的成员。
2. 继承的特点：2.1 继承的本质就是抽取共性代码，简化代码。2.2 类是对一批对象的抽象，继承是对一批类的抽象。
3. 继承的使用：
   3.1 一般在写代码的时候发现代码中存在重复代码,需要向上抽取,考虑继承。
   3.2 当某个类的设计非常复杂的时候可以考虑继承 例如: 设计一个窗口类。

### 多态

相同方法名的多种实现，主要通过方法重写和方法重载来实现，多态是基于继承来实现的。

1. 方法重载（overload）：方法具有相同的方法名，不同的参数列表，与返回值无关。
2. 方法重写（overrride）：方法重写是指子类重新定义了父类同名的方法，子类中的方法具有父类方法中相同的参数列表，但是方法体不同。

多态优点：

1. 提高代码的维护性。
2. 提高代码的扩展性。

### final的使用情况

1. 当内部类需要引入外部类的局部变量或是传入的参数时那么该变量必须被定义为final,防止内部类中引入的和外部类的不是同一个。
2. 当你不让别人继承一这个类的时候, 用final 修饰该类. 当一个方法不想让别人重写的时候可以把这个方法用final修饰. 当定义一个常量的时候可以用final 修饰。

### Static

1. 特点：被static修饰的内容会随着类的加载而加载，优先于对象存在，成员变量和成员方法可以通过类名直接调用并被该类下所有对象共享。
2. 使用情况：在同一类中，当某一数据被所有实例化对象共享时，可以用static修饰
3. 什么时候用？当一个变量需要初始化加载时候,或者是经常被调用的时候可以加上static。用static 修饰的方法可以直接被调用,不用再new对象才能调用。
4. 坏处：
   初始化加载，比较占内存，所以不经常用的方法，不建议加此关键字。

### 抽象类和方法

1. 定义：如果一个类没有足够的信息来描绘一个具体的对象，这样的类叫做抽象类。
2. 抽象类和抽象方法的关系

   1. 有抽象方法的类，一定是抽象类
   2. 抽象类不一定有抽象方法
   3. 抽象类不允许被实例化
   4. 抽象类的子类必须实现抽象方法以后才能被实例化
   5. 如果有任意一个抽象方法没有被子类实现，那么子类也应该是抽象类

### 接口

是一组常量和抽象方法的集合。

1. Java只允许类的单继承，使用接口可以实现多重继承。
2. 接口只能继承接口。
3. 表面上接口是解决多继承的，实质上是解决不同行为的。因为只有共性行为才能定义在父类中。非共性行为通过接口来补充扩展。

## 全局变量、成员变量和局部变量

### 全局变量

    // 写在函数和大括号外部的变量, 我们称之为全局变量
    // 作用域: 从定义的那一行开始, 一直到文件末尾
    // 全局变量可以先定义再初始化, 也可以定义的同时初始化
    // 存储: 静态区
    // 程序一启动就会分配存储空间, 直到程序结束才会释放

### 成员变量

    // 写在类声明的大括号中的变量, 我们称之为 成员变量(属性, 实例变量)
    // 成员变量只能通过对象来访问
    // 注意: 成员变量不能离开类, 离开类之后就不是成员变量 成员变量不能在定义的同时进行初始化
    // 存储: 堆(当前对象对应的堆的存储空间中)
    // 存储在堆中的数据, 不会被自动释放, 只能程序员手动释放

### 局部变量

    // 写在函数或者代码块中的变量, 我们称之为局部变量
    // 作用域: 从定义的那一行开始, 一直到遇到大括号或者return
    // 局部变量可以先定义再初始化, 也可以定义的同时初始化
    // 存储 : 栈
    // 存储在栈中的数据有一个特点, 系统会自动给我们释放

## C/S结构和B/S结构的区别

### C/S与B/S

c/s：客户机和服务器结构（胖客户端结构），需要安装，如QQ
b/s:浏览器和服务器结构（瘦客户端结构），无需安装，如平时浏览的网站

### URL(统一资源定位符)结构

协议：//服务器名称:端口号/路径/文件名？查询字符串

## JSP九个内置对象

内置对象定义：由web容器实例化，开发人员不需要实例化而直接使用的对象。

1. application（应用程序对象）作用：就像全局变量，用于保存应用程序中的共有数据（上传时获取真实路径）
2. config（配置对象）作用：用于取得服务器的配置信息
3. execption（异常对象）作用：用于处理jsp页面发生的异常
4. out（输出对象）作用：对象用于在web浏览器内输出信息，数据输出完，要及时关闭输出流
5. page（页面对象）作用：代表jsp本身，只有在jsp页面内才是合法的
6. pageContext（上下文对象）作用：用于获取页面的上下文，通过此对象可以获取页面的其他8个内置对象
7. request（请求对象）作用：用于处理客户端请求，在（页面转发，获取cookie）用到
8. response（响应对象）作用：用于处理响应客户端请求，在（页面重定向）中使用
9. session（会话对象）
   作用：在网络中被称为会话，一个会话就是浏览器与服务器之间的一次通话（保存登录状态时）

## get请求和post请求的区别

1. 提交方式不同：get请求会将提交的数据显示在地址栏，post不会，而是把提交的数据放在正文内form date中。
2. 传输数据大小不同：get请求因浏览器而异，post请求因web服务器而异，但是HTTP协议本身对于传输数据大小没有限制。
3. 安全性：post请求略高于get请求。

## 请求转发和重定向的区别

### 两者区别

1. 转发在一次请求中完成，重定向是两次请求。
2. 转发操作发生在服务器内部，重定向是浏览器执行操作。
3. 转发地址栏不变（只有一次请求，一个地址），重定向，地址栏变化（两次请求，两个地址）。
4. 转发可以 在一次请求中共享数据，重定向不行。（重定向两次请求）

### 请求转发和重定向分别何时使用？

前后两个页面，有数据传递，用请求转发，没有则用重定向。
比如servlet查询了数据需要在页面显示，就用请求转发。
比如servlet做了update操作跳转到其他页面，就用重定向。

### 补充

WEB-INF:是java的web应用的安全目录，所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应的映射才能访问。

request是请求，session是会话，request的生命周期就在一次请求中，而session是整个会话周期，你开启一个网站就是一个会话，知道关闭浏览器，session才被销毁，而request是在开启一个网站，关闭这个网站，request就被销毁了，在jsp中一般就request来传递该页面使用的参数，而session则用来保存整个网站所需要的参数，如用户信息,session是会话，session在整个过程都是可以取到绑定的参数，无论是重定向还是转发都可以。

## 序列化和反序列化

序列化：把对象转换为字节序列的过程称为对象的序列化。
反序列化：把字节序列恢复为对象的过程称为对象的反序列化。

什么情况下需要序列化 ：
　　当你想把的内存中的对象保存到一个文件中或者数据库中时候；
　　当你想用序列化在网络上传送对象的时候；
    当你想通过RMI传输对象的时候；

## Servlet 生命周期

Servlet 生命周期可被定义为从创建直到毁灭的整个过程。
Servlet 遵循的过程：
Servlet 通过调用 init () 方法进行初始化。
Servlet 调用 service() 方法来处理客户端的请求。
Servlet 通过调用 destroy() 方法终止（结束）。
最后，Servlet 是由 JVM 的垃圾回收器进行垃圾回收的。

## Servlet生命周期简述

（1）加载和实例化

当Servlet容器启动或客户端发送一个请求时，Servlet容器会查找内存中是否存在该Servlet实例，若存在，则直接读取该实例响应请求；如果不存在，就创建一个Servlet实例。

（2） 初始化

实例化后，Servlet容器将调用Servlet的init()方法进行初始化（一些准备工作或资源预加载工作）。

（3）服务

初始化后，Servlet处于能响应请求的就绪状态。当接收到客户端请求时，调用service()的方法处理客户端请求，HttpServlet的service()方法会根据不同的请求 转调不同的doXxx()方法。

（4）销毁

当Servlet容器关闭时，Servlet实例也随时销毁。其间，Servlet容器会调用Servlet 的destroy()方法去判断该Servlet是否应当被释放（或回收资源）。

JavaBean:称为java组件，也就是java类，用于保存数据和实现业务逻辑。

## 什么是MVC开发模式

一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，将业务逻辑聚集到一个部件里面，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。MVC被独特的发展起来用于映射传统的输入、处理和输出功能在一个逻辑的图形化用户界面的结构中。

1. Model（模型）
   1. 是应用程序中用于处理应用程序数据逻辑的部分。
   2. 通常模型对象负责在数据库中存取数据。
2. View（视图）
   1. 是应用程序中处理数据显示的部分。
   2. 通常视图是依据模型数据创建的。
3. Controller（控制器）
   1. 是应用程序中处理用户交互的部分。
   2. 通常控制器负责从视图读取数据，控制用户输入，并向模型发送数据。

## 什么是restful API

中文名是“表现层状态转移”，简单来说就是URL定位资源，用HTTP动词（GET,POST,PUT,DELETE)描述操作。
你每次请求的接口或者地址,都在做描述,例如查询的时候用了query,新增的时候用了save,其实完全没有这个必要,我使用了get请求,就是查询.使用post请求,就是新增的请求,我的意图很明显,完全没有必要做描述,这就是为什么有了restful。

## REST系统

定义：REST是一个标准，一种规范，遵循REST风格可以使开发的接口通用，便于调用者理解接口的作用。

特征：

1. 无状态（Stateless），来自客户的每一个请求必须包含服务器处理该请求所需的所有信息。
2. 可缓存（Cachable），服务器必须让客户知道请求是否可以被缓存。
3. 统一接口（Uniform Interface），客户和服务器之间通信的方法必须是统一化的。

无状态：所谓无状态的，即所有的资源，都可以通过URI定位，而且这个定位与其他资源无关，也不会因为其他资源的变化而改变。如查询员工的工资，如果查询工资是需要登录系统，进入查询工资的页面，执行相关操作后，获取工资的多少，则这种情况是有状态的，因为查询工资的每一步操作都依赖于前一步操作，只要前置操作不成功，后续操作就无法执行；如果输入一个url即可得到指定员工的工资，则这种情况是无状态的，因为获取工资不依赖于其他资源或状态，且这种情况下，员工工资是一个资源，由一个url与之对应，可以通过HTTP中的GET方法得到资源，这是典型的RESTful风格。

![图片](hexo_post_2.png)

![图片](hexo_post_3.png)

## 统一接口

RESTful架构风格规定，数据的元操作，即CRUD(create, read, update和delete,即数据的增删查改)操作，分别对应于HTTP方法：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源，这样就统一了数据操作的接口，仅通过HTTP方法，就可以完成对数据的所有增删查改工作。

## 操作系统部分

### 进程和线程的区别

1. 进程是系统进行资源调度和分配的基本单位，实现了操作系统的并发性。
2. 线程是进程的子任务，是CPU调度和分派的基本单位，用于保证程序的实时性，实现进程内部的并发。
3. 一个程序至少有一个进程，一个进程至少有一个线程，线程依赖于进程而存在；

### 进程间的几种通信方式

1. 管道（pipe）及命名管道（named pipe）：管道可用于具有亲缘关系的父子进程间的通信，有名管道除了具有管道所具有的功能外，它还允许无亲缘关系进程间的通信；
2. 信号（signal）：信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
3. 消息队列：消息队列是消息的链接表，它克服了上两种通信方式中信号量有限的缺点，具有写权限得进程可以按照一定得规则向消息队列中添加新信息；对消息队列有读权限得进程则可以从消息队列中读取信息；
4. 共享内存：可以说这是最有用的进程间通信方式。它使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据得更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等；
5. 信号量：主要作为进程之间及同一种进程的不同线程之间的同步和互斥手段，用来保证多个线程不会互相冲突。
6. 套接字：这是一种更为一般得进程间通信机制，它可用于网络中不同机器之间的进程间通信，应用非常广泛。

### 死锁

概念：两个或多个进程无限期的阻塞、相互等待的一种状态。

在数据库中有两种基本的锁类型：排它锁（X锁）和共享锁（S锁）。当数据对象被加上排它锁时，其他的事务不能对它读取和修改。加了共享锁的数据对象可以被其他事务读取，但不能修改。数据库利用这两种基本的锁类型来对数据库的事务进行并发控制。

死锁产生的原因：

一个用户A 访问表A（锁住了表A），然后又访问表B；另一个用户B 访问表B（锁住了表B），然后企图访问表A；这时用户A由于用户B已经锁住表B，它必须等待用户B释放表B才能继续，同样用户B要等用户A释放表A才能继续，因为正在进行带锁的数据访问，那么这个进程就会等待，如果等了很久锁没有解除就会锁超时，形成死锁的状态。

死锁产生的四个必要条件：

1. 互斥：一个资源每次只能被一个进程使用
2. 请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
3. 不可剥夺条件：进程已获得资源，在未使用完之前，不能被其他进程强行剥夺，只能主动释放
4. 循环等待：若干进程之间形成一种头尾相接的环形等待资源关系

解决死锁的基本方法主要有 预防死锁、避免死锁、检测死锁、解除死锁等。
(1). 死锁预防　
死锁预防的基本思想是 只要确保死锁发生的四个必要条件中至少有一个不成立，就能预防死锁的发生

(2). 死锁解除
死锁解除的常用两种方法为进程终止和资源抢占。所谓进程终止是指简单地终止一个或多个进程以打破循环等待，包括两种方式：终止所有死锁进程和一次只终止一个进程直到取消死锁循环为止；所谓资源抢占是指从一个或多个死锁进程那里抢占一个或多个资源

## 互斥锁/读写锁

互斥锁在Java中的具体实现就是ReentrantLock；读写锁在Java中的具体实现就是ReadWriteLock。

"互斥锁"，防止多个线程同时读写某一块内存区域。

## 悲观锁/乐观锁

乐观锁与悲观锁不是指具体的什么类型的锁，而是指看待并发同步的角度。

悲观锁：总是假设最坏的情况，每次去拿数据的时候都认为别人会修改，所以每次在拿数据的时候都会上锁，这样别人想拿这个数据就会阻塞直到它拿到锁。比如Java里面的同步原语synchronized关键字的实现就是悲观锁。

乐观锁：顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在更新的时候会判断一下在此期间别人有没有去更新这个数据，可以使用版本号等机制。乐观锁适用于多读的应用类型，这样可以提高吞吐量，在Java中java.util.concurrent.atomic包下面的原子变量类就是使用了乐观锁的一种实现方式CAS(Compare and Swap 比较并交换)实现的。

## 公平锁/非公平锁

公平锁是指多个线程按照申请锁的顺序来获取锁。
非公平锁是指多个线程获取锁的顺序并不是按照申请锁的顺序，有可能后申请的线程比先申请的线程优先获取锁。有可能，会造成优先级反转或者饥饿现象。
对于Java ReentrantLock而言，通过构造函数指定该锁是否是公平锁，默认是非公平锁。非公平锁的优点在于吞吐量比公平锁大。
对于synchronized而言，也是一种非公平锁。由于其并不像ReentrantLock是通过AQS的来实现线程调度，所以并没有任何办法使其变成公平锁。

## JVM虚拟机

### 基本概念

JVM是可运行Java代码的假想计算机 ，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收，堆 和 一个存储方法域。JVM是运行在操作系统之上的，它与硬件没有直接的交互。

### JRE/JDK/JVM的关系

1. JDK ：英文名称（Java Development Kit），Java 开发工具包。jdk 是整个 Java 开发的核心，它集成了 jre 和一些好用的小工具。例如：javac.exe，java.exe，jar.exe 等。
2. JRE ：英文名称（Java Runtime Environment），我们叫它：Java 运行时环境，所有的Java程序都要在JRE下才能运行。它主要包含两个部分，jvm 的标准实现和 Java 的一些基本类库。它相对于 jvm 来说，多出来的是一部分的 Java 类库。
3. JVM ：英文名称（Java Virtual Machine），就是我们耳熟能详的 Java 虚拟机。它只认识 xxx.class 这种类型的文件，它能够将 class 文件中的字节码指令进行识别并调用操作系统向上的 API 完成动作。JVM是JRE的一部分，一个虚构出来的计算机，它支持跨平台。

这三者的关系是：一层层的嵌套关系。JDK>JRE>JVM。

### JVM原理

JVM是Java编译器和os平台之间的虚拟处理器，java编译器生成的.java文件通过JVM生成.class字节码文件，然后通过JVM将每一个条指令翻译成不同平台的机器码，实现真正的跨平台运行。

## 高并发

我们常见的高并发场景有：淘宝的双 11、春运时的抢票、微博大 V 的热点新闻等。除了这些典型事情，每秒几十万请求的秒杀系统、每天千万级的订单系统、每天亿级日活的信息流系统等，都可以归为高并发。

高并发可以通过分布式技术去解决，将并发流量分到不同的物理服务器上。但除此之外，还可以有很多其他优化手段：比如使用缓存系统，将所有的，静态内容放到CDN等；还可以使用多线程技术将一台服务器的服务能力最大化。

## 总结一下

●分布式是从物理资源的角度去将不同的机器组成一个整体对外服务，技术范围非常广且难度非常大，有了这个基础，高并发、高吞吐等系统很容易构建；

● 高并发是从业务角度去描述系统的能力，实现高并发的手段可以采用分布式，也可以采用诸如缓存、CDN等，当然也包括多线程；

● 多线程则聚焦于如何使用编程语言将CPU调度能力最大化。
