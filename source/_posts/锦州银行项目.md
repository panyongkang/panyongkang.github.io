title: 锦州银行项目
author: PanXiaoKang
tags: [银行,工作笔记]
categories: [项目]

cover: https://ss0.bdstatic.com/70cFvHSh_Q1YnxGkpoWK1HF6hhy/it/u=1225489108,1880621396&fm=26&gp=0.jpg
message: 您好，本篇文章需密码访问，请谅解！
password: card0113
date: 2020-04-18 23:26:00

---

### 理论知识

**银行系统分为**：核心系统 和 外围系统 (包括 前置、前端)。

**核心系统**：核心系统可以抽象成是往一个账户金额的加加减减。传统的银行核心系统，可以进行完整的银行交易和事务处理的交易系统,没有前置系统。如果采用直连柜面通讯通道，银行核心是一个单独的、可运行的交易系统。
**外围系统**：都调用核心系统，如柜台、网银、ATM、人行结算、管理分析系统、日终处理、贷款、信用卡、等等。 每一个外围系统都是一项业务系统。

**前置系统**：也可以说是中间业务平台，没有处理业务交易功能，只能是进行报文的转换、报文的加密处理、通讯协议的转换。以及通过这个平台进行路由功能通讯的转入转出处理。

渠道前置系统，只做相应的渠道配置就可以实现与外围系统的对接，或者只做很简单的二次开发就可以实现。银行的前置系统是一种多外围、可快速扩展、可配置的分布式企业级系统。

若银行系统是这样的三层架构：渠道层(包括柜面)、银行综合前置层(中间业务交换平台)、核心层(包括传统银行核心以及新非集成新业务子系统)。

银行核心是内脏，前置系统是血管。

**不同格式的报文转换和解析**

前置系统作为枢纽，必须能够兼容各类报文，并对各种报文格式进行相互的转换，完成跨系统之间的报文交互。

**系统间通讯问题的解决方案**

由于有些交易时需要跨系统之间进行交互的，系统间的通讯协议存在较大差异如 TCP/IP、HTTP、SOAP 等，网络结构复杂，主机间的通讯不能靠网络进行识别，前置系统作为各系统间的中介，需要能够对各类协议进行转换，实现跨系统业务的通信。

**部分业务交易的预处理**

替核心系统完成一部分交易的处理，将核心系统要求的数据提前进行转换，提高后台核心系统的工作效率 。

**监控交易的完成情况**

并记录交易流水和日志，便于发现问题的同时对问题进行跟踪、定位和分析，减少外围系统与主机交互式出现的数据不正确或者不完整的情况。

 金融数据字典是每个银行势在必行的任务，这在整理本行业务结构、技术规范、教育培训等都具有非同寻常的意义。数据字典最重要的信息结构是分类树、中英文对照和名词解释、数据域格式和长度、枚举空间。曾经有公司有雄心发布自己的金融数据字典，最后却落得孤芳自赏，其原因有很多，比如缺乏权威机构的支持，金融数据字典带有浓厚的银行自身业务特色，很难有一个统一的数据字典能放整个行业皆准。不过花点资源，整理出本行数据字典还是很有好处的。

**IOC常见的几种注入方式**

1. 构造器注入
2. Getter/Setter
3. 工厂注入

Spring框架、MVC、TCP/IP和HTTP

### 什么是报文，有哪些作用？

报文就是在各个系统之间进行请求和响应时用来交换信息的，还需要遵守规定好的格式。

另外，应用报文是多个系统之间需要通信的时候，比如银行ESB系统到网关系统再到银联系统。在这中间报文就承担了装载数据，运输数据的功能。报文的格式可能互不相同，但是承载的数据是一样的。

报文中配置余额的类型为BigDecimal,为什么使用BigDecimal?

金额必须是完全精确的计算，因此不能使用float或double,而应该采用java.math.BigDecimal

### 常用的技术

Map、HashMap、String和StringBuffer.

ArrayList代替Vector,HashMap代替Hashtable,因为同步会导致性能缺失。

final可提高程序响应效率，使用final之前确保类或方法不可被继承或重装。

数据库连接，IO操作时必须try...catch...finally

### 锦州面试的基础题

1. Q:"=="和equals方法究竟有什么区别

　A:基本数据类型是可以用“==”进行比较，而引用数据类型则不可以，一般是通过equals方法来实现比较。"=="为比较两侧的对象是否同一对象，是用内存地址来比较的。

   equals是方法，默认是用内存地址比较，重写后，主要是用来比较两侧的对象的值是否相同，和equals方法中的实现有关

2. Q:String是最基本的数据类型吗

  A:基本数据类型包括byte、int、char、long、float、double、boolean和short。

   String是引用数据类型。常用的还有类，接口，数组，枚举，注解，使用new关键字创建出来的类型都是引用数据类型。

3. Q:List和 Map区别？

  A:List是存储单列数据的集合，Map是存储键和值的双列数据的集合，List中存储的数据是有顺序，并且允许重复；Map中存储的数据是没有顺序的，其键是不能重复的，它的值是可以有重复的。

4. Q:Integer与int的区别？

  A:int是java提供的8种原始数据类型之一，意思整型，占用4字节。

   Integer是java为int提供的封装类，是引用数据类型。

5. Q:字节流与字符流的区别？

  A:字节流是按字节读取或写入设备，但字符流是以字符为单位读取或写入设备。

   如果是二进制文件，需要用字节流读取。一般来说，字符流只处理文本文件。在设备中，大多数情况是以字节形式存储数据的，因此字符流通过需要传入字节流当参数。

6. Q:什么是servlet？

  A:通常Servlet特指HttpServlet，用来接受浏览器的访问请求，浏览器最常用的请求为GET和POST方式

7. Q:静态变量和实例变量的区别？

  A:在语法定义上的区别：静态变量前要加static关键字，而实例变量前则不加。

   在程序运行时的区别：实例变量属于某个对象的属性，必须创建了实例对象，其中的实例变量才会被分配空间，才能使用这个实例变量。静态变量不属于某个实例对象，而是属于类，所以也称为类变量，只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间，静态变量就可以被使用了。

   总之，实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。

8. Q:是否可以从一个static方法内部发出对非static方法的调用？

  A:不可以。因为非static方法（实例方法）是要与对象关联在一起的，必须创建一个对象后，才可以在该对象上进行方法调用，而static方法调用时不需要创建对象，可以直接调用。也就是说，当一个static方法被调用时，可能还没有创建任何实例对象，如果从一个static方法中发出对非static方法的调用，那个非static方法是关联到哪个对象上的呢？这个逻辑无法成立，所以，一个static方法内部不能发出对非static方法的调用。

9. Q:Request和Response的用法？

  A:Request是客户端向服务端发送请求

  Response是服务端对客户端请求做出响应

10. Q:OSGI最主要的优点？

  A:热部署或动态部署，不需要整体重新启动服务，只针对某个模块进行新增，修改，移除即可。

### 配置一个交易步骤

1. 交易定义
   1. 描述
   2. 交易业务逻辑处理类
   3. 规则设置
   4. 交易成功跳转路径
2. 权限控制
3. 关系映射
4. 报文配置
   1. 发送报文
   2. 接收报文
5. 报文发送检查，保证报文发送成功就完成一个交易的配置

### JSP三种指令标签

| 指令             | 描述                                                    |
| ---------------- | ------------------------------------------------------- |
| <%@ page...%>    | 定义网页依赖属性，比如脚本语言，error页面，缓存需求等等 |
| <%@ include...%> | 包含其他文件                                            |
| <%@ taglib...%>  | 引入标签库的定义                                        |

**Page指令**

Page指令为容器提供当前页面的使用说明。一个JSP页面可以包含多个page指令。

contentType属性：指定当前JSP页面的MIME类型和字符编码。

Session属性：指定JSP页面是否使用session。

**Include指令**

JSP可以通过include指令来包含其他文件。被包含的文件可以是JSP文件、HTML文件或文本文件。包含的文件就好像是该JSP文件的一部分，会被同时编译执行。

**Taglib指令**

JSP API允许用户自定义标签，一个自定义标签库就是自定义标签的集合。Taglib指令引入一个自定义标签集合的定义，包括库路径、自定义标签。

uri属性：确定标签库的位置。

prefix属性：指定标签库的前缀。

### JSP标准标签库JSTL

**核心标签**

核心标签是最常用的JSTL标签，引用核心标签库的语法：

```
<%@ taglib prefix="c" uri=http://java.sun.com/jsp/jstl/core" %>
```

| 标签           | 描述                                                                       |
| -------------- | -------------------------------------------------------------------------- |
| < c:out>       | 用于在JSP中输出数据，就像<%=...>                                           |
| < c:set>       | 保存数据                                                                   |
| < c:remove>    | 删除数据                                                                   |
| < c:catch>     | 处理产生错误的异常状况，并将错误信息存储起来                               |
| < c:if>        | 与判断条件if语句一样                                                       |
| < c:choose>    | 本身只作为< c:when>和< c:otherwise>的父标签                                |
| < c:when>      | 判断条件是否成立                                                           |
| < c:otherwise> | < c:choose>的子标签，接在< c:when>标签后面，当< c:when>标签为false时被执行 |
| < c:import>    | 检索一个绝对或相对URL，然后将其内容暴露给页面                              |
| < c:forEach>   | 基础迭代标签，接收多种集合类型                                             |
| < c:forTokens> | 根据指定的分隔符来分隔内容并迭代输出                                       |
| < c:param>     | 用于给包含或重定向的页面传递参数                                           |
| < c:redirect>  | 重定向一个新的URL                                                          |
| < c:url>       | 使用可选的查询参数来创造一个URL                                            |

<c:out value=””>：输出数据。

<c:if test=””>:test条件属性。

<c:set var=”” value=””>:保存数据，用于设置变量值和对象属性。

< c:choose>标签与Java switch语句的功能一样，用于在众多选项中做出选择。

switch语句中有case，而< c:choose>标签中对应有< c:when>，switch语句中有default，而< c:choose>标签中有< c:otherwise>。

只有<c:when test=” ”>才有一个tset属性，其他两个没有属性。

### 格式化标签

< fmt:message>:显示资源配置文件信息。

属性key:要检索的消息关键字。

< fmt:formatNumber>:使用指定的格式。

属性：

value   要显示的数字

type    NUMBER，CURRENCY，或 PERCENT类型

pattern  指定一个自定义的格式化模式用于输出

### JQuery部分

val() 方法：

val() 方法返回或设置被选元素的 value 属性。

当用于返回值时：

该方法返回第一个匹配元素的 value 属性的值。

当用于设置值时：

该方法设置所有匹配元素的 value 属性的值。

show()方法：显示隐藏的被选元素。

Hide()方法：则是隐藏被选元素。

### JavaScript部分

defer属性： 延迟脚本的执行。

PEGetElement("EEE").innerHTML = "";//获取id="EEE"的标签地址；

throwValidationAtEEE("请输入缴款编码!","EEE");//在判断中错误提醒；

PEGetPostData(oparams)//获取数据的方法；

### 设计模式

最常见的采用模板模式，责任链模式和单例模式

### 个人网银运维手册

**操作条件**

    应用整合平台系统业务无法使用，需要重启

**操作流程**

进入相关控制台停止相关的服务或启动服务检测

通过命令：ps –ef|grep 服务名称

通过查看进程是否存在来检测服务是否停止成功或启动成功。

**命令解释**

ps 命令的作用是显示进程信息的；

| 符号，是个管道符号，表示ps 和 grep 命令同时执行；

grep 是查找命令，能使用正则表达式搜索文本，然后把匹配的行显示出来；

ps命令参数描述：
-e : 显示所有进程
-f : 全格式 显示UID,PPIP,C与STIME栏位。

### Linux查看was进程连接数

1. 查看全部进程数

   ps -ef |wc -l
2. 查看httpd的进程数

   ps -ef |grep httpd |wc -l

### Linux查看当前TCP系统信息

cat /proc/net/netstat  --查看TCP系统信息

cat /proc/net/snmp   --查看当前系统的连接情况

netstat -s      --查看网络系统信息

### Linux查看所有进程

1. 在控制台，使用命令“ps -A”查看当前系统所有的进程。
2. 在控制台使用ps命令“ps -aux|less”，查看当前系统正在运行的所有进程。
3. 在控制台使用ps命令“ps -U root -u root -N”，查看当前系统中非root运行的所有进程。
4. 在控制台使用ps命令“ps -u test”，查看当前系统中test用户运行的所有进程。

### less命令使用

**less**的用法比起**more**更加有弹性，在使用**more**的时候，我们没有办法向前翻，只能往后面看。若使用了**less**之后，就可以更加便捷的查看数据了。

·     **空格键**：向下翻动一页

·    **[PageDown]**：向下翻动一页

·    **[PageUp]**：向上翻动一页

·    **/****字符串**：向下查询“字符串”的功能

·    **?****字符串**：向上查询“字符串”的功能

·    **n**：重复前一个查询（more向下）

·    **N**：反向重复前一个查询（more向上）

·    G - 移动到最后一行

·    g - 移动到第一行

·    m：标记位置a-z

·    '(单引号)：导航到标记处a-z

·    **q**：离开

### 查看日志、磁盘使用情况的常用命令

查看文件夹总大小

  \>>du -sh (附有文件大小的单位)

  \>>du -sk (没有文件大小的单位，默认的单位是字节byte)

查看指定文件夹的大小

  \>>du -sh /home/dxuser

查看文件大小的详细信息

  \>>ls -lsh

  \>>ls -alsh (包含隐藏文件的大小)

查看指定问件的大小详细信息

  \>>ls -lsh emd.log

 注意：以上两个命令du和ls，前者只能查看文件夹的大小，如果用du查看的目录下既有文件又有文件夹，此时不会显示文件夹下挂载的文件大小，只会显示文件夹本身的大小,而文件夹本身的大小是不包含它所挂载文件的大小。

查找文件

  \>>find . -size +100M ( 查找当前文件目录(含子目录)下大与100M的文件，当前目录用‘.’表示 )

  \>>find /home/dxuser -size +100M (查找指定目录下大于100M的文件)

查看磁盘的使用情况

\>>df –h

  显示时有四个重要参数：

   Size：磁盘的大小

   Used：已经使用的空间

   Avail：剩余可使用的空间

   Use%：使用的百分比

### AIX解压缩tar文件

tar –xvf bak.tar  --解压缩tar文件

tar -xzvf *file my.tar  --把多个文件压缩成tar文件
