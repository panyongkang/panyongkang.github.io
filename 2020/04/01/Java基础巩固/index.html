<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Java基础巩固 | 向阳榆木</title><meta name="description" content="Java基础巩固"><meta name="keywords" content="Java基础"><meta name="author" content="PanXiaoKang"><meta name="copyright" content="PanXiaoKang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Lotus.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="wyZknSW2XMDLHhrSvtifCN1aQwr2nn53ydI_lDzVJmI"/><meta name="baidu-site-verification" content="p1OeTLcEA8"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="Java基础巩固"><meta name="twitter:description" content="Java基础巩固"><meta name="twitter:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1499015010,895265431&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="Java基础巩固"><meta property="og:url" content="http://example.com/2020/04/01/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"><meta property="og:site_name" content="向阳榆木"><meta property="og:description" content="Java基础巩固"><meta property="og:image" content="https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1499015010,895265431&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://example.com/2020/04/01/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/"><link rel="prev" title="Java代码片段" href="http://example.com/2020/04/01/Java%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"><link rel="next" title="专业术语" href="http://example.com/2020/03/10/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"最近有点失眠了,每天被自己帅醒,帅早已成为负担,除了帅一无所有,富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"20px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/06/09/t40ARx.th.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">96</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">208</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="/sunshineBookshelf/"><i class="fa-fw fa fa-university"></i><span> 向阳书架</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://playground.z.wiki/typing-game/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 纪念空间</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D照片屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 青春校园</span></a></li><li><a class="site-page" href="/photo-wall/"><i class="fa-fw fa fa-th"></i><span> 生活日常</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li><li><a class="site-page" href="/timeStoryline/"><i class="fa-fw fa fa-video-camera"></i><span> 时间故事线</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的数据类型"><span class="toc-number">1.</span> <span class="toc-text">Java的数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型的封装类"><span class="toc-number">2.</span> <span class="toc-text">基本数据类型的封装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#什么叫包装类"><span class="toc-number">2.1.</span> <span class="toc-text">什么叫包装类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数类型和返回值类型"><span class="toc-number">3.</span> <span class="toc-text">参数类型和返回值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#变量的定义"><span class="toc-number">4.</span> <span class="toc-text">变量的定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用static修饰方法的好坏"><span class="toc-number">5.</span> <span class="toc-text">用static修饰方法的好坏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#public-static-void-main-String-args"><span class="toc-number">6.</span> <span class="toc-text">public static void main(String[] args)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#标识符"><span class="toc-number">7.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java中的名称命名规范"><span class="toc-number">8.</span> <span class="toc-text">Java中的名称命名规范</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本数据类型"><span class="toc-number">9.</span> <span class="toc-text">基本数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动类型提升"><span class="toc-number">9.1.</span> <span class="toc-text">自动类型提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#强制类型转换"><span class="toc-number">9.2.</span> <span class="toc-text">强制类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#String字符串"><span class="toc-number">9.3.</span> <span class="toc-text">String字符串</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#逻辑运算符"><span class="toc-number">10.</span> <span class="toc-text">逻辑运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#区分-amp-和-amp-amp"><span class="toc-number">10.1.</span> <span class="toc-text">区分&amp;和&amp;&amp;</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#位运算符"><span class="toc-number">11.</span> <span class="toc-text">位运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#程序流程控制"><span class="toc-number">12.</span> <span class="toc-text">程序流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#分支结构"><span class="toc-number">12.1.</span> <span class="toc-text">分支结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#Switch-case"><span class="toc-number">12.1.1.</span> <span class="toc-text">Switch-case</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#switch-case和if-else怎么选"><span class="toc-number">12.1.2.</span> <span class="toc-text">switch-case和if-else怎么选</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环结构"><span class="toc-number">12.2.</span> <span class="toc-text">循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#循环语句的四个组成部分"><span class="toc-number">12.2.1.</span> <span class="toc-text">循环语句的四个组成部分</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#衡量一个功能代码的优劣"><span class="toc-number">12.3.</span> <span class="toc-text">衡量一个功能代码的优劣</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">13.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#数组中常见的算法"><span class="toc-number">13.1.</span> <span class="toc-text">数组中常见的算法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#排序算法"><span class="toc-number">13.1.1.</span> <span class="toc-text">排序算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JVM的内存结构"><span class="toc-number">14.</span> <span class="toc-text">JVM的内存结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#栈（Stack）"><span class="toc-number">14.1.</span> <span class="toc-text">栈（Stack）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#堆（Heap）"><span class="toc-number">14.2.</span> <span class="toc-text">堆（Heap）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#常量池（Constant-Pool）"><span class="toc-number">14.3.</span> <span class="toc-text">常量池（Constant Pool）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法区（Method-Area）"><span class="toc-number">14.4.</span> <span class="toc-text">方法区（Method Area）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态域（Static-Field）"><span class="toc-number">14.5.</span> <span class="toc-text">静态域（Static Field）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结"><span class="toc-number">14.6.</span> <span class="toc-text">小结</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象"><span class="toc-number">15.</span> <span class="toc-text">面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#思想概述"><span class="toc-number">15.1.</span> <span class="toc-text">思想概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类中属性的使用"><span class="toc-number">15.2.</span> <span class="toc-text">类中属性的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#小结-1"><span class="toc-number">15.3.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#匿名对象的使用"><span class="toc-number">15.4.</span> <span class="toc-text">匿名对象的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#面向对象与面向过程（理解）"><span class="toc-number">15.5.</span> <span class="toc-text">面向对象与面向过程（理解）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法重写-Override-与重载-Overload"><span class="toc-number">16.</span> <span class="toc-text">方法重写(Override)与重载(Overload)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Java的值传递机制"><span class="toc-number">17.</span> <span class="toc-text">Java的值传递机制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#关于变量的赋值"><span class="toc-number">17.1.</span> <span class="toc-text">关于变量的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#针对于方法的参数概念"><span class="toc-number">17.2.</span> <span class="toc-text">针对于方法的参数概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Java中参数传递机制"><span class="toc-number">17.3.</span> <span class="toc-text">Java中参数传递机制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#封装和隐藏"><span class="toc-number">18.</span> <span class="toc-text">封装和隐藏</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#封装性的体现方式"><span class="toc-number">18.1.</span> <span class="toc-text">封装性的体现方式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承性"><span class="toc-number">19.</span> <span class="toc-text">继承性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态性"><span class="toc-number">20.</span> <span class="toc-text">多态性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#虚拟方法调用（多态情况下）"><span class="toc-number">20.1.</span> <span class="toc-text">虚拟方法调用（多态情况下）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#从编译和运行角度"><span class="toc-number">20.2.</span> <span class="toc-text">从编译和运行角度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Instanceof关键字的使用"><span class="toc-number">20.3.</span> <span class="toc-text">Instanceof关键字的使用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造器"><span class="toc-number">21.</span> <span class="toc-text">构造器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造器的作用"><span class="toc-number">21.1.</span> <span class="toc-text">构造器的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#说明"><span class="toc-number">21.2.</span> <span class="toc-text">说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this和super关键字"><span class="toc-number">22.</span> <span class="toc-text">this和super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaBean的使用"><span class="toc-number">23.</span> <span class="toc-text">JavaBean的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MVC设计模式"><span class="toc-number">24.</span> <span class="toc-text">MVC设计模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#DeBug调试"><span class="toc-number">25.</span> <span class="toc-text">DeBug调试</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#和equals-的区别"><span class="toc-number">26.</span> <span class="toc-text">&#x3D;&#x3D;和equals()的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#设计模式"><span class="toc-number">27.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#单例设计模式"><span class="toc-number">27.1.</span> <span class="toc-text">单例设计模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字"><span class="toc-number">28.</span> <span class="toc-text">static关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#final关键字"><span class="toc-number">29.</span> <span class="toc-text">final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代码块"><span class="toc-number">30.</span> <span class="toc-text">代码块</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#abstract抽象类"><span class="toc-number">31.</span> <span class="toc-text">abstract抽象类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#interface接口"><span class="toc-number">32.</span> <span class="toc-text">interface接口</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#内部类"><span class="toc-number">33.</span> <span class="toc-text">内部类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异常处理"><span class="toc-number">34.</span> <span class="toc-text">异常处理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#常见的异常"><span class="toc-number">34.1.</span> <span class="toc-text">常见的异常</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异常处理的抓抛模型"><span class="toc-number">34.2.</span> <span class="toc-text">异常处理的抓抛模型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#try-catch-finally的使用"><span class="toc-number">34.3.</span> <span class="toc-text">try-catch-finally的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#如何自定义异常类"><span class="toc-number">34.4.</span> <span class="toc-text">如何自定义异常类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#会话跟踪技术"><span class="toc-number">35.</span> <span class="toc-text">会话跟踪技术</span></a></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss1.bdstatic.com/70cFvXSh_Q1YnxGkpoWK1HF6hhy/it/u=1499015010,895265431&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">向阳榆木</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="/sunshineBookshelf/"><i class="fa-fw fa fa-university"></i><span> 向阳书架</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://playground.z.wiki/typing-game/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 纪念空间</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D照片屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 青春校园</span></a></li><li><a class="site-page" href="/photo-wall/"><i class="fa-fw fa fa-th"></i><span> 生活日常</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li><li><a class="site-page" href="/timeStoryline/"><i class="fa-fw fa fa-video-camera"></i><span> 时间故事线</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Java基础巩固</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-04-01 18:31:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2020-04-01</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-12-21 18:14:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2024-12-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%90%8E%E7%AB%AF%E6%8A%80%E6%9C%AF/">后端技术</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2020/04/01/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2020/04/01/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><p>虽然说框架满天飞，但打好地基很重要，整理一下基础知识，以备不时之需，毕竟好记性不如烂笔头，常回来看看老朋友。。。</p>
<hr>
<h3 id="Java的数据类型"><a href="#Java的数据类型" class="headerlink" title="Java的数据类型"></a>Java的数据类型</h3><ol>
<li>基本类型：long,int,byte,float,double,char</li>
<li>对象类型（类）： Long,Integer,Byte,Float,Double,String,其它一切java提供的，或者你自己创建的类。引用类型比较大小一定要用equals而不要用==。</li>
</ol>
<h3 id="基本数据类型的封装类"><a href="#基本数据类型的封装类" class="headerlink" title="基本数据类型的封装类"></a>基本数据类型的封装类</h3><table>
<thead>
<tr>
<th>数据类型</th>
<th>封装类/包装类</th>
</tr>
</thead>
<tbody><tr>
<td>boolean（布尔型）</td>
<td>Boolean</td>
</tr>
<tr>
<td>byte（字节型）</td>
<td>Byte</td>
</tr>
<tr>
<td>char（字符型）</td>
<td>Character</td>
</tr>
<tr>
<td>short（短整型）</td>
<td>Short</td>
</tr>
<tr>
<td>int（整型）</td>
<td>Integer</td>
</tr>
<tr>
<td>long（长整型）</td>
<td>Long</td>
</tr>
<tr>
<td>float（浮点型）</td>
<td>Float</td>
</tr>
<tr>
<td>double（双精度浮点型）</td>
<td>Double</td>
</tr>
</tbody></table>
<h4 id="什么叫包装类"><a href="#什么叫包装类" class="headerlink" title="什么叫包装类"></a><strong>什么叫包装类</strong></h4><p>在java中有时候的运算必须是两个类对象之间进行的，不充许对象与数字之间进行运算。所以需要有一个对象，这个对象把数字进行了一下包装，这样这个对象就可以和另一个对象进行运算了。byte: 八位整数 -128——127，可用来节省内存的使用。</p>
<p>short: 16位整数 -32768——32,767，也比较省内存。<br>int: 32位整数 -2,147,483,648——2,147,483,647，一般来说整数都够用了<br>long: 64位整数 -9,223,372,036,854,775,808—— 9,223,372,036,854,775,807，一般不需要用<br>float: 32位浮点，如果浮点需要节省内存用这个。<br>Double: 64位浮点，一般非整数浮点可用这个。</p>
<p>但是要记住float和double都不是精确的，如果要储存钱一类的必须精确的，用java.math.BigDecimal</p>
<p>为什么要有包装类（或封装类）？</p>
<p>为了使基本数据类型的变量具有类的特征，引入包装类。</p>
<h3 id="参数类型和返回值类型"><a href="#参数类型和返回值类型" class="headerlink" title="参数类型和返回值类型"></a>参数类型和返回值类型</h3><p>一个方法的返回值类型要是抽象类类型，那么就返回该抽象类的子类对象。<br>一个方法的返回值类型要是接口类型，那么就返回该接口类的子类对象。</p>
<h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3><p>局部变量：从属于方法或语句块，生命周期短，使用前必须先初始化赋值。<br>成员变量：从属于对象，生命周期较长，未赋值会自动被初始化。<br>静态变量：从属于类，生命周期最长。<br>在类中，使用static修饰的成员变量被称为静态成员变量（类变量）。<br>static修饰的变量和方法从属于类，普通变量和方法从属于对象的。</p>
<p>Java中主要用final来定义一个常量。Final String AGE=18相当于age=18,常量都是大写，所以是AGE;<br>定义方法时传递的参数是形式参数，调用该方法时传递的参数是实际参数，实参的数据类型必须与形参一一对应。</p>
<h3 id="用static修饰方法的好坏"><a href="#用static修饰方法的好坏" class="headerlink" title="用static修饰方法的好坏"></a>用static修饰方法的好坏</h3><p>在定义方法时不加static，在调用方法时就需要new该方法才能调用，如果在定义时加上static，就可以直接调用该方法而不需要new了。<br>好处：<br>1.当一个方法需要初始化加载或者经常被调用的时候可以加上 static<br>2.被 static 修饰的方法可以用类名直接调用，不用实例化一个对象后才调用<br>3.比如 person这个类里有一个方法 public static add () {} 那么可以使用 person.add();调用，当然也可以创建对象调用<br>比如 person p= new person();<br>p.add();调用<br>类加载器在加载这个类的时候就已经实例化了这个类</p>
<p>坏处：初始化加载比较占内存，所以不经常用的方法不建议加 static 这个关键字</p>
<h3 id="public-static-void-main-String-args"><a href="#public-static-void-main-String-args" class="headerlink" title="public static void main(String[] args)"></a><strong>public static void main(String[] args)</strong></h3><p>这是 Java 程序的入口地址，Java 虚拟机运行程序的时候首先找的就是 main 方法。跟 C 语言里面的 main() 函数的作用是一样的。只有有 main() 方法的 Java 程序才能够被 Java 虚拟机运行，可理解为规定的格式。</p>
<p>对于里面的参数及修饰符：</p>
<ul>
<li><strong>public</strong> ：表示的这个程序的访问权限，表示的是任何的场合可以被引用，这样 Java 虚拟机就可以找到 main() 方法,从而来运行 <strong>javac</strong> 程序。</li>
<li><strong>static</strong> ： 表明方法是静态的，不依赖类的对象的，是属于类的，在类加载的时候 main() 方法也随着加载到内存中去。由于在入口时，未调用任何对象，该方法只能设置为static静态。</li>
<li><strong>void:</strong> main()方法是不需要返回值的。JVM为Java的最底层，所以即使有返回结果，结果也无处可去，因此该方法必然是void无返回值。</li>
<li><strong>main</strong> ：约定俗成，规定的。</li>
<li><strong>String[] args</strong> ：从控制台接收参数。</li>
</ul>
<h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>1、标识符的使用：凡是自己可以起名字的地方都叫标识符。比如：类名、变量名、方法名、接口名、包名等等。。。</p>
<p>2、标识符的命名规则：</p>
<ul>
<li>由26个英文字母大小写，0-9，_或$组成</li>
<li>数字不可以开头</li>
<li>不可以使用关键字和保留字，但能包含关键字和保留字</li>
<li>Java中严格区分大小写，长度无限制</li>
<li>标识符不能包含空格</li>
</ul>
<h3 id="Java中的名称命名规范"><a href="#Java中的名称命名规范" class="headerlink" title="Java中的名称命名规范"></a>Java中的名称命名规范</h3><p>包名：多个单词组成时所有字母都小写：xxxyyyzzz</p>
<p>类名、接口名：多个单词组成时，所有单词的首字母大写：XxxYyyZzz</p>
<p>变量名、方法名：多个单词组成时，第一个单词首字母小写，第二个单词开始每个单词首字母大写：xxxYyyZzz</p>
<p>常量名：所有字母都大写，多个单词组成时每个单词用下划线连接：XXX_YYY_ZZZ</p>
<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><h4 id="自动类型提升"><a href="#自动类型提升" class="headerlink" title="自动类型提升"></a>自动类型提升</h4><pre><code>结论：当容量小的数据类型的变量与容量大的数据类型的变量做运算时，结果自动提升为容量大的数据类型(不包含boolean类型)</code></pre><p>byte、char、short–&gt;int–&gt;long–&gt;float–&gt;double</p>
<p>特别的：当byte、char、short三种类型的变量做运算时，结果为int型。</p>
<h4 id="强制类型转换"><a href="#强制类型转换" class="headerlink" title="强制类型转换"></a>强制类型转换</h4><p>自动类型提升运算的逆运算。</p>
<p>1、需要使用强转符：()</p>
<p>2、注意点：强制类型转换，可能导致精度降低或溢出。</p>
<h4 id="String字符串"><a href="#String字符串" class="headerlink" title="String字符串"></a>String字符串</h4><ol>
<li>String属于引用数据类型，翻译为：字符串</li>
<li>声明String类型变量时，使用一对””</li>
</ol>
<p>3.String可以和8种基本数据类型变量做运算，且运算符只能是连接运算：+</p>
<p>4.运算的结果仍然是String类型</p>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符操作的都是boolean类型的变量</p>
<h4 id="区分-amp-和-amp-amp"><a href="#区分-amp-和-amp-amp" class="headerlink" title="区分&amp;和&amp;&amp;"></a>区分&amp;和&amp;&amp;</h4><p>相同点1：运算结果都相同</p>
<p>相同点2：当符号左边是true时，二者都会执行符号右边的运算</p>
<p>不同点：当符号左边是false时，&amp;继续执行符号右边的运算，&amp;&amp;则不再执行符号右边的运算。</p>
<h3 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h3><p>1.位运算符操作的都是整型的数据</p>
<p>2.&lt;&lt;：在一定范围内，每向左移1位，相当于 * 2;</p>
<p>&gt;&gt;:在一定范围内，每向右移1位，相当于 / 2;</p>
<h3 id="程序流程控制"><a href="#程序流程控制" class="headerlink" title="程序流程控制"></a>程序流程控制</h3><ul>
<li>顺序结构、分支结构、循环结构</li>
</ul>
<h4 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h4><h5 id="Switch-case"><a href="#Switch-case" class="headerlink" title="Switch-case"></a>Switch-case</h5><ul>
<li>Switch结构中的表达式，只能是如下6种数据类型之一：byte、short、char、int、枚举类型（JDK5.0新增）、Sting类型（JDK7.0新增）</li>
<li>case之后只能声明常量，不能声明范围</li>
<li>break关键字是可选的</li>
<li>default：相当于if-else结构中的else,default结构是可选的，而且位置也是灵活的。</li>
</ul>
<h5 id="switch-case和if-else怎么选"><a href="#switch-case和if-else怎么选" class="headerlink" title="switch-case和if-else怎么选"></a>switch-case和if-else怎么选</h5><p>总结：</p>
<ul>
<li>凡是可以使用Switch-case的结构，都可以转换为if-else;反之，不成立；</li>
<li>我们写分支结构时，当发现既可以使用Switch-case（同时，Switch中表达式的取值情况不太多），又可以使用if-else时，我们优先选择使用switch-case。原因：switch-case执行效率稍高。</li>
</ul>
<h4 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h4><p>定义：在某些条件满足的情况下，反复执行特定代码的功能。</p>
<p>循环语句分类：</p>
<ul>
<li>for循环</li>
<li>while循环</li>
<li>do-while循环</li>
</ul>
<h5 id="循环语句的四个组成部分"><a href="#循环语句的四个组成部分" class="headerlink" title="循环语句的四个组成部分"></a>循环语句的四个组成部分</h5><ul>
<li>初始化部分</li>
<li>循环条件部分</li>
<li>循环体部分</li>
<li>迭代部分</li>
</ul>
<h4 id="衡量一个功能代码的优劣"><a href="#衡量一个功能代码的优劣" class="headerlink" title="衡量一个功能代码的优劣"></a>衡量一个功能代码的优劣</h4><ul>
<li>正确性</li>
<li>可读性</li>
<li>健壮性</li>
<li>高效率与低存储：时间复杂度和空间复杂度（衡量算法的好坏）</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>定义：数组是一种数据结构，它由一组相同类型的元素组成，这些元素在内存中连续存储，并可以通过索引（下标）访问和修改。</p>
<h4 id="数组中常见的算法"><a href="#数组中常见的算法" class="headerlink" title="数组中常见的算法"></a>数组中常见的算法</h4><h5 id="排序算法"><a href="#排序算法" class="headerlink" title="排序算法"></a>排序算法</h5><p><strong>衡量排序算法的优劣：</strong></p>
<ul>
<li>时间复杂度：分析关键字的比较次数和记录的移动次数</li>
<li>空间复杂度：分析排序算法中需要多少辅助内存</li>
<li>稳定性：若两个记录A和B的关键字值相等，但排序后A、B的先后次序保持不变，则称这种排序算法是稳定的。</li>
</ul>
<p><strong>排序算法的分类：</strong></p>
<p>内部排序和外部排序。</p>
<ul>
<li>内部排序：整个排序过程中不需要借助于外部存储器（如磁盘等），所有排序操作都在内存中完成。</li>
<li>外部排序：参与排序的数据非常多，数据量非常大，计算机无法把整个排序过程放在内存中完成，必须借助于外部存储器（如磁盘）。外部排序最常见的是多路 归并排序，可以认为外部排序是由多次内部排序组成。</li>
</ul>
<p><strong>十大内部排序算法：</strong></p>
<ul>
<li>选择排序<ul>
<li>直接选择排序、堆排序</li>
</ul>
</li>
<li>交换排序<ul>
<li>冒泡排序、快速排序</li>
</ul>
</li>
<li>插入排序<ul>
<li>直接插入排序、折半插入排序、Shell排序</li>
</ul>
</li>
<li>归并排序</li>
<li>桶式排序</li>
<li>基数排序</li>
</ul>
<h3 id="JVM的内存结构"><a href="#JVM的内存结构" class="headerlink" title="JVM的内存结构"></a>JVM的内存结构</h3><p>在JVM中，有几个重要的概念和组件，包括栈、堆、常量池、方法区和静态域。</p>
<h4 id="栈（Stack）"><a href="#栈（Stack）" class="headerlink" title="栈（Stack）"></a>栈（Stack）</h4><p>栈是一种基于后进先出（LIFO）的数据结构，用于存储方法调用的相关信息，如方法的参数、局部变量、返回地址等。在 Java 中，每个线程都有自己的栈，用于存储该线程的方法调用信息。当一个方法被调用时，会在栈上分配一块新的内存空间，用于存储该方法的参数和局部变量。当方法执行完毕时，这个内存空间会被释放。</p>
<p>举例来说，以下是一个简单的 Java 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = a + b;</span><br><span class="line">    System.out.println(sum);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当这个方法被调用时，在该方法的栈上会分配一些内存空间，用于存储参数 a 和 b，以及局部变量 sum。当方法执行完毕时，这些内存空间会被释放。</p>
<h4 id="堆（Heap）"><a href="#堆（Heap）" class="headerlink" title="堆（Heap）"></a>堆（Heap）</h4><p>堆是一种用于动态分配对象的内存区域。在 Java 中，所有的对象都在堆上分配内存。堆是一块共享的内存区域，所有线程都可以访问。当创建一个对象时，会在堆上分配一块新的内存空间，用于存储对象的数据。</p>
<p>举例来说，以下是一个简单的 Java 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当创建一个 Person 对象时，会在堆上分配一块新的内存空间，用于存储对象的数据。在这个例子中，Person 对象会包含一个 String 类型的 name 属性和一个 int类型的 age 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person(<span class="string">"John"</span>, <span class="number">30</span>);</span><br></pre></td></tr></table></figure>

<p>在这个例子中，p 是一个 Person 类型的对象，它被创建在堆上，并分配了一块内存空间来存储对象的数据。</p>
<h4 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h4><p>常量池是一种特殊的内存区域，用于存储常量和符号引用。在 Java 中，常量池主要用于存储字符串常量、数字常量和类、方法、字段等符号引用信息。</p>
<p>举例来说，以下是一个包含字符串常量和符号引用的 Java 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Constants</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String MESSAGE = <span class="string">"Hello, world!"</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIZE = <span class="number">100</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(MESSAGE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，字符串常量 “Hello, world!” 和整数常量 100 会被存储在常量池中。同时，静态常量 MESSAGE 和 SIZE 也会被存储在常量池中，它们的值是对常量池中字符串和数字常量的引用。当 main 方法被调用时，会从常量池中获取 MESSAGE 的值，并输出到控制台。</p>
<h4 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h4><p>方法区是一种用于存储类信息、常量池、静态变量等数据的内存区域。在 Java 中，每个类都有自己的方法区，用于存储类的信息和静态成员变量。方法区是堆的一部分，但是它有自己的内存管理机制。</p>
<p>举例来说，以下是一个包含静态变量的 Java 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Counter</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increment</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，静态变量 count 会被存储在方法区中，它的值在整个应用程序的生命周期内都是可见和共享的。当 increment 方法被调用时，会从方法区中获取 count 的值，并将其加 1。当 getCount 方法被调用时，也会从方法区中获取 count 的值并返回。</p>
<h4 id="静态域（Static-Field）"><a href="#静态域（Static-Field）" class="headerlink" title="静态域（Static Field）"></a>静态域（Static Field）</h4><p>静态域是一种类级别的变量，它属于类而不属于对象。在 Java 中，静态域可以被所有对象共享，也可以被类的所有方法访问。静态域通常用于存储类级别的信息和常量。</p>
<p>举例来说，以下是一个包含静态域的 Java 类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MathUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.141592653589793</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">square</span><span class="params">(<span class="keyword">double</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x * x;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">circleArea</span><span class="params">(<span class="keyword">double</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PI * square(r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这个例子中，静态域 PI 存储了圆周率的值，它可以被 MathUtils 类的所有方法访问。当 circleArea 方法被调用时，会从静态域 PI 中获取圆周率的值，并进行计算。</p>
<p>需要注意的是，栈、堆、常量池、方法区和静态域是 Java 运行时的重要组成部分，它们的实现和使用方式可能与不同的 Java 实现和版本有所不同。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><p>虚拟机栈，即为平时提到的栈机构。方法的参数和局部变量都存储在栈结构中。</p>
<p>堆：将new出来的结构（比如：数组、对象）加载到堆空间中。补充：对象的属性（非static的）加载在堆空间中。</p>
<p>方法区：类的加载信息、常量池、静态域</p>
<h3 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h3><h4 id="思想概述"><a href="#思想概述" class="headerlink" title="思想概述"></a>思想概述</h4><p>面向对象：把属性（成员变量）和方法放入一个类里面，类里面抽象出来共同点就是面向对象。</p>
<p><strong>面向对象的两个要素：</strong></p>
<p>类：对一类事物的描述，是抽象的、概念上的定义。</p>
<p>对象：是实际存在的该类事物的每个个体，因而也称为实例（instance）</p>
<ul>
<li>面向对象程序设计的重点是类的设计</li>
<li>设计类，就是设计类的成员</li>
</ul>
<h4 id="类中属性的使用"><a href="#类中属性的使用" class="headerlink" title="类中属性的使用"></a>类中属性的使用</h4><p> <strong>属性（成员变量）VS局部变量</strong><br> 1.相同点<br>  1.1 定义变量的格式：数据类型 变量名 =变量值<br>  1.2 先声明，后使用<br>  1.3 变量都有其对应的作用域</p>
<p> 2.不同点：<br>  2.1在类中毒声明的位置不同<br>  属性：直接定义在类的一对{}内<br>  局部变量：声明在方法内、方法形参、代码块内、构造器形参、构造器内部的变量</p>
<p>  2.2 关于权限修饰符的不同<br>  属性：可以在声明属性时，指明其权限，使用权限修饰符。<br>      常用的权限修饰符：private、public、缺省、protected —&gt;封装性<br>      目前，大家声明属性时，都使用缺省即可。</p>
<p>  局部变量：不可以使用权限修饰符</p>
<p>  2.3 默认初始值的情况<br>  属性：类的属性，根据其类型，都有默认初始化值</p>
<p>  局部变量：没有默认初始化值。<br>          意味着，我们调用局部变量之前，一定要显式赋值。<br>          特别的，形参在调用时，我们赋值即可。</p>
<p>  2.4 在内存中加载的位置<br>  属性：加载到堆空间中（非static）<br>  局部变量：加载到栈空间</p>
<h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><p>1.面向对象思想编程内容的三条主线分别是什么：</p>
<p>①类及类的成员：属性、方法、构造器、代码块、内部类</p>
<p>②面向对象的三大特征：封装、继承、多态</p>
<p>③其它关键字：this、super、abstract、interface、static、final、package、import</p>
<p>2.谈谈你对面向对象中类和对象的理解，并指出二者的关系？</p>
<p>类：抽象的、概念上的内容</p>
<p>对象：实实在在的一个个体。对象是由类派生出来的。</p>
<p>3.面向对象思想的体现一：类和对象的创建和执行操作由哪三步？</p>
<p>① 创建类</p>
<p>② 类的实例化</p>
<p>③ 调用对象的结构：”对象.属性” “对象.方法”</p>
<h4 id="匿名对象的使用"><a href="#匿名对象的使用" class="headerlink" title="匿名对象的使用"></a>匿名对象的使用</h4><ul>
<li>理解：我们创建的对象，没有显式的赋给一个变量名，即为匿名对象</li>
<li>特征：匿名对象只能调用一次</li>
</ul>
<h4 id="面向对象与面向过程（理解）"><a href="#面向对象与面向过程（理解）" class="headerlink" title="面向对象与面向过程（理解）"></a>面向对象与面向过程（理解）</h4><p>1.面向过程：强调的是功能行为，以函数为最小单位，考虑怎么做。</p>
<p>2.面向对象：强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。</p>
<p>递归方法：自己调用自己，但要写递归头和递归体，否则陷入死循环，直到占满内容溢出为止。递归是很耗费时间和内存资源的，尽量不要使用，百度的爬虫就是递归，在一个页面不断点击进入下一个页面那种，一般使用迭代循环方法就能满足普通开发。</p>
<h3 id="方法重写-Override-与重载-Overload"><a href="#方法重写-Override-与重载-Overload" class="headerlink" title="方法重写(Override)与重载(Overload)"></a>方法重写(Override)与重载(Overload)</h3><p>方法重载：参数的个数、类型和顺序不同，都可以构成重载。方法中参数只有返回值不同、参数只有名称不同，都不构成重载。（跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">* 方法的重载（overload） loading……</span><br><span class="line">* 1.定义：在同一个类中，允许存在一个以上的同名方法，只要它们的参数个数或参数类型不同即可。</span><br><span class="line">*</span><br><span class="line">*  &quot;两同一不同“：同一个类、相同方法名</span><br><span class="line">*          参数列表不同：参数个数不同、参数类型不同</span><br><span class="line">*</span><br><span class="line">* 2.举例：</span><br><span class="line">*      Arrays类中重载的sort()&#x2F;binarySearch()</span><br><span class="line">*</span><br><span class="line">* 3.判断是否是重载：</span><br><span class="line">*      跟方法的权限修饰符、返回值类型、形参变量名、方法体都没有关系！</span><br><span class="line">*</span><br><span class="line">* 4.在通过对象调用方法时，如何确定某一个指定的方法：</span><br><span class="line">*      方法名---&gt;参数列表</span><br></pre></td></tr></table></figure>

<p>方法重写：在子类中可以根据需要对从父类中继承来的方法进行改造，也称为方法的重置、覆盖、在程序执行时，子类的方法将覆盖父类的方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* 方法的重写（override&#x2F;overwrite）</span><br><span class="line">*</span><br><span class="line">* 1.重写：子类继承父类以后，可以对父类中同名同参的方法，进行覆盖操作</span><br><span class="line">* 2.应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参的方法时，实际执行的是子类重写父类的方法。</span><br><span class="line">* 3.重写的规定：</span><br><span class="line">*      方法声明：权限修饰符 返回值类型 方法名（形参列表）throws 异常的类型&#123;</span><br><span class="line">*          &#x2F;&#x2F;方法体</span><br><span class="line">*      &#125;</span><br><span class="line">*      约定俗称：子类中的叫重写的方法，父类中的叫被重写的方法</span><br><span class="line">*    ① 子类重写的方法的方法名和形参列表与父类被重写的方法的方法名和形参列表相同</span><br><span class="line">*    ② 子类重写的方法的权限修饰符不小于父类被重写的方法的权限修饰符</span><br><span class="line">*          &gt;特殊情况，子类不能重写父类中声明为private权限的方法</span><br><span class="line">*    ③ 返回值类型：</span><br><span class="line">*          &gt;父类被重写的方法的返回值类型是void，则子类重写的方法的返回值类型只能是void</span><br><span class="line">*          &gt;父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型可以是A类或A类的子类</span><br><span class="line">*          &gt;父类被重写的方法的返回值类型是基本数据类型（比如：double），则子类重写的方法的返回值类型必须是相同的基本数据类型（必须也是double）</span><br><span class="line">*    ④ 子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型</span><br><span class="line">*******************************************************************</span><br><span class="line">*      子类和父类中同名同参数的方法要么都声明为非static的（考虑重写），要么都声明为static的（此时不是重写）。</span><br></pre></td></tr></table></figure>

<h3 id="Java的值传递机制"><a href="#Java的值传递机制" class="headerlink" title="Java的值传递机制"></a>Java的值传递机制</h3><h4 id="关于变量的赋值"><a href="#关于变量的赋值" class="headerlink" title="关于变量的赋值"></a>关于变量的赋值</h4><ul>
<li>如果变量是基本数据类型，此时赋值的是变量所保存的数据值。</li>
<li>如果变量是引用数据类型，此时赋值的是变量所保存的数据的地址值。</li>
</ul>
<h4 id="针对于方法的参数概念"><a href="#针对于方法的参数概念" class="headerlink" title="针对于方法的参数概念"></a>针对于方法的参数概念</h4><p>形参：方法定义时，声明的小括号内的参数</p>
<p>实参：方法调用时，实际传递给形参的数据</p>
<h4 id="Java中参数传递机制"><a href="#Java中参数传递机制" class="headerlink" title="Java中参数传递机制"></a>Java中参数传递机制</h4><p><strong>值传递规则</strong></p>
<ul>
<li>如果参数是基本数据类型，此时实参赋给形参的是实参真实存储的数据值。</li>
<li>如果参数是引用数据类型，此时实参赋给形参的是实参存储数据的地址值。</li>
</ul>
<h3 id="封装和隐藏"><a href="#封装和隐藏" class="headerlink" title="封装和隐藏"></a>封装和隐藏</h3><p>我们程序设计追求“高内聚，低耦合”。</p>
<ul>
<li>高内聚：类的内部数据操作细节自己完成，不允许外部干涉。</li>
<li>低耦合：仅对外暴露少量的方法用于使用。</li>
</ul>
<h4 id="封装性的体现方式"><a href="#封装性的体现方式" class="headerlink" title="封装性的体现方式"></a>封装性的体现方式</h4><ul>
<li>将类的属性私有化（private），同时，提供公共的（public）方法来获取（getXXX）和设置（setXXX）此属性的值.</li>
<li>不对外暴露的私有方法</li>
<li>单例模式（将构造器私有化）</li>
<li>如果不希望类在包外被调用，可以将类设置为缺省的。</li>
</ul>
<p>Java规定的四种权限修饰符：</p>
<p>从小到大顺序为：private&lt;缺省&lt;protected&lt;public</p>
<p>具体修饰范围：</p>
<p><img src="/img/loading.gif" class="lazyload" data-src="image/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/1686369340092.png"  alt="1686369340092"></p>
<h3 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">* 一、继承性的好处：</span><br><span class="line">* ① 减少了代码的冗余，提高了代码的复用性</span><br><span class="line">* ② 便于功能的拓展</span><br><span class="line">* ③ 为之后多态性的使用，提供了前提</span><br><span class="line">*</span><br><span class="line">* 二、继承性的格式：class A extends B&#123;&#125;</span><br><span class="line">*  A:子类、派生类、subclass</span><br><span class="line">*  B:父类、超类、基类、superclass</span><br><span class="line">*</span><br><span class="line">*  2.1 体现：一旦子类A继承父类B以后，子类A中就获取了父类B中声明的所有的属性和方法</span><br><span class="line">*  特别的，父类中声明为private的属性或方法，子类继承父类以后，仍然认为获取了父类中私有的结构。</span><br><span class="line">*  只是因为封装性的影响，使得子类不能直接调用父类的结构而已。</span><br><span class="line">*</span><br><span class="line">*  2.2 子类继承父类以后，还可以声明自己特有的属性或方法：实现功能的拓展。</span><br><span class="line">*  子类和父类的关系，不同于子集和集合的关系。</span><br><span class="line">*  extends:延展、扩展</span><br><span class="line">*</span><br><span class="line">* 三、Java中关于继承性的规定：</span><br><span class="line">*      1.一个类可以被多个子类继承。</span><br><span class="line">*      2.Java中类的单继承性：一个类只能有一个父类</span><br><span class="line">*      3.子父类是相对的概念</span><br><span class="line">*      4.子类直接继承的父类，称为：直接父类。间接继承的父类，称为：间接父类</span><br><span class="line">*      5.子类继承父类以后，就获取了直接父类以及所有间接父类中声明的属性和方法。</span><br><span class="line">*</span><br><span class="line">* 四、1.如果我们没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类</span><br><span class="line">*    2.所有的java类（除java.lang.Object类之外）都直接或间接继承于java.lang.Object类。</span><br><span class="line">*    3.意味着，所有的java类具有java.lang.Object类声明的功能。</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h3><p>1.理解多态性：可以理解为一个事物的多种形态。<br>2.何为多态性：<br> 对象的多态性：父类的引用指向子类对象（或子类的对象赋给父类的引用）<br>3.多态的使用：虚拟方法调用<br> 有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。<br> 总结：编译，看左边，运行，看右边。<br>4.多态性的使用前提：① 类的继承关系 ② 方法的重写<br>5.对象的多态性，只适用于方法，不适用于属性（编译和运行都看左边）</p>
<h4 id="虚拟方法调用（多态情况下）"><a href="#虚拟方法调用（多态情况下）" class="headerlink" title="虚拟方法调用（多态情况下）"></a>虚拟方法调用（多态情况下）</h4><p>子类中定义了与父类同名同参数的方法，在多态情况下，将此时父类的方法称为虚拟方法。父类根据赋给它的不同子类对象，动态调用属于子类的该方法。这样的方法调用在编译期是无法确定的。</p>
<h4 id="从编译和运行角度"><a href="#从编译和运行角度" class="headerlink" title="从编译和运行角度"></a>从编译和运行角度</h4><p>对于重载而言：在方法调用之前，编译器就已经确定了所要调用的方法，这称为“早绑定”或“静态绑定”</p>
<p>而对于多态，只有等到方法调用的那一刻，解释运行器才会确定所要调用的具体方法，这称为“晚绑定”或“动态绑定”。</p>
<h4 id="Instanceof关键字的使用"><a href="#Instanceof关键字的使用" class="headerlink" title="Instanceof关键字的使用"></a>Instanceof关键字的使用</h4><p><img src="/img/loading.gif" class="lazyload" data-src="image/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/1687496560763.png"  alt="1687496560763"></p>
<h3 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h3><p>1.通过new关键字调用。<br>2.构造器有返回值，但不能定义返回值类型，即可以return，但不能返回值。<br>3.如果我们没有定义一个构造器，编译器会自动定义一个无参的构造函数。<br>4.构造方法名字必须要与类名相同。</p>
<h4 id="构造器的作用"><a href="#构造器的作用" class="headerlink" title="构造器的作用"></a>构造器的作用</h4><ul>
<li>创建对象</li>
<li>初始化对象的信息</li>
</ul>
<h4 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h4><ul>
<li>如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器</li>
<li>定义构造器的格式：权限修饰符 类名(形参列表){}</li>
<li>一个类中定义的多个构造器，彼此构成重载</li>
<li>一旦我们显式的定义了类的构造器之后，系统就不再提供默认的空参构造器</li>
<li>一个类中，至少会有一个构造器</li>
</ul>
<h3 id="this和super关键字"><a href="#this和super关键字" class="headerlink" title="this和super关键字"></a>this和super关键字</h3><p>调用构造器注意点：</p>
<p>this(形参列表):本类重载的其它的构造器</p>
<p>super(形参列表):调用父类中指定的构造器</p>
<blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* super关键字的使用</span><br><span class="line">* 1.super理解为：父类的</span><br><span class="line">* 2.super可以用来调用：属性、方法、构造器</span><br><span class="line">*</span><br><span class="line">* 3.super的使用</span><br><span class="line">*      3.1 我们可以在子类的方法或构造器中。通过使用“super.属性”或“super.方法”的方式，显式的调用</span><br><span class="line">*      父类中声明的属性和方法。但是，通常情况下，我们习惯省略&quot;super.&quot;</span><br><span class="line">*      3.2 特殊情况，当子类和父类中定义了同名的属性时，我们要想在子类中调用父类中声明的属性，</span><br><span class="line">*      则必须显式的使用“super.属性”的方式，表明调用的是父类中声明的属性。</span><br><span class="line">*      3.3 当子类重写了父类中的方法以后，我们想在子类的方法中调用父类中被重写的方法时，则必须显式的</span><br><span class="line">*      使用“super.方法”的方式，表明调用的是父类中被重写的方法。</span><br><span class="line">*</span><br><span class="line">* 4.super调用构造器</span><br><span class="line">*      4.1 我们可以在子类的构造器中显式的使用“super(形参列表)”的方式，调用父类中声明的指定的构造器</span><br><span class="line">*      4.2 “super(形参列表)”的使用，必须声明在子类构造器的首行!</span><br><span class="line">*      4.3 我们在类的构造器中，针对于“this(形参列表)”或“super(形参列表)”只能二选一，不能同时出现</span><br><span class="line">*      4.4 在构造器的首行，没有显示的声明“this(形参列表)”或“super(形参列表)”,则默认调用的是父类中</span><br><span class="line">*      空参的构造器：super()</span><br><span class="line">*      4.5 在类的多个构造器中，至少有一个类的构造器中使用了“super(形参列表)”，调用父类中的构造器</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="JavaBean的使用"><a href="#JavaBean的使用" class="headerlink" title="JavaBean的使用"></a>JavaBean的使用</h3><p>描述：JavaBean是一种Java语言写成的可重用组件。</p>
<p>所谓JavaBean,是值符合如下标准的Java类：</p>
<ul>
<li>类是公共的</li>
<li>有一个无参的公共的构造器</li>
<li>有属性，且有对应的get、set方法</li>
</ul>
<h3 id="MVC设计模式"><a href="#MVC设计模式" class="headerlink" title="MVC设计模式"></a>MVC设计模式</h3><p><img src="/img/loading.gif" class="lazyload" data-src="image/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/1686236975009.png"  alt="1686236975009"></p>
<h3 id="DeBug调试"><a href="#DeBug调试" class="headerlink" title="DeBug调试"></a>DeBug调试</h3><p><img src="/img/loading.gif" class="lazyload" data-src="image/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/1686411719261.png"  alt="1686411719261"></p>
<h3 id="和equals-的区别"><a href="#和equals-的区别" class="headerlink" title="==和equals()的区别"></a>==和equals()的区别</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">* 一、回顾&#x3D;&#x3D;的使用：</span><br><span class="line">* &#x3D;&#x3D;：运算符</span><br><span class="line">*  1.可以使用在基本数据类型变量和引用数据类型变量中</span><br><span class="line">*  2.如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）</span><br><span class="line">*    如果比较的是引用数据类型变量：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</span><br><span class="line">*  补充：&#x3D;&#x3D;符号使用时，必须保证符号左右两边的变量类型一致。</span><br><span class="line">*</span><br><span class="line">* 二、equals()方法的使用：</span><br><span class="line">*  1.是一个方法，而非运算符</span><br><span class="line">*  2.只能适用于引用数据类型</span><br><span class="line">*  3.Object类中equals()的定义：</span><br><span class="line">*      public boolean equals(Object obj) &#123;</span><br><span class="line">*              return (this &#x3D;&#x3D; obj);</span><br><span class="line">*          &#125;</span><br><span class="line">*      说明：Object类中定义的equals()和&#x3D;&#x3D;的作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个对象实体</span><br><span class="line">*</span><br><span class="line">*  4.像String、Date、File、包装类等都重写了Object类中的equals()方法。重写以后，比较的不是</span><br><span class="line">*    两个引用的地址是否相同，而是比较的两个对象的“实体内容”是否相同。</span><br><span class="line">*</span><br><span class="line">*  5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的“实体内容”是否相同。</span><br><span class="line">*  那么，我们就需要对Object类中的equals()进行重写</span><br><span class="line">*  重写的原则：比较两个对象的实体内容是否相同。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><p>概念：设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式。</p>
<h4 id="单例设计模式"><a href="#单例设计模式" class="headerlink" title="单例设计模式"></a>单例设计模式</h4><p>要解决的问题：所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例。</p>
<p>饿汉式：</p>
<ul>
<li>坏处：对象加载时间过长，会造成资源的浪费。</li>
<li>好处：是线程安全的。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//饿汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bank</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化类的构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Bank</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.内部创建类的对象</span></span><br><span class="line"><span class="comment">//4.要求此对象也必须声明为静态的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Bank instance =<span class="keyword">new</span> Bank();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.提供公共的静态的方法，返回类的对象</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bank <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>懒汉式：</p>
<ul>
<li>坏处：非线程安全，实现相对复杂，需要考虑线程安全性和性能等问题，需要额外的代码来处理。</li>
<li>好处：延迟加载对象，避免资源的浪费。</li>
</ul>
<p>代码示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//懒汉式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Order</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.私有化构造器</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Order</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.声明当前类对象，没有初始化</span></span><br><span class="line"><span class="comment">//4.此对象也必须声明为static的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Order instance =<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.声明public、static的返回当前类对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Order <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance==<span class="keyword">null</span>)&#123;</span><br><span class="line">            instance =<span class="keyword">new</span> Order();</span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单例模式的优点：减少了系统性能的开销。</p>
<p>应用场景：</p>
<ul>
<li>网站的计数器</li>
<li>应用程序的日志应用</li>
<li>数据库连接池</li>
<li>读取配置文件的类</li>
<li>Application</li>
<li>Windows的任务管理器、回收站。</li>
</ul>
<h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">* 1.static：静态的</span><br><span class="line">* 2.static可以用来修饰：属性、方法、代码块、内部类</span><br><span class="line">*</span><br><span class="line">* 3.使用static修饰属性：静态变量（类变量）</span><br><span class="line">*      3.1 属性，按是否使用static修饰，又分为：静态属性 vs 非静态属性（实例变量）</span><br><span class="line">*      实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。</span><br><span class="line">*              当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。</span><br><span class="line">*      静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，</span><br><span class="line">*              会导致其他对象调用此静态变量时，是修改过了的。</span><br><span class="line">*      3.2 static修饰属性的其他说明：</span><br><span class="line">*          ① 静态变量随着类的加载而加载。可以通过“类.静态变量&quot;的方式进行调用</span><br><span class="line">*          ② 静态变量的加载要早于对象的创建。</span><br><span class="line">*          ③ 由于类只会加载一次，则静态变量在内存中也只会存在一份。存在方法区的静态域中。</span><br><span class="line">*</span><br><span class="line">*          ④       类变量  实例变量</span><br><span class="line">*              类   yes    no</span><br><span class="line">*              对象  yes   yes</span><br><span class="line">*</span><br><span class="line">*      3.3 静态属性举例：System.out、Match.PI；</span><br><span class="line">*</span><br><span class="line">* 4.使用static修饰方法：静态方法</span><br><span class="line">*      ① 随着类的加载而加载，可以通过&quot;类.方法&quot;进行调用</span><br><span class="line">*      ②     静态方法  非静态方法</span><br><span class="line">*          类   yes    no</span><br><span class="line">*          对象 yes   yes</span><br><span class="line">*      ③ 静态方法中，只能调用静态的方法或属性</span><br><span class="line">*         非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性</span><br><span class="line">*</span><br><span class="line">* 5.static注意点：</span><br><span class="line">*      5.1 在静态的方法内，不能使用this关键字、super关键字</span><br><span class="line">*      5.2 关于静态属性和静态方法的使用，大家都从生命周期的角度去理解。</span><br><span class="line">*</span><br><span class="line">* 6.开发中如何确定一个属性是否要声明为static的？</span><br><span class="line">*    &gt; 属性是可以被多个对象所共享的，不会随着对象的不同而不同的。</span><br><span class="line">*    &gt; 类中的常量也常常声明为static</span><br><span class="line">*</span><br><span class="line">*   开发中如何确定一个方法是否要声明为static的？</span><br><span class="line">*    &gt; 操作静态属性的方法，通常设置为static的</span><br><span class="line">*    &gt; 工具类中的方法，习惯上声明为static的。比如：Math、Arrays、Collections</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">* final:最终的</span><br><span class="line">*</span><br><span class="line">* 1.final可以用来修饰的结构：类、方法、变量</span><br><span class="line">*</span><br><span class="line">* 2.final 用来修饰一个类:此类不能被其他类所继承。</span><br><span class="line">*      比如：String类、System类、StringBuffer类</span><br><span class="line">*</span><br><span class="line">* 3.final 用来修饰方法：表明此方法不可以被重写</span><br><span class="line">*      比如：Object类中getClass();</span><br><span class="line">*</span><br><span class="line">* 4.final 用来修饰变量：此时的”变量“就称为是一个常量</span><br><span class="line">*      4.1final修饰属性：可以考虑赋值的位置有：显式初始化、代码块中初始化、构造器中初始化</span><br><span class="line">*      4.2final修饰局部变量：</span><br><span class="line">*              尤其是使用final修饰形参时，表明此时形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。</span><br><span class="line">*              一旦赋值以后，就只能在方法体内使用此形参，但不能重新赋值。</span><br><span class="line">*</span><br><span class="line">* static final用来修饰属性：全局常量</span><br></pre></td></tr></table></figure>

<h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">* 1.代码块的作用：用来初始化类、对象的信息</span><br><span class="line">* 2.代码块如果有修饰的话，只能使用static</span><br><span class="line">* 3.分类：静态代码块 VS 非静态代码块</span><br><span class="line">*</span><br><span class="line">* 4.静态代码块</span><br><span class="line">*      &gt;内部可以有输出语句</span><br><span class="line">*      &gt;随着类的加载而执行，且只执行一次</span><br><span class="line">*      &gt;作用：初始化类的信息</span><br><span class="line">*      &gt;如果一个类中定义了多个静态代码块，则按照声明的先后顺序执行</span><br><span class="line">*      &gt;静态代码块的执行要优先于非静态代码块的执行</span><br><span class="line">*      &gt;静态代码块内只能调用静态的属性、静态的方法，不能调用非静态的结构</span><br><span class="line">*</span><br><span class="line">* 5.非静态代码块</span><br><span class="line">*      &gt;内部可以有输出语句</span><br><span class="line">*      &gt;随着对象的创建而执行，每创建一个对象，就执行一次非静态代码块</span><br><span class="line">*      &gt;作用：可以在创建对象时，对对象的属性等进行初始化</span><br><span class="line">*      &gt;如果一个类中定义了多个非静态代码块，则按照声明的先后顺序执行</span><br><span class="line">*      &gt;非静态代码块内可以调用静态的属性、方法，也可以调用非静态的属性、方法</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<p>实例化子类对象时，涉及到父类、子类中静态代码块、非静态代码块、构造器的加载顺序总结为：由父及子，静态先行。</p>
<h3 id="abstract抽象类"><a href="#abstract抽象类" class="headerlink" title="abstract抽象类"></a>abstract抽象类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">* abstract关键字的使用</span><br><span class="line">*  1.abstract：抽象的</span><br><span class="line">*  2.abstract可以用来修饰的结构：类、方法</span><br><span class="line">*</span><br><span class="line">*  3.abstract修饰类：抽象类</span><br><span class="line">*      &gt;此类不能实例化</span><br><span class="line">*      &gt;抽象类一定有构造器，便于子类实例化时调用（涉及：子类对象实例化的全过程）</span><br><span class="line">*      &gt;开发中，都会提供抽象类的子类，让子类对象实例化，完成相关的操作</span><br><span class="line">*</span><br><span class="line">*  4.abstract修饰方法：抽象方法</span><br><span class="line">*      &gt;抽象方法只有方法的声明，没有方法体</span><br><span class="line">*      &gt;包含抽象方法的类，一定是一个抽象类。反之，抽象类中可以没有抽象方法的。</span><br><span class="line">*      &gt;若子类重写了父类中的所有的抽象方法后，此子类方可实例化</span><br><span class="line">*      &gt;若子类没有重写父类中的所有的抽象方法，则此子类也是一个抽象类，需要使用abstract修饰</span><br><span class="line"></span><br><span class="line">* abstract使用上的注意点：</span><br><span class="line">*  1.abstract不能用来修饰：属性、构造器等结构</span><br><span class="line">*</span><br><span class="line">*  2.abstract不能用来修饰私有方法、静态方法、final的方法、final的类</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h3 id="interface接口"><a href="#interface接口" class="headerlink" title="interface接口"></a>interface接口</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* 1.接口使用interface来定义</span><br><span class="line">* 2.Java中，接口和类是并列的两个结构</span><br><span class="line">* 3.如何定义接口：定义接口中的成员</span><br><span class="line">*      3.1 JDK7及以前：只能定义全局常量和抽象方法</span><br><span class="line">*          &gt;全局常量：public static final的。但是书写时，可以省略不写</span><br><span class="line">*          &gt;抽象方法：public abstract的</span><br><span class="line">*</span><br><span class="line">*      3.2 JDK8:除了定义全局常量和抽象方法之外，还可以定义静态方法、默认方法（略）</span><br><span class="line">*</span><br><span class="line">* 4.接口中不能定义构造器的！意味着接口不可以实例化</span><br><span class="line">*</span><br><span class="line">* 5.Java开发中，接口通过让类去实现（implement）的方式来使用。</span><br><span class="line">*   如果实现类覆盖了接口中的所有抽象方法，则此实现类就可以实例化</span><br><span class="line">*   如果实现类没有覆盖接口中的所有的抽象方法，则此实现类仍为一个抽象类</span><br><span class="line">*</span><br><span class="line">* 6.Java可以实现多个接口---&gt;弥补了Java单继承的局限性</span><br><span class="line">*      格式：class AA extends BB implements CC,DD,EE</span><br><span class="line">*</span><br><span class="line">* 7.接口与接口之间可以继承，而且可以多继承</span><br><span class="line">*</span><br><span class="line">* ***************************************</span><br><span class="line"> * 接口的使用</span><br><span class="line"> *  1.接口使用上也满足多态性</span><br><span class="line"> *  2.接口：实际上是定义了一种规范</span><br><span class="line"> *  3.开发中，体会面向接口编程！</span><br><span class="line"></span><br><span class="line">Java8中关于接口的新规范：</span><br><span class="line">	&#x2F;&#x2F;知识点1：接口中定义的静态方法，只能通过接口来调用。</span><br><span class="line">        &#x2F;&#x2F;知识点2：通过实现类的对象，可以调用接口中的默认方法</span><br><span class="line">        &#x2F;&#x2F;如果实现类重写了接口中的默认方法，调用时，仍然调用的是重写以后的方法</span><br><span class="line">        &#x2F;&#x2F;知识点3：如果子类（或实现类）继承的父类和实现的接口中声明同名同参数的方法，</span><br><span class="line">        &#x2F;&#x2F;那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法。---&gt;类优先原则</span><br><span class="line">        &#x2F;&#x2F;知识点4：如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，</span><br><span class="line">        &#x2F;&#x2F;那么在实现类没有重写此方法的情况下，报错。---&gt;接口冲突。</span><br><span class="line">        &#x2F;&#x2F;这就需要我们必须在实现类中重写此方法</span><br><span class="line">	&#x2F;&#x2F;知识点5：如何在子类（或实现类）的方法中调用父类、接口中被重写的方法</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">* 1.Java中允许将一个类A声明在另一个类B中，则类A就是内部类，类B称为外部类。</span><br><span class="line">* 2.内部类的分类：成员内部类（静态、非静态） VS 局部内部类（方法内、代码块、构造器内）</span><br><span class="line">* 3.成员内部类：</span><br><span class="line">*      一方面，作为外部类的成员：</span><br><span class="line">*          &gt; 调用外部类的结构</span><br><span class="line">*          &gt; 可以被static修饰</span><br><span class="line">*          &gt; 可以被4种不同的权限修饰</span><br><span class="line">*</span><br><span class="line">*      另一方面，作为一个类：</span><br><span class="line">*          &gt;类内可以定义属性、方法、构造器等</span><br><span class="line">*          &gt; 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</span><br><span class="line">*          &gt; 可以被abstract修饰</span><br><span class="line">*</span><br><span class="line">* 4.关注如下的3个问题</span><br><span class="line">*      4.1如何实例化成员内部类的对象</span><br><span class="line">*      4.2如何在成员内部类中区分调用外部类的结构</span><br><span class="line">*      4.3开发中局部内部类的使用：见InnerClassTest1.java</span><br><span class="line">*</span><br><span class="line">*注意点：</span><br><span class="line">*在局部内部类的方法中（比如:show）如果调用局部内部类所声明的方法（比如：method）中的局部变量（比如：num）,要求此局部变量声明为final的。</span><br><span class="line">* jdk 7及之前的版本：要求此局部变量显式的声明为final的</span><br><span class="line">* jdk 8及之后的版本：可以省略final的声明</span><br><span class="line">*</span><br><span class="line">*总结：</span><br><span class="line">*成员内部类和局部内部类，在编译以后，都会生成字节码文件。</span><br><span class="line">*格式：成员内部类：外部类$内部类名.class</span><br><span class="line">*      局部内部类：外部类$数字 内部类名.class</span><br><span class="line">*</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>编译时异常：执行javac.exe命名时，可能出现的异常</p>
<p>运行时异常：执行java.exe命名时，出现的异常</p>
<h4 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">* 一、异常体系结构：</span><br><span class="line">* java.lang.Throwable</span><br><span class="line">*      |-----java.lang.Error:一般不编写针对性的代码进行处理。</span><br><span class="line">*      |-----java.lang.Exception:可以进行异常的处理</span><br><span class="line">*          |-----编译时异常（checked）</span><br><span class="line">*              |-----IOException</span><br><span class="line">*                  |-----FileNotFoundException</span><br><span class="line">*              |-----ClassNotFoundException</span><br><span class="line">*          |-----运行时异常（unchecked&#x2F;RuntimeException）</span><br><span class="line">*              |-----NullPointerException</span><br><span class="line">*              |-----ArrayIndexOutOfBoundsException</span><br><span class="line">*              |-----ClassCastException</span><br><span class="line">*              |-----NumberFormatException</span><br><span class="line">*              |-----InputMismatchException</span><br><span class="line">*              |-----ArithmeticException</span><br></pre></td></tr></table></figure>

<h4 id="异常处理的抓抛模型"><a href="#异常处理的抓抛模型" class="headerlink" title="异常处理的抓抛模型"></a>异常处理的抓抛模型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">* 过程一：“抛”：程序在正常执行的过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象。</span><br><span class="line">*          并将此对象抛出。</span><br><span class="line">*          一旦抛出对象以后，其后的代码就不再执行。</span><br><span class="line">*</span><br><span class="line">*          关于异常对象的产生：① 系统自动生成的异常对象</span><br><span class="line">*                          ② 手动的生成一个异常对象，并抛出（throw）</span><br><span class="line">*</span><br><span class="line">* 过程二：“抓“：可以理解为异常的处理方式：① try-catch-finally  ②throws</span><br><span class="line">*</span><br></pre></td></tr></table></figure>

<h4 id="try-catch-finally的使用"><a href="#try-catch-finally的使用" class="headerlink" title="try-catch-finally的使用"></a>try-catch-finally的使用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">* 二、try-catch-finally的使用</span><br><span class="line">*</span><br><span class="line">* try&#123;</span><br><span class="line">*     &#x2F;&#x2F;可能出现异常的代码</span><br><span class="line">* &#125;catch (异常类型1 变量名1)&#123;</span><br><span class="line">*       &#x2F;&#x2F;异常处理方式1</span><br><span class="line">* &#125;catch (异常类型2 变量名2)&#123;</span><br><span class="line">*      &#x2F;&#x2F;异常处理方式2</span><br><span class="line">* &#125;catch (异常类型3 变量名3)&#123;</span><br><span class="line">*      &#x2F;&#x2F;异常处理方式3</span><br><span class="line">* &#125;</span><br><span class="line">* ...</span><br><span class="line">* finally&#123;</span><br><span class="line">*     &#x2F;&#x2F;一定会执行的代码</span><br><span class="line">* &#125;</span><br><span class="line">*</span><br><span class="line">* 说明：</span><br><span class="line">* 1.finally是可选的。</span><br><span class="line">* 2.使用try将可能出现异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的对象，</span><br><span class="line">* 根据此对象的类型，去catch中进行匹配</span><br><span class="line">* 3.一旦try中的异常对象匹配到某一个catch时，就进入catch中进行异常的处理，</span><br><span class="line">* 一旦处理完成，就跳出当前的try-catch结构(在没有写finally的情况)。继续执行其后的代码。</span><br><span class="line">* 4.catch中的异常类型如果没有子父类关系，则谁声明在上，声明在下无所谓</span><br><span class="line">*  catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类上面。否则，报错。</span><br><span class="line">* 5.常用的异常对象的处理方式：① String getMessage() ② printStackTrace()</span><br><span class="line">* 6.在try结构中声明的变量，再出了try结构以后，就不能再被调用了</span><br><span class="line">* 7.try-catch-finally结构可以嵌套</span><br><span class="line">*</span><br><span class="line">* 体会1：使用try-catch-finally处理编译时异常，使得程序在编译时就不再报错，但是运行时仍可能报错。</span><br><span class="line">*      相当于我们使用try-catch-finally将一个编译时可能出现的异常，延迟到运行时出现。</span><br><span class="line">* 体会2：开发中，由于运行时异常比较常见，所以我们通常就不针对运行时异常编写try-catch-finally了。</span><br><span class="line">*       针对于编译时异常，我们说一定要考虑异常的处理。</span><br><span class="line">* 再说明：</span><br><span class="line">* finally中声明的是一定会被执行的代码。即使catch中又出现异常了，try中有return语句，catch中有return语句等情况。</span><br><span class="line">* 像数据库连接、输入输出流、网络编程Socket等资源，JVM是不能自动回收的，我们需要自己手动的进行资源的释放。</span><br><span class="line">* 此时的资源释放，就需要声明在finally中。</span><br></pre></td></tr></table></figure>

<h4 id="如何自定义异常类"><a href="#如何自定义异常类" class="headerlink" title="如何自定义异常类"></a>如何自定义异常类</h4><ul>
<li>继承与现有的异常结构：RuntimeException、Exception</li>
<li>提供全局常量：serialVersionUID</li>
<li>提供重载的构造器</li>
</ul>
<h3 id="会话跟踪技术"><a href="#会话跟踪技术" class="headerlink" title="会话跟踪技术"></a>会话跟踪技术</h3><pre><code>1.会话跟踪定义：从进入网站开始到退出网站结束或者关闭浏览器称为一次会话。
2.开始标志：浏览器成功访问页面。
3.结束标志：退出或关闭浏览器。
4.作用：是指在会话过程中多次请求和响应之间共享数据的技术。

5.五种实现会话跟踪方法
5.1URL传参
5.2通过“表单隐藏域”提交
5.3cookie实现
5.4内置对象session实现
5.5内置对象application实现
6.cookie定义：是一小段文本组成的，伴随着用户的请求和服务器的响应，在浏览器和服务器之间来回传递，保存在客户端。
    6.1cookie的业务应用：
        6.1.1记录上次访问时间
        6.1.2猜你喜欢
        6.1.3记住用户名
7.session和cookie的区别：
    7.1都是用来做会话跟踪
    7.2session保存在服务端，cookie保存在客户端
    7.3cookie的值只能是String类型，session的值是Object类型
    7.4session是内置对象，cookie不是
    7.5cookie不安全，session保存在服务端安全性较高
8.内置对象application：
    8.1application对象的生命周期从web应用程序启动开始一直到web容器关闭为止。
9.作用域范围
    application&gt;session&gt;request&gt;page</code></pre></div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">PanXiaoKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2020/04/01/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/">http://example.com/2020/04/01/Java%E5%9F%BA%E7%A1%80%E5%B7%A9%E5%9B%BA/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">向阳榆木</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/Java%E5%9F%BA%E7%A1%80/">Java基础</a></div><div class="post_share"><div class="social-share" data-image="/img/butterfly.jpg" data-sites="qq,wechat,facebook,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t40mLD.th.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t4czVK.th.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2020/04/01/Java%E4%BB%A3%E7%A0%81%E7%89%87%E6%AE%B5/"><img class="prev_cover lazyload" data-src="/img/butterfly.jpg" onerror="onerror=null;src='/img/404.png'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Java代码片段</div></div></a></div><div class="next-post pull_right"><a href="/2020/03/10/%E4%B8%93%E4%B8%9A%E6%9C%AF%E8%AF%AD/"><img class="next_cover lazyload" data-src="/img/butterfly.jpg" onerror="onerror=null;src='/img/404.png'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">专业术语</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2020/04/01/Java代码片段/" title="Java代码片段"><img class="relatedPosts_cover lazyload"data-src="/img/butterfly.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2020-04-01</div><div class="relatedPosts_title">Java代码片段</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: true,
  appId: 'z2GwNsG7RRpWpx5rt7psedl5-MdYXbMMI',
  appKey: 'gI6Yhfwz4JiUIv9546gepko8',
  placeholder: '来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By PanXiaoKang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">小伙伴们好！欢迎来到<a href="https://panyongkang.github.io/" target="_blank" rel="noopener">向阳榆木</a>的博客！</div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>黔ICP备54587259号</span></a></div><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2020,01,01,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/platelet.model.json"},"display":{"position":"right","width":200,"height":500},"mobile":{"show":true},"log":false});</script></body></html>