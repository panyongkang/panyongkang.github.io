<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>④JavaScript教程之面向对象编程 | 向阳榆木</title><meta name="description" content="④JavaScript教程之面向对象编程"><meta name="keywords" content="JavaScript,前端知识,面向对象编程"><meta name="author" content="PanXiaoKang"><meta name="copyright" content="PanXiaoKang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Lotus.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="wyZknSW2XMDLHhrSvtifCN1aQwr2nn53ydI_lDzVJmI"/><meta name="baidu-site-verification" content="p1OeTLcEA8"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="④JavaScript教程之面向对象编程"><meta name="twitter:description" content="④JavaScript教程之面向对象编程"><meta name="twitter:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="④JavaScript教程之面向对象编程"><meta property="og:url" content="http://example.com/2021/09/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><meta property="og:site_name" content="向阳榆木"><meta property="og:description" content="④JavaScript教程之面向对象编程"><meta property="og:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://example.com/2021/09/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"><link rel="prev" title="⑤JavaScript教程之DOM" href="http://example.com/2021/09/21/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8BDOM/"><link rel="next" title="③JavaScript教程之标准库" href="http://example.com/2021/08/29/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"最近有点失眠了,每天被自己帅醒,帅早已成为负担,除了帅一无所有,富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"20px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/06/09/t40ARx.th.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">103</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">235</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="/sunshineBookshelf/"><i class="fa-fw fa fa-university"></i><span> 向阳书架</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://playground.z.wiki/typing-game/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/nineGridGame/nineGridGame.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 抽奖游戏</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li><li><a class="site-page" href="/encryptedPages/"><i class="fa-fw fa fa-lock"></i><span> 加密访问</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 纪念空间</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D相册屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 青春校园</span></a></li><li><a class="site-page" href="/photo-wall/"><i class="fa-fw fa fa-th"></i><span> 生活照片</span></a></li><li><a class="site-page" href="/video-wall/"><i class="fa-fw fa fa-video-camera"></i><span> 在线视频</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li><li><a class="site-page" href="/timeStoryline/"><i class="fa-fw fa fa-file-video-o"></i><span> 时间故事线</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#实例对象与new命令"><span class="toc-number">1.</span> <span class="toc-text">实例对象与new命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#对象是什么"><span class="toc-number">1.1.</span> <span class="toc-text">对象是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数"><span class="toc-number">1.2.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#new-命令"><span class="toc-number">1.3.</span> <span class="toc-text">new 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-number">1.3.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-命令的原理"><span class="toc-number">1.3.2.</span> <span class="toc-text">new 命令的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#new-target"><span class="toc-number">1.3.3.</span> <span class="toc-text">new.target</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-create-创建实例对象"><span class="toc-number">1.4.</span> <span class="toc-text">Object.create() 创建实例对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#this关键字"><span class="toc-number">2.</span> <span class="toc-text">this关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#涵义"><span class="toc-number">2.1.</span> <span class="toc-text">涵义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实质"><span class="toc-number">2.2.</span> <span class="toc-text">实质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用场合"><span class="toc-number">2.3.</span> <span class="toc-text">使用场合</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用注意点"><span class="toc-number">2.4.</span> <span class="toc-text">使用注意点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#避免多层-this"><span class="toc-number">2.4.1.</span> <span class="toc-text">避免多层 this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免数组处理方法中的-this"><span class="toc-number">2.4.2.</span> <span class="toc-text">避免数组处理方法中的 this</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#避免回调函数中的-this"><span class="toc-number">2.4.3.</span> <span class="toc-text">避免回调函数中的 this</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#绑定-this-的方法"><span class="toc-number">2.5.</span> <span class="toc-text">绑定 this 的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-prototype-call"><span class="toc-number">2.5.1.</span> <span class="toc-text">Function.prototype.call()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-prototype-apply"><span class="toc-number">2.5.2.</span> <span class="toc-text">Function.prototype.apply()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Function-prototype-bind"><span class="toc-number">2.5.3.</span> <span class="toc-text">Function.prototype.bind()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#对象的继承"><span class="toc-number">3.</span> <span class="toc-text">对象的继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原型对象概述"><span class="toc-number">3.1.</span> <span class="toc-text">原型对象概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数的缺点"><span class="toc-number">3.1.1.</span> <span class="toc-text">构造函数的缺点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#prototype-属性的作用"><span class="toc-number">3.1.2.</span> <span class="toc-text">prototype 属性的作用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#原型链"><span class="toc-number">3.1.3.</span> <span class="toc-text">原型链</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#constructor-属性"><span class="toc-number">3.1.4.</span> <span class="toc-text">constructor 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#instanceof-运算符"><span class="toc-number">3.2.</span> <span class="toc-text">instanceof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造函数的继承"><span class="toc-number">3.3.</span> <span class="toc-text">构造函数的继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多重继承"><span class="toc-number">3.4.</span> <span class="toc-text">多重继承</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模块"><span class="toc-number">3.5.</span> <span class="toc-text">模块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本的实现方法"><span class="toc-number">3.5.1.</span> <span class="toc-text">基本的实现方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#封装私有变量：构造函数的写法"><span class="toc-number">3.5.2.</span> <span class="toc-text">封装私有变量：构造函数的写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#封装私有变量：立即执行函数的写法"><span class="toc-number">3.5.3.</span> <span class="toc-text">封装私有变量：立即执行函数的写法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#模块的放大模式"><span class="toc-number">3.5.4.</span> <span class="toc-text">模块的放大模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#输入全局变量"><span class="toc-number">3.5.5.</span> <span class="toc-text">输入全局变量</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Object对象的相关方法"><span class="toc-number">4.</span> <span class="toc-text">Object对象的相关方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-getPrototypeOf"><span class="toc-number">4.1.</span> <span class="toc-text">Object.getPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-setPrototypeOf"><span class="toc-number">4.2.</span> <span class="toc-text">Object.setPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-create"><span class="toc-number">4.3.</span> <span class="toc-text">Object.create()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-isPrototypeOf"><span class="toc-number">4.4.</span> <span class="toc-text">Object.prototype.isPrototypeOf()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-proto"><span class="toc-number">4.5.</span> <span class="toc-text">Object.prototype.proto</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取原型对象方法的比较"><span class="toc-number">4.6.</span> <span class="toc-text">获取原型对象方法的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-getOwnPropertyNames"><span class="toc-number">4.7.</span> <span class="toc-text">Object.getOwnPropertyNames()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Object-prototype-hasOwnProperty"><span class="toc-number">4.8.</span> <span class="toc-text">Object.prototype.hasOwnProperty()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#in-运算符和-for…in-循环"><span class="toc-number">4.9.</span> <span class="toc-text">in 运算符和 for…in 循环</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象的拷贝"><span class="toc-number">4.10.</span> <span class="toc-text">对象的拷贝</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#严格模式"><span class="toc-number">5.</span> <span class="toc-text">严格模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#设计目的"><span class="toc-number">5.1.</span> <span class="toc-text">设计目的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#启用方法"><span class="toc-number">5.2.</span> <span class="toc-text">启用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#显式报错"><span class="toc-number">5.3.</span> <span class="toc-text">显式报错</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#只读属性不可写"><span class="toc-number">5.3.1.</span> <span class="toc-text">只读属性不可写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#只设置了取值器的属性不可写"><span class="toc-number">5.3.2.</span> <span class="toc-text">只设置了取值器的属性不可写</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止扩展的对象不可扩展"><span class="toc-number">5.3.3.</span> <span class="toc-text">禁止扩展的对象不可扩展</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eval、arguments-不可用作标识名"><span class="toc-number">5.3.4.</span> <span class="toc-text">eval、arguments 不可用作标识名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数不能有重名的参数"><span class="toc-number">5.3.5.</span> <span class="toc-text">函数不能有重名的参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止八进制的前缀0表示法"><span class="toc-number">5.3.6.</span> <span class="toc-text">禁止八进制的前缀0表示法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#增强的安全措施"><span class="toc-number">5.4.</span> <span class="toc-text">增强的安全措施</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#全局变量显式声明"><span class="toc-number">5.4.1.</span> <span class="toc-text">全局变量显式声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止-this-关键字指向全局对象"><span class="toc-number">5.4.2.</span> <span class="toc-text">禁止 this 关键字指向全局对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止使用-fn-callee、fn-caller"><span class="toc-number">5.4.3.</span> <span class="toc-text">禁止使用 fn.callee、fn.caller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止使用-arguments-callee、arguments-caller"><span class="toc-number">5.4.4.</span> <span class="toc-text">禁止使用 arguments.callee、arguments.caller</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止删除变量"><span class="toc-number">5.4.5.</span> <span class="toc-text">禁止删除变量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#静态绑定"><span class="toc-number">5.5.</span> <span class="toc-text">静态绑定</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#禁止使用-with-语句"><span class="toc-number">5.5.1.</span> <span class="toc-text">禁止使用 with 语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#创设-eval-作用域"><span class="toc-number">5.5.2.</span> <span class="toc-text">创设 eval 作用域</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arguments-不再追踪参数的变化"><span class="toc-number">5.5.3.</span> <span class="toc-text">arguments 不再追踪参数的变化</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#向下一个版本的-JavaScript-过渡"><span class="toc-number">5.6.</span> <span class="toc-text">向下一个版本的 JavaScript 过渡</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#非函数代码块不得声明函数"><span class="toc-number">5.6.1.</span> <span class="toc-text">非函数代码块不得声明函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#保留字"><span class="toc-number">5.6.2.</span> <span class="toc-text">保留字</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异步操作"><span class="toc-number">6.</span> <span class="toc-text">异步操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单线程模型"><span class="toc-number">6.1.</span> <span class="toc-text">单线程模型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同步任务和异步任务"><span class="toc-number">6.2.</span> <span class="toc-text">同步任务和异步任务</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#任务队列和事件循环"><span class="toc-number">6.3.</span> <span class="toc-text">任务队列和事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#事件循环的基本原理"><span class="toc-number">6.3.1.</span> <span class="toc-text">事件循环的基本原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件循环的过程"><span class="toc-number">6.3.2.</span> <span class="toc-text">事件循环的过程</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步操作的模式"><span class="toc-number">6.4.</span> <span class="toc-text">异步操作的模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#回调函数"><span class="toc-number">6.4.1.</span> <span class="toc-text">回调函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件监听"><span class="toc-number">6.4.2.</span> <span class="toc-text">事件监听</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#发布-x2F-订阅"><span class="toc-number">6.4.3.</span> <span class="toc-text">发布&#x2F;订阅</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#异步操作的流程控制"><span class="toc-number">6.5.</span> <span class="toc-text">异步操作的流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#串行执行"><span class="toc-number">6.5.1.</span> <span class="toc-text">串行执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行执行"><span class="toc-number">6.5.2.</span> <span class="toc-text">并行执行</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#并行与串行的结合"><span class="toc-number">6.5.3.</span> <span class="toc-text">并行与串行的结合</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#定时器"><span class="toc-number">7.</span> <span class="toc-text">定时器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout"><span class="toc-number">7.1.</span> <span class="toc-text">setTimeout()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setInterval"><span class="toc-number">7.2.</span> <span class="toc-text">setInterval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#clearTimeout-，clearInterval"><span class="toc-number">7.3.</span> <span class="toc-text">clearTimeout()，clearInterval()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例：debounce-函数"><span class="toc-number">7.4.</span> <span class="toc-text">实例：debounce 函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#运行机制"><span class="toc-number">7.5.</span> <span class="toc-text">运行机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#setTimeout-f-0"><span class="toc-number">7.6.</span> <span class="toc-text">setTimeout(f, 0)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#含义"><span class="toc-number">7.6.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#应用"><span class="toc-number">7.6.2.</span> <span class="toc-text">应用</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Promise-对象"><span class="toc-number">8.</span> <span class="toc-text">Promise 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-对象的状态"><span class="toc-number">8.2.</span> <span class="toc-text">Promise 对象的状态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-构造函数"><span class="toc-number">8.3.</span> <span class="toc-text">Promise 构造函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Promise-prototype-then"><span class="toc-number">8.4.</span> <span class="toc-text">Promise.prototype.then()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#then-用法辨析"><span class="toc-number">8.5.</span> <span class="toc-text">then() 用法辨析</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例：图片加载"><span class="toc-number">8.6.</span> <span class="toc-text">实例：图片加载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#小结"><span class="toc-number">8.7.</span> <span class="toc-text">小结</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#微任务"><span class="toc-number">8.8.</span> <span class="toc-text">微任务</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">向阳榆木</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="/sunshineBookshelf/"><i class="fa-fw fa fa-university"></i><span> 向阳书架</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://playground.z.wiki/typing-game/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/nineGridGame/nineGridGame.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 抽奖游戏</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li><li><a class="site-page" href="/encryptedPages/"><i class="fa-fw fa fa-lock"></i><span> 加密访问</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 纪念空间</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D相册屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 青春校园</span></a></li><li><a class="site-page" href="/photo-wall/"><i class="fa-fw fa fa-th"></i><span> 生活照片</span></a></li><li><a class="site-page" href="/video-wall/"><i class="fa-fw fa fa-video-camera"></i><span> 在线视频</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li><li><a class="site-page" href="/timeStoryline/"><i class="fa-fw fa fa-file-video-o"></i><span> 时间故事线</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">④JavaScript教程之面向对象编程</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-09-17 22:12:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-09-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-12-21 18:14:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2024-12-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/09/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/09/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="实例对象与new命令"><a href="#实例对象与new命令" class="headerlink" title="实例对象与new命令"></a>实例对象与new命令</h2><h3 id="对象是什么"><a href="#对象是什么" class="headerlink" title="对象是什么"></a>对象是什么</h3><p>面向对象编程（Object Oriented Programming，缩写为 OOP）是目前主流的编程范式。它将真实世界各种复杂的关系，抽象为一个个对象，然后由对象之间的分工与合作，完成对真实世界的模拟。</p>
<p>每一个对象都是功能中心，具有明确分工，可以完成接受信息、处理数据、发出信息等任务。对象可以复用，通过继承机制还可以定制。因此，面向对象编程具有灵活、代码可复用、高度模块化等特点，容易维护和开发，比起由一系列函数或指令组成的传统的过程式编程（procedural programming），更适合多人合作的大型软件项目。</p>
<p>那么，“对象”（object）到底是什么？我们从两个层次来理解。</p>
<p><strong>（1）对象是单个实物的抽象。</strong></p>
<p>一本书、一辆汽车、一个人都可以是对象，一个数据库、一张网页、一个远程服务器连接也可以是对象。当实物被抽象成对象，实物之间的关系就变成了对象之间的关系，从而就可以模拟现实情况，针对对象进行编程。</p>
<p><strong>（2）对象是一个容器，封装了属性（property）和方法（method）。</strong></p>
<p>属性是对象的状态，方法是对象的行为（完成某种任务）。比如，我们可以把动物抽象为 <code>animal</code>对象，使用“属性”记录具体是哪一种动物，使用“方法”表示动物的某种行为（奔跑、捕猎、休息等等）。</p>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>面向对象编程的第一步，就是要生成对象。前面说过，对象是单个实物的抽象。通常需要一个模板，表示某一类实物的共同特征，然后对象根据这个模板生成。</p>
<p>典型的面向对象编程语言（比如 C++ 和 Java），都有“类”（class）这个概念。所谓“类”就是对象的模板，对象就是“类”的实例。但是，JavaScript 语言的对象体系，不是基于“类”的，而是基于构造函数（constructor）和原型链（prototype）。</p>
<p>JavaScript 语言使用构造函数（constructor）作为对象的模板。所谓”构造函数”，就是专门用来生成实例对象的函数。它就是对象的模板，描述实例对象的基本结构。一个构造函数，可以生成多个实例对象，这些实例对象都有相同的结构。</p>
<p>构造函数就是一个普通的函数，但具有自己的特征和用法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle &#x3D; function () &#123;</span><br><span class="line">  this.price &#x3D; 1000;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>就是构造函数。为了与普通函数区别，构造函数名字的第一个字母通常大写。</p>
<p>构造函数的特点有两个。</p>
<ul>
<li>函数体内部使用了 <code>this</code>关键字，代表了所要生成的对象实例。</li>
<li>生成对象的时候，必须使用 <code>new</code>命令。</li>
</ul>
<p>下面先介绍 <code>new</code>命令。</p>
<h3 id="new-命令"><a href="#new-命令" class="headerlink" title="new 命令"></a>new 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>new</code>命令的作用，就是执行构造函数，返回一个实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle &#x3D; function () &#123;</span><br><span class="line">  this.price &#x3D; 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v &#x3D; new Vehicle();</span><br><span class="line">v.price &#x2F;&#x2F; 1000</span><br></pre></td></tr></table></figure>

<p>上面代码通过 <code>new</code>命令，让构造函数 <code>Vehicle</code>生成一个实例对象，保存在变量 <code>v</code>中。这个新生成的实例对象，从构造函数 <code>Vehicle</code>得到了 <code>price</code>属性。<code>new</code>命令执行时，构造函数内部的 <code>this</code>，就代表了新生成的实例对象，<code>this.price</code>表示实例对象有一个 <code>price</code>属性，值是1000。</p>
<p>使用 <code>new</code>命令时，根据需要，构造函数也可以接受参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle &#x3D; function (p) &#123;</span><br><span class="line">  this.price &#x3D; p;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v &#x3D; new Vehicle(500);</span><br></pre></td></tr></table></figure>

<p><code>new</code>命令本身就可以执行构造函数，所以后面的构造函数可以带括号，也可以不带括号。下面两行代码是等价的，但是为了表示这里是函数调用，推荐使用括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 推荐的写法</span><br><span class="line">var v &#x3D; new Vehicle();</span><br><span class="line">&#x2F;&#x2F; 不推荐的写法</span><br><span class="line">var v &#x3D; new Vehicle;</span><br></pre></td></tr></table></figure>

<p>一个很自然的问题是，如果忘了使用 <code>new</code>命令，直接调用构造函数会发生什么事？</p>
<p>这种情况下，构造函数就变成了普通函数，并不会生成实例对象。而且由于后面会说到的原因，<code>this</code>这时代表全局对象，将造成一些意想不到的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle &#x3D; function ()&#123;</span><br><span class="line">  this.price &#x3D; 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var v &#x3D; Vehicle();</span><br><span class="line">v &#x2F;&#x2F; undefined</span><br><span class="line">price &#x2F;&#x2F; 1000</span><br></pre></td></tr></table></figure>

<p>上面代码中，调用 <code>Vehicle</code>构造函数时，忘了加上 <code>new</code>命令。结果，变量 <code>v</code>变成了 <code>undefined</code>，而 <code>price</code>属性变成了全局变量。因此，应该非常小心，避免不使用 <code>new</code>命令、直接调用构造函数。</p>
<p>为了保证构造函数必须与 <code>new</code>命令一起使用，一个解决办法是，构造函数内部使用严格模式，即第一行加上 <code>use strict</code>。这样的话，一旦忘了使用 <code>new</code>命令，直接调用构造函数就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fubar(foo, bar)&#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  this._foo &#x3D; foo;</span><br><span class="line">  this._bar &#x3D; bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar()</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot set property &#39;_foo&#39; of undefined</span><br></pre></td></tr></table></figure>

<p>上面代码的 <code>Fubar</code>为构造函数，<code>use strict</code>命令保证了该函数在严格模式下运行。由于严格模式中，函数内部的 <code>this</code>不能指向全局对象，默认等于 <code>undefined</code>，导致不加 <code>new</code>调用会报错（JavaScript 不允许对 <code>undefined</code>添加属性）。</p>
<p>另一个解决办法，构造函数内部判断是否使用 <code>new</code>命令，如果发现没有使用，则直接返回一个实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function Fubar(foo, bar) &#123;</span><br><span class="line">  if (!(this instanceof Fubar)) &#123;</span><br><span class="line">    return new Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  this._foo &#x3D; foo;</span><br><span class="line">  this._bar &#x3D; bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fubar(1, 2)._foo &#x2F;&#x2F; 1</span><br><span class="line">(new Fubar(1, 2))._foo &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中的构造函数，不管加不加 <code>new</code>命令，都会得到同样的结果。</p>
<h4 id="new-命令的原理"><a href="#new-命令的原理" class="headerlink" title="new 命令的原理"></a>new 命令的原理</h4><p>使用 <code>new</code>命令时，它后面的函数依次执行下面的步骤。</p>
<ol>
<li>创建一个空对象，作为将要返回的对象实例。</li>
<li>将这个空对象的原型，指向构造函数的 <code>prototype</code>属性。</li>
<li>将这个空对象赋值给函数内部的 <code>this</code>关键字。</li>
<li>开始执行构造函数内部的代码。</li>
</ol>
<p>也就是说，构造函数内部，<code>this</code>指的是一个新生成的空对象，所有针对 <code>this</code>的操作，都会发生在这个空对象上。构造函数之所以叫“构造函数”，就是说这个函数的目的，就是操作一个空对象（即 <code>this</code>对象），将其“构造”为需要的样子。</p>
<p>如果构造函数内部有 <code>return</code>语句，而且 <code>return</code>后面跟着一个对象，<code>new</code>命令会返回 <code>return</code>语句指定的对象；否则，就会不管 <code>return</code>语句，返回 <code>this</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle &#x3D; function () &#123;</span><br><span class="line">  this.price &#x3D; 1000;</span><br><span class="line">  return 1000;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(new Vehicle()) &#x3D;&#x3D;&#x3D; 1000</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数 <code>Vehicle</code>的 <code>return</code>语句返回一个数值。这时，<code>new</code>命令就会忽略这个 <code>return</code>语句，返回“构造”后的 <code>this</code>对象。</p>
<p>但是，如果 <code>return</code>语句返回的是一个跟 <code>this</code>无关的新对象，<code>new</code>命令会返回这个新对象，而不是 <code>this</code>对象。这一点需要特别引起注意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var Vehicle &#x3D; function ()&#123;</span><br><span class="line">  this.price &#x3D; 1000;</span><br><span class="line">  return &#123; price: 2000 &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(new Vehicle()).price</span><br><span class="line">&#x2F;&#x2F; 2000</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数 <code>Vehicle</code>的 <code>return</code>语句，返回的是一个新对象。<code>new</code>命令会返回这个对象，而不是 <code>this</code>对象。</p>
<p>另一方面，如果对普通函数（内部没有 <code>this</code>关键字的函数）使用 <code>new</code>命令，则会返回一个空对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getMessage() &#123;</span><br><span class="line">  return &#39;this is a message&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var msg &#x3D; new getMessage();</span><br><span class="line"></span><br><span class="line">msg &#x2F;&#x2F; &#123;&#125;</span><br><span class="line">typeof msg &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>getMessage</code>是一个普通函数，返回一个字符串。对它使用 <code>new</code>命令，会得到一个空对象。这是因为 <code>new</code>命令总是返回一个对象，要么是实例对象，要么是 <code>return</code>语句指定的对象。本例中，<code>return</code>语句返回的是字符串，所以 <code>new</code>命令就忽略了该语句。</p>
<p><code>new</code>命令简化的内部流程，可以用下面的代码表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function _new(&#x2F;* 构造函数 *&#x2F; constructor, &#x2F;* 构造函数参数 *&#x2F; params) &#123;</span><br><span class="line">  &#x2F;&#x2F; 将 arguments 对象转为数组</span><br><span class="line">  var args &#x3D; [].slice.call(arguments);</span><br><span class="line">  &#x2F;&#x2F; 取出构造函数</span><br><span class="line">  var constructor &#x3D; args.shift();</span><br><span class="line">  &#x2F;&#x2F; 创建一个空对象，继承构造函数的 prototype 属性</span><br><span class="line">  var context &#x3D; Object.create(constructor.prototype);</span><br><span class="line">  &#x2F;&#x2F; 执行构造函数</span><br><span class="line">  var result &#x3D; constructor.apply(context, args);</span><br><span class="line">  &#x2F;&#x2F; 如果返回结果是对象，就直接返回，否则返回 context 对象</span><br><span class="line">  return (typeof result &#x3D;&#x3D;&#x3D; &#39;object&#39; &amp;&amp; result !&#x3D; null) ? result : context;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实例</span><br><span class="line">var actor &#x3D; _new(Person, &#39;张三&#39;, 28);</span><br></pre></td></tr></table></figure>

<h4 id="new-target"><a href="#new-target" class="headerlink" title="new.target"></a>new.target</h4><p>函数内部可以使用 <code>new.target</code>属性。如果当前函数是 <code>new</code>命令调用，<code>new.target</code>指向当前函数，否则为 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(new.target &#x3D;&#x3D;&#x3D; f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; false</span><br><span class="line">new f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>使用这个属性，可以判断函数调用的时候，是否使用 <code>new</code>命令。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  if (!new.target) &#123;</span><br><span class="line">    throw new Error(&#39;请使用 new 命令调用！&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; Uncaught Error: 请使用 new 命令调用！</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数 <code>f</code>调用时，没有使用 <code>new</code>命令，就抛出一个错误。</p>
<h3 id="Object-create-创建实例对象"><a href="#Object-create-创建实例对象" class="headerlink" title="Object.create() 创建实例对象"></a>Object.create() 创建实例对象</h3><p>构造函数作为模板，可以生成实例对象。但是，有时拿不到构造函数，只能拿到一个现有的对象。我们希望以这个现有的对象作为模板，生成新的实例对象，这时就可以使用 <code>Object.create()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var person1 &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  age: 38,</span><br><span class="line">  greeting: function() &#123;</span><br><span class="line">    console.log(&#39;Hi! I\&#39;m &#39; + this.name + &#39;.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var person2 &#x3D; Object.create(person1);</span><br><span class="line"></span><br><span class="line">person2.name &#x2F;&#x2F; 张三</span><br><span class="line">person2.greeting() &#x2F;&#x2F; Hi! I&#39;m 张三.</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象 <code>person1</code>是 <code>person2</code>的模板，后者继承了前者的属性和方法。</p>
<h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="涵义"><a href="#涵义" class="headerlink" title="涵义"></a>涵义</h3><p><code>this</code>关键字是一个非常重要的语法点。毫不夸张地说，不理解它的含义，大部分开发任务都无法完成。</p>
<p>前一章已经提到，<code>this</code>可以用在构造函数之中，表示实例对象。除此之外，<code>this</code>还可以用在别的场合。但不管是什么场合，<code>this</code>都有一个共同点：它总是返回一个对象。</p>
<p>简单说，<code>this</code>就是属性或方法“当前”所在的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.property</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>this</code>就代表 <code>property</code>属性当前所在的对象。</p>
<p>下面是一个实际的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  describe: function () &#123;</span><br><span class="line">    return &#39;姓名：&#39;+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">person.describe()</span><br><span class="line">&#x2F;&#x2F; &quot;姓名：张三&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>this.name</code>表示 <code>name</code>属性所在的那个对象。由于 <code>this.name</code>是在 <code>describe</code>方法中调用，而 <code>describe</code>方法所在的当前对象是 <code>person</code>，因此 <code>this</code>指向 <code>person</code>，<code>this.name</code>就是 <code>person.name</code>。</p>
<p>由于对象的属性可以赋给另一个对象，所以属性所在的当前对象是可变的，即 <code>this</code>的指向是可变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var A &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  describe: function () &#123;</span><br><span class="line">    return &#39;姓名：&#39;+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B &#x3D; &#123;</span><br><span class="line">  name: &#39;李四&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">B.describe &#x3D; A.describe;</span><br><span class="line">B.describe()</span><br><span class="line">&#x2F;&#x2F; &quot;姓名：李四&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A.describe</code>属性被赋给 <code>B</code>，于是 <code>B.describe</code>就表示 <code>describe</code>方法所在的当前对象是 <code>B</code>，所以 <code>this.name</code>就指向 <code>B.name</code>。</p>
<p>稍稍重构这个例子，<code>this</code>的动态指向就能看得更清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return &#39;姓名：&#39;+ this.name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var A &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var B &#x3D; &#123;</span><br><span class="line">  name: &#39;李四&#39;,</span><br><span class="line">  describe: f</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.describe() &#x2F;&#x2F; &quot;姓名：张三&quot;</span><br><span class="line">B.describe() &#x2F;&#x2F; &quot;姓名：李四&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 <code>f</code>内部使用了 <code>this</code>关键字，随着 <code>f</code>所在的对象不同，<code>this</code>的指向也不同。</p>
<p>只要函数被赋给另一个变量，<code>this</code>的指向就会变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var A &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  describe: function () &#123;</span><br><span class="line">    return &#39;姓名：&#39;+ this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var name &#x3D; &#39;李四&#39;;</span><br><span class="line">var f &#x3D; A.describe;</span><br><span class="line">f() &#x2F;&#x2F; &quot;姓名：李四&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A.describe</code>被赋值给变量 <code>f</code>，内部的 <code>this</code>就会指向 <code>f</code>运行时所在的对象（本例是顶层对象）。</p>
<p>再看一个网页编程的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot; size&#x3D;3 onChange&#x3D;&quot;validate(this, 18, 99);&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">function validate(obj, lowval, hival)&#123;</span><br><span class="line">  if ((obj.value &lt; lowval) || (obj.value &gt; hival))</span><br><span class="line">    console.log(&#39;Invalid Value!&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码是一个文本输入框，每当用户输入一个值，就会调用 <code>onChange</code>回调函数，验证这个值是否在指定范围。浏览器会向回调函数传入当前对象，因此 <code>this</code>就代表传入当前对象（即文本框），然后就可以从 <code>this.value</code>上面读到用户的输入值。</p>
<p>总结一下，JavaScript 语言之中，一切皆对象，运行环境也是对象，所以函数都是在某个对象之中运行，<code>this</code>就是函数运行时所在的对象（环境）。这本来并不会让用户糊涂，但是 JavaScript 支持运行环境动态切换，也就是说，<code>this</code>的指向是动态的，没有办法事先确定到底指向哪个对象，这才是最让初学者感到困惑的地方。</p>
<h3 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h3><p>JavaScript 语言之所以有 this 的设计，跟内存里面的数据结构有关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo:  5 &#125;;</span><br></pre></td></tr></table></figure>

<p>上面的代码将一个对象赋值给变量 <code>obj</code>。JavaScript 引擎会先在内存里面，生成一个对象 <code>{ foo: 5 }</code>，然后把这个对象的内存地址赋值给变量 <code>obj</code>。也就是说，变量 <code>obj</code>是一个地址（reference）。后面如果要读取 <code>obj.foo</code>，引擎先从 <code>obj</code>拿到内存地址，然后再从该地址读出原始的对象，返回它的 <code>foo</code>属性。</p>
<p>原始的对象以字典结构保存，每一个属性名都对应一个属性描述对象。举例来说，上面例子的 <code>foo</code>属性，实际上是以下面的形式保存的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 5</span><br><span class="line">    [[writable]]: true</span><br><span class="line">    [[enumerable]]: true</span><br><span class="line">    [[configurable]]: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，<code>foo</code>属性的值保存在属性描述对象的 <code>value</code>属性里面。</p>
<p>这样的结构是很清晰的，问题在于属性的值可能是一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: function () &#123;&#125; &#125;;</span><br></pre></td></tr></table></figure>

<p>这时，引擎会将函数单独保存在内存中，然后再将函数的地址赋值给 <code>foo</code>属性的 <code>value</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  foo: &#123;</span><br><span class="line">    [[value]]: 函数的地址</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于函数是一个单独的值，所以它可以在不同的环境（上下文）执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;&#125;;</span><br><span class="line">var obj &#x3D; &#123; f: f &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单独执行</span><br><span class="line">f()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj 环境执行</span><br><span class="line">obj.f()</span><br></pre></td></tr></table></figure>

<p>JavaScript 允许在函数体内部，引用当前环境的其他变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面使用了变量 <code>x</code>。该变量由运行环境提供。</p>
<p>现在问题就来了，由于函数可以在不同的运行环境执行，所以需要有一种机制，能够在函数体内部获得当前的运行环境（context）。所以，<code>this</code>就出现了，它的设计目的就是在函数体内部，指代函数当前的运行环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体里面的 <code>this.x</code>就是指当前运行环境的 <code>x</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  console.log(this.x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  f: f,</span><br><span class="line">  x: 2,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 单独执行</span><br><span class="line">f() &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; obj 环境执行</span><br><span class="line">obj.f() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 <code>f</code>在全局环境执行，<code>this.x</code>指向全局环境的 <code>x</code>；在 <code>obj</code>环境执行，<code>this.x</code>指向 <code>obj.x</code>。</p>
<h3 id="使用场合"><a href="#使用场合" class="headerlink" title="使用场合"></a>使用场合</h3><p><code>this</code>主要有以下几个使用场合。</p>
<p><strong>（1）全局环境</strong></p>
<p>全局环境使用 <code>this</code>，它指的就是顶层对象 <code>window</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">this &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; window);</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码说明，不管是不是在函数内部，只要是在全局环境下运行，<code>this</code>就是指顶层对象 <code>window</code>。</p>
<p><strong>（2）构造函数</strong></p>
<p>构造函数中的 <code>this</code>，指的是实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var Obj &#x3D; function (p) &#123;</span><br><span class="line">  this.p &#x3D; p;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个构造函数 <code>Obj</code>。由于 <code>this</code>指向实例对象，所以在构造函数内部定义 <code>this.p</code>，就相当于定义实例对象有一个 <code>p</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; new Obj(&#39;Hello World!&#39;);</span><br><span class="line">o.p &#x2F;&#x2F; &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>

<p><strong>（3）对象的方法</strong></p>
<p>如果对象的方法里面包含 <code>this</code>，<code>this</code>的指向就是方法运行时所在的对象。该方法赋值给另一个对象，就会改变 <code>this</code>的指向。</p>
<p>但是，这条规则很不容易把握。请看下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D;&#123;</span><br><span class="line">  foo: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo() &#x2F;&#x2F; obj</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>方法执行时，它内部的 <code>this</code>指向 <code>obj</code>。</p>
<p>但是，下面这几种用法，都会改变 <code>this</code>的指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 情况一</span><br><span class="line">(obj.foo &#x3D; obj.foo)() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; 情况二</span><br><span class="line">(false || obj.foo)() &#x2F;&#x2F; window</span><br><span class="line">&#x2F;&#x2F; 情况三</span><br><span class="line">(1, obj.foo)() &#x2F;&#x2F; window</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.foo</code>就是一个值。这个值真正调用的时候，运行环境已经不是 <code>obj</code>了，而是全局环境，所以 <code>this</code>不再指向 <code>obj</code>。</p>
<p>可以这样理解，JavaScript 引擎内部，<code>obj</code>和 <code>obj.foo</code>储存在两个内存地址，称为地址一和地址二。<code>obj.foo()</code>这样调用时，是从地址一调用地址二，因此地址二的运行环境是地址一，<code>this</code>指向 <code>obj</code>。但是，上面三种情况，都是直接取出地址二进行调用，这样的话，运行环境就是全局环境，因此 <code>this</code>指向全局环境。上面三种情况等同于下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 情况一</span><br><span class="line">(obj.foo &#x3D; function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;)()</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">(function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况二</span><br><span class="line">(false || function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 情况三</span><br><span class="line">(1, function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>如果 <code>this</code>所在的方法不在对象的第一层，这时 <code>this</code>只是指向当前一层的对象，而不会继承更上面的层。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;</span><br><span class="line">  p: &#39;Hello&#39;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: function() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">a.b.m() &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a.b.m</code>方法在 <code>a</code>对象的第二层，该方法内部的 <code>this</code>不是指向 <code>a</code>，而是指向 <code>a.b</code>，因为实际执行的是下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var b &#x3D; &#123;</span><br><span class="line">  m: function() &#123;</span><br><span class="line">   console.log(this.p);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var a &#x3D; &#123;</span><br><span class="line">  p: &#39;Hello&#39;,</span><br><span class="line">  b: b</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">(a.b).m() &#x2F;&#x2F; 等同于 b.m()</span><br></pre></td></tr></table></figure>

<p>如果要达到预期效果，只有写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: function() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: &#39;Hello&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果这时将嵌套对象内部的方法赋值给一个变量，<code>this</code>依然会指向全局对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;</span><br><span class="line">  b: &#123;</span><br><span class="line">    m: function() &#123;</span><br><span class="line">      console.log(this.p);</span><br><span class="line">    &#125;,</span><br><span class="line">    p: &#39;Hello&#39;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var hello &#x3D; a.b.m;</span><br><span class="line">hello() &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>m</code>是多层对象内部的一个方法。为求简便，将其赋值给 <code>hello</code>变量，结果调用时，<code>this</code>指向了顶层对象。为了避免这个问题，可以只将 <code>m</code>所在的对象赋值给 <code>hello</code>，这样调用时，<code>this</code>的指向就不会变。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var hello &#x3D; a.b;</span><br><span class="line">hello.m() &#x2F;&#x2F; Hello</span><br></pre></td></tr></table></figure>

<h3 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h3><h4 id="避免多层-this"><a href="#避免多层-this" class="headerlink" title="避免多层 this"></a>避免多层 this</h4><p>由于 <code>this</code>的指向是不确定的，所以切勿在函数中包含多层的 <code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  f1: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 &#x3D; function () &#123;</span><br><span class="line">      console.log(this);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">&#x2F;&#x2F; Object</span><br><span class="line">&#x2F;&#x2F; Window</span><br></pre></td></tr></table></figure>

<p>上面代码包含两层 <code>this</code>，结果运行后，第一层指向对象 <code>o</code>，第二层指向全局对象，因为实际执行的是下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var temp &#x3D; function () &#123;</span><br><span class="line">  console.log(this);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123;</span><br><span class="line">  f1: function () &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var f2 &#x3D; temp();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>一个解决方法是在第二层改用一个指向外层 <code>this</code>的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  f1: function() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">    var that &#x3D; this;</span><br><span class="line">    var f2 &#x3D; function() &#123;</span><br><span class="line">      console.log(that);</span><br><span class="line">    &#125;();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f1()</span><br><span class="line">&#x2F;&#x2F; Object</span><br><span class="line">&#x2F;&#x2F; Object</span><br></pre></td></tr></table></figure>

<p>上面代码定义了变量 <code>that</code>，固定指向外层的 <code>this</code>，然后在内层使用 <code>that</code>，就不会发生 <code>this</code>指向的改变。</p>
<p>事实上，使用一个变量固定 <code>this</code>的值，然后内层函数调用这个变量，是非常常见的做法，请务必掌握。</p>
<p>JavaScript 提供了严格模式，也可以硬性避免这种问题。严格模式下，如果函数内部的 <code>this</code>指向顶层对象，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; &#123;</span><br><span class="line">  count: 0</span><br><span class="line">&#125;;</span><br><span class="line">counter.inc &#x3D; function () &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  this.count++</span><br><span class="line">&#125;;</span><br><span class="line">var f &#x3D; counter.inc;</span><br><span class="line">f()</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot read property &#39;count&#39; of undefined</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>inc</code>方法通过 <code>&#39;use strict&#39;</code>声明采用严格模式，这时内部的 <code>this</code>一旦指向顶层对象，就会报错。</p>
<h4 id="避免数组处理方法中的-this"><a href="#避免数组处理方法中的-this" class="headerlink" title="避免数组处理方法中的 this"></a>避免数组处理方法中的 this</h4><p>数组的 <code>map</code>和 <code>foreach</code>方法，允许提供一个函数作为参数。这个函数内部不应该使用 <code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  v: &#39;hello&#39;,</span><br><span class="line">  p: [ &#39;a1&#39;, &#39;a2&#39; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(this.v + &#39; &#39; + item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">&#x2F;&#x2F; undefined a1</span><br><span class="line">&#x2F;&#x2F; undefined a2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foreach</code>方法的回调函数中的 <code>this</code>，其实是指向 <code>window</code>对象，因此取不到 <code>o.v</code>的值。原因跟上一段的多层 <code>this</code>是一样的，就是内层的 <code>this</code>不指向外部，而指向顶层对象。</p>
<p>解决这个问题的一种方法，就是前面提到的，使用中间变量固定 <code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  v: &#39;hello&#39;,</span><br><span class="line">  p: [ &#39;a1&#39;, &#39;a2&#39; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    var that &#x3D; this;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(that.v+&#39; &#39;+item);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">&#x2F;&#x2F; hello a1</span><br><span class="line">&#x2F;&#x2F; hello a2</span><br></pre></td></tr></table></figure>

<p>另一种方法是将 <code>this</code>当作 <code>foreach</code>方法的第二个参数，固定它的运行环境。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;</span><br><span class="line">  v: &#39;hello&#39;,</span><br><span class="line">  p: [ &#39;a1&#39;, &#39;a2&#39; ],</span><br><span class="line">  f: function f() &#123;</span><br><span class="line">    this.p.forEach(function (item) &#123;</span><br><span class="line">      console.log(this.v + &#39; &#39; + item);</span><br><span class="line">    &#125;, this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">o.f()</span><br><span class="line">&#x2F;&#x2F; hello a1</span><br><span class="line">&#x2F;&#x2F; hello a2</span><br></pre></td></tr></table></figure>

<h4 id="避免回调函数中的-this"><a href="#避免回调函数中的-this" class="headerlink" title="避免回调函数中的 this"></a>避免回调函数中的 this</h4><p>回调函数中的 <code>this</code>往往会改变指向，最好避免使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; new Object();</span><br><span class="line">o.f &#x3D; function () &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; jQuery 的写法</span><br><span class="line">$(&#39;#button&#39;).on(&#39;click&#39;, o.f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台会显示 <code>false</code>。原因是此时 <code>this</code>不再指向 <code>o</code>对象，而是指向按钮的 DOM 对象，因为 <code>f</code>方法是在按钮对象的环境中被调用的。这种细微的差别，很容易在编程中忽视，导致难以察觉的错误。</p>
<p>为了解决这个问题，可以采用下面的一些方法对 <code>this</code>进行绑定，也就是使得 <code>this</code>固定指向某个对象，减少不确定性。</p>
<h3 id="绑定-this-的方法"><a href="#绑定-this-的方法" class="headerlink" title="绑定 this 的方法"></a>绑定 this 的方法</h3><p><code>this</code>的动态切换，固然为 JavaScript 创造了巨大的灵活性，但也使得编程变得困难和模糊。有时，需要把 <code>this</code>固定下来，避免出现意想不到的情况。JavaScript 提供了 <code>call</code>、<code>apply</code>、<code>bind</code>这三个方法，来切换&#x2F;固定 <code>this</code>的指向。</p>
<h4 id="Function-prototype-call"><a href="#Function-prototype-call" class="headerlink" title="Function.prototype.call()"></a>Function.prototype.call()</h4><p>函数实例的 <code>call</code>方法，可以指定函数内部 <code>this</code>的指向（即函数执行时所在的作用域），然后在所指定的作用域中，调用该函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f() &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br><span class="line">f.call(obj) &#x3D;&#x3D;&#x3D; obj &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，全局环境运行函数 <code>f</code>时，<code>this</code>指向全局环境（浏览器为 <code>window</code>对象）；<code>call</code>方法可以改变 <code>this</code>的指向，指定 <code>this</code>指向对象 <code>obj</code>，然后在对象 <code>obj</code>的作用域中运行函数 <code>f</code>。</p>
<p><code>call</code>方法的参数，应该是一个对象。如果参数为空、<code>null</code>和 <code>undefined</code>，则默认传入全局对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; 123;</span><br><span class="line">var obj &#x3D; &#123; n: 456 &#125;;</span><br><span class="line"></span><br><span class="line">function a() &#123;</span><br><span class="line">  console.log(this.n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.call() &#x2F;&#x2F; 123</span><br><span class="line">a.call(null) &#x2F;&#x2F; 123</span><br><span class="line">a.call(undefined) &#x2F;&#x2F; 123</span><br><span class="line">a.call(window) &#x2F;&#x2F; 123</span><br><span class="line">a.call(obj) &#x2F;&#x2F; 456</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>函数中的 <code>this</code>关键字，如果指向全局对象，返回结果为 <code>123</code>。如果使用 <code>call</code>方法将 <code>this</code>关键字指向 <code>obj</code>对象，返回结果为 <code>456</code>。可以看到，如果 <code>call</code>方法没有参数，或者参数为 <code>null</code>或 <code>undefined</code>，则等同于指向全局对象。</p>
<p>如果 <code>call</code>方法的参数是一个原始值，那么这个原始值会自动转成对应的包装对象，然后传入 <code>call</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f.call(5)</span><br><span class="line">&#x2F;&#x2F; Number &#123;[[PrimitiveValue]]: 5&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>的参数为 <code>5</code>，不是对象，会被自动转成包装对象（<code>Number</code>的实例），绑定 <code>f</code>内部的 <code>this</code>。</p>
<p><code>call</code>方法还可以接受多个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.call(thisValue, arg1, arg2, ...)</span><br></pre></td></tr></table></figure>

<p><code>call</code>的第一个参数就是 <code>this</code>所要指向的那个对象，后面的参数则是函数调用时所需的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(a, b) &#123;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add.call(this, 1, 2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>call</code>方法指定函数 <code>add</code>内部的 <code>this</code>绑定当前环境（对象），并且参数为 <code>1</code>和 <code>2</code>，因此函数 <code>add</code>运行后得到 <code>3</code>。</p>
<p><code>call</code>方法的一个应用是调用对象的原生方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 覆盖掉继承的 hasOwnProperty 方法</span><br><span class="line">obj.hasOwnProperty &#x3D; function () &#123;</span><br><span class="line">  return true;</span><br><span class="line">&#125;;</span><br><span class="line">obj.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Object.prototype.hasOwnProperty.call(obj, &#39;toString&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>hasOwnProperty</code>是 <code>obj</code>对象继承的方法，如果这个方法一旦被覆盖，就不会得到正确结果。<code>call</code>方法可以解决这个问题，它将 <code>hasOwnProperty</code>方法的原始定义放到 <code>obj</code>对象上执行，这样无论 <code>obj</code>上有没有同名方法，都不会影响结果。</p>
<h4 id="Function-prototype-apply"><a href="#Function-prototype-apply" class="headerlink" title="Function.prototype.apply()"></a>Function.prototype.apply()</h4><p><code>apply</code>方法的作用与 <code>call</code>方法类似，也是改变 <code>this</code>指向，然后再调用该函数。唯一的区别就是，它接收一个数组作为函数执行时的参数，使用格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">func.apply(thisValue, [arg1, arg2, ...])</span><br></pre></td></tr></table></figure>

<p><code>apply</code>方法的第一个参数也是 <code>this</code>所要指向的那个对象，如果设为 <code>null</code>或 <code>undefined</code>，则等同于指定全局对象。第二个参数则是一个数组，该数组的所有成员依次作为参数，传入原函数。原函数的参数，在 <code>call</code>方法中必须一个个添加，但是在 <code>apply</code>方法中，必须以数组形式添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(x, y)&#123;</span><br><span class="line">  console.log(x + y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.call(null, 1, 1) &#x2F;&#x2F; 2</span><br><span class="line">f.apply(null, [1, 1]) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f</code>函数本来接受两个参数，使用 <code>apply</code>方法以后，就变成可以接受一个数组作为参数。</p>
<p>利用这一点，可以做一些有趣的应用。</p>
<p><strong>（1）找出数组最大元素</strong></p>
<p>JavaScript 不提供找出数组最大元素的函数。结合使用 <code>apply</code>方法和 <code>Math.max</code>方法，就可以返回数组的最大元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [10, 2, 4, 15, 9];</span><br><span class="line">Math.max.apply(null, a) &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<p><strong>（2）将数组的空元素变为 <code>undefined</code></strong></p>
<p>通过 <code>apply</code>方法，利用 <code>Array</code>构造函数将数组的空元素变成 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.apply(null, [&#39;a&#39;, ,&#39;b&#39;])</span><br><span class="line">&#x2F;&#x2F; [ &#39;a&#39;, undefined, &#39;b&#39; ]</span><br></pre></td></tr></table></figure>

<p>空元素与 <code>undefined</code>的差别在于，数组的 <code>forEach</code>方法会跳过空元素，但是不会跳过 <code>undefined</code>。因此，遍历内部元素的时候，会得到不同的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [&#39;a&#39;, , &#39;b&#39;];</span><br><span class="line"></span><br><span class="line">function print(i) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a.forEach(print)</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">&#x2F;&#x2F; b</span><br><span class="line"></span><br><span class="line">Array.apply(null, a).forEach(print)</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">&#x2F;&#x2F; undefined</span><br><span class="line">&#x2F;&#x2F; b</span><br></pre></td></tr></table></figure>

<p><strong>（3）转换类似数组的对象</strong></p>
<p>另外，利用数组对象的 <code>slice</code>方法，可以将一个类似数组的对象（比如 <code>arguments</code>对象）转为真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.slice.apply(&#123;0: 1, length: 1&#125;) &#x2F;&#x2F; [1]</span><br><span class="line">Array.prototype.slice.apply(&#123;0: 1&#125;) &#x2F;&#x2F; []</span><br><span class="line">Array.prototype.slice.apply(&#123;0: 1, length: 2&#125;) &#x2F;&#x2F; [1, undefined]</span><br><span class="line">Array.prototype.slice.apply(&#123;length: 1&#125;) &#x2F;&#x2F; [undefined]</span><br></pre></td></tr></table></figure>

<p>上面代码的 <code>apply</code>方法的参数都是对象，但是返回结果都是数组，这就起到了将对象转成数组的目的。从上面代码可以看到，这个方法起作用的前提是，被处理的对象必须有 <code>length</code>属性，以及相对应的数字键。</p>
<p><strong>（4）绑定回调函数的对象</strong></p>
<p>前面的按钮点击事件的例子，可以改写如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">o.f &#x3D; function () &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; o);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var f &#x3D; function ()&#123;</span><br><span class="line">  o.f.apply(o);</span><br><span class="line">  &#x2F;&#x2F; 或者 o.f.call(o);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; jQuery 的写法</span><br><span class="line">$(&#39;#button&#39;).on(&#39;click&#39;, f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，点击按钮以后，控制台将会显示 <code>true</code>。由于 <code>apply()</code>方法（或者 <code>call()</code>方法）不仅绑定函数执行时所在的对象，还会立即执行函数，因此不得不把绑定语句写在一个函数体内。更简洁的写法是采用下面介绍的 <code>bind()</code>方法。</p>
<h4 id="Function-prototype-bind"><a href="#Function-prototype-bind" class="headerlink" title="Function.prototype.bind()"></a>Function.prototype.bind()</h4><p><code>bind()</code>方法用于将函数体内的 <code>this</code>绑定到某个对象，然后返回一个新函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; new Date();</span><br><span class="line">d.getTime() &#x2F;&#x2F; 1481869925657</span><br><span class="line"></span><br><span class="line">var print &#x3D; d.getTime;</span><br><span class="line">print() &#x2F;&#x2F; Uncaught TypeError: this is not a Date object.</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们将 <code>d.getTime()</code>方法赋给变量 <code>print</code>，然后调用 <code>print()</code>就报错了。这是因为 <code>getTime()</code>方法内部的 <code>this</code>，绑定 <code>Date</code>对象的实例，赋给变量 <code>print</code>以后，内部的 <code>this</code>已经不指向 <code>Date</code>对象的实例了。</p>
<p><code>bind()</code>方法可以解决这个问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var print &#x3D; d.getTime.bind(d);</span><br><span class="line">print() &#x2F;&#x2F; 1481869925657</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法将 <code>getTime()</code>方法内部的 <code>this</code>绑定到 <code>d</code>对象，这时就可以安全地将这个方法赋值给其他变量了。</p>
<p><code>bind</code>方法的参数就是所要绑定 <code>this</code>的对象，下面是一个更清晰的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  inc: function () &#123;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var func &#x3D; counter.inc.bind(counter);</span><br><span class="line">func();</span><br><span class="line">counter.count &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>counter.inc()</code>方法被赋值给变量 <code>func</code>。这时必须用 <code>bind()</code>方法将 <code>inc()</code>内部的 <code>this</code>，绑定到 <code>counter</code>，否则就会出错。</p>
<p><code>this</code>绑定到其他对象也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  inc: function () &#123;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  count: 100</span><br><span class="line">&#125;;</span><br><span class="line">var func &#x3D; counter.inc.bind(obj);</span><br><span class="line">func();</span><br><span class="line">obj.count &#x2F;&#x2F; 101</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法将 <code>inc()</code>方法内部的 <code>this</code>，绑定到 <code>obj</code>对象。结果调用 <code>func</code>函数以后，递增的就是 <code>obj</code>内部的 <code>count</code>属性。</p>
<p><code>bind()</code>还可以接受更多的参数，将这些参数绑定原函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; function (x, y) &#123;</span><br><span class="line">  return x * this.m + y * this.n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  m: 2,</span><br><span class="line">  n: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var newAdd &#x3D; add.bind(obj, 5);</span><br><span class="line">newAdd(5) &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>bind()</code>方法除了绑定 <code>this</code>对象，还将 <code>add()</code>函数的第一个参数 <code>x</code>绑定成 <code>5</code>，然后返回一个新函数 <code>newAdd()</code>，这个函数只要再接受一个参数 <code>y</code>就能运行了。</p>
<p>如果 <code>bind()</code>方法的第一个参数是 <code>null</code>或 <code>undefined</code>，等于将 <code>this</code>绑定到全局对象，函数运行时 <code>this</code>指向顶层对象（浏览器为 <code>window</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var plus5 &#x3D; add.bind(null, 5);</span><br><span class="line">plus5(10) &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 <code>add()</code>内部并没有 <code>this</code>，使用 <code>bind()</code>方法的主要目的是绑定参数 <code>x</code>，以后每次运行新函数 <code>plus5()</code>，就只需要提供另一个参数 <code>y</code>就够了。而且因为 <code>add()</code>内部没有 <code>this</code>，所以 <code>bind()</code>的第一个参数是 <code>null</code>，不过这里如果是其他对象，也没有影响。</p>
<p><code>bind()</code>方法有一些使用注意点。</p>
<p><strong>（1）每一次返回一个新函数</strong></p>
<p><code>bind()</code>方法每运行一次，就返回一个新函数，这会产生一些问题。比如，监听事件的时候，不能写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.addEventListener(&#39;click&#39;, o.m.bind(o));</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>click</code>事件绑定 <code>bind()</code>方法生成的一个匿名函数。这样会导致无法取消绑定，所以下面的代码是无效的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">element.removeEventListener(&#39;click&#39;, o.m.bind(o));</span><br></pre></td></tr></table></figure>

<p>正确的方法是写成下面这样：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var listener &#x3D; o.m.bind(o);</span><br><span class="line">element.addEventListener(&#39;click&#39;, listener);</span><br><span class="line">&#x2F;&#x2F;  ...</span><br><span class="line">element.removeEventListener(&#39;click&#39;, listener);</span><br></pre></td></tr></table></figure>

<p><strong>（2）结合回调函数使用</strong></p>
<p>回调函数是 JavaScript 最常用的模式之一，但是一个常见的错误是，将包含 <code>this</code>的方法直接当作回调函数。解决方法就是使用 <code>bind()</code>方法，将 <code>counter.inc()</code>绑定 <code>counter</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var counter &#x3D; &#123;</span><br><span class="line">  count: 0,</span><br><span class="line">  inc: function () &#123;</span><br><span class="line">    &#39;use strict&#39;;</span><br><span class="line">    this.count++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function callIt(callback) &#123;</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">callIt(counter.inc.bind(counter));</span><br><span class="line">counter.count &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>callIt()</code>方法会调用回调函数。这时如果直接把 <code>counter.inc</code>传入，调用时 <code>counter.inc()</code>内部的 <code>this</code>就会指向全局对象。使用 <code>bind()</code>方法将 <code>counter.inc</code>绑定 <code>counter</code>以后，就不会有这个问题，<code>this</code>总是指向 <code>counter</code>。</p>
<p>还有一种情况比较隐蔽，就是某些数组方法可以接受一个函数当作参数。这些函数内部的 <code>this</code>指向，很可能也会出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;,</span><br><span class="line">  times: [1, 2, 3],</span><br><span class="line">  print: function () &#123;</span><br><span class="line">    this.times.forEach(function (n) &#123;</span><br><span class="line">      console.log(this.name);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line">&#x2F;&#x2F; 没有任何输出</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.print</code>内部 <code>this.times</code>的 <code>this</code>是指向 <code>obj</code>的，这个没有问题。但是，<code>forEach()</code>方法的回调函数内部的 <code>this.name</code>却是指向全局对象，导致没有办法取到值。稍微改动一下，就可以看得更清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.print &#x3D; function () &#123;</span><br><span class="line">  this.times.forEach(function (n) &#123;</span><br><span class="line">    console.log(this &#x3D;&#x3D;&#x3D; window);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>解决这个问题，也是通过 <code>bind()</code>方法绑定 <code>this</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">obj.print &#x3D; function () &#123;</span><br><span class="line">  this.times.forEach(function (n) &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;.bind(this));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.print()</span><br><span class="line">&#x2F;&#x2F; 张三</span><br><span class="line">&#x2F;&#x2F; 张三</span><br><span class="line">&#x2F;&#x2F; 张三</span><br></pre></td></tr></table></figure>

<p><strong>（3）结合 <code>call()</code>方法使用</strong></p>
<p>利用 <code>bind()</code>方法，可以改写一些 JavaScript 原生方法的使用形式，以数组的 <code>slice()</code>方法为例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[1, 2, 3].slice(0, 1) &#x2F;&#x2F; [1]</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">Array.prototype.slice.call([1, 2, 3], 0, 1) &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure>

<p>上面的代码中，数组的 <code>slice</code>方法从 <code>[1, 2, 3]</code>里面，按照指定的开始位置和结束位置，切分出另一个数组。这样做的本质是在 <code>[1, 2, 3]</code>上面调用 <code>Array.prototype.slice()</code>方法，因此可以用 <code>call</code>方法表达这个过程，得到同样的结果。</p>
<p><code>call()</code>方法实质上是调用 <code>Function.prototype.call()</code>方法，因此上面的表达式可以用 <code>bind()</code>方法改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var slice &#x3D; Function.prototype.call.bind(Array.prototype.slice);</span><br><span class="line">slice([1, 2, 3], 0, 1) &#x2F;&#x2F; [1]</span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将 <code>Array.prototype.slice</code>变成 <code>Function.prototype.call</code>方法所在的对象，调用时就变成了 <code>Array.prototype.slice.call</code>。类似的写法还可以用于其他数组方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var push &#x3D; Function.prototype.call.bind(Array.prototype.push);</span><br><span class="line">var pop &#x3D; Function.prototype.call.bind(Array.prototype.pop);</span><br><span class="line"></span><br><span class="line">var a &#x3D; [1 ,2 ,3];</span><br><span class="line">push(a, 4)</span><br><span class="line">a &#x2F;&#x2F; [1, 2, 3, 4]</span><br><span class="line"></span><br><span class="line">pop(a)</span><br><span class="line">a &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>如果再进一步，将 <code>Function.prototype.call</code>方法绑定到 <code>Function.prototype.bind</code>对象，就意味着 <code>bind</code>的调用形式也可以被改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(this.v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var o &#x3D; &#123; v: 123 &#125;;</span><br><span class="line">var bind &#x3D; Function.prototype.call.bind(Function.prototype.bind);</span><br><span class="line">bind(f, o)() &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure>

<p>上面代码的含义就是，将 <code>Function.prototype.bind</code>方法绑定在 <code>Function.prototype.call</code>上面，所以 <code>bind</code>方法就可以直接使用，不需要在函数实例上使用。</p>
<h2 id="对象的继承"><a href="#对象的继承" class="headerlink" title="对象的继承"></a>对象的继承</h2><p>面向对象编程很重要的一个方面，就是对象的继承。A 对象通过继承 B 对象，就能直接拥有 B 对象的所有属性和方法。这对于代码的复用是非常有用的。</p>
<p>大部分面向对象的编程语言，都是通过“类”（class）实现对象的继承。传统上，JavaScript 语言的继承不通过 class，而是通过“原型对象”（prototype）实现，本章介绍 JavaScript 的原型链继承。</p>
<h3 id="原型对象概述"><a href="#原型对象概述" class="headerlink" title="原型对象概述"></a>原型对象概述</h3><h4 id="构造函数的缺点"><a href="#构造函数的缺点" class="headerlink" title="构造函数的缺点"></a>构造函数的缺点</h4><p>JavaScript 通过构造函数生成新对象，因此构造函数可以视为对象的模板。实例对象的属性和方法，可以定义在构造函数内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Cat (name, color) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.color &#x3D; color;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat1 &#x3D; new Cat(&#39;大毛&#39;, &#39;白色&#39;);</span><br><span class="line"></span><br><span class="line">cat1.name &#x2F;&#x2F; &#39;大毛&#39;</span><br><span class="line">cat1.color &#x2F;&#x2F; &#39;白色&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Cat</code>函数是一个构造函数，函数内部定义了 <code>name</code>属性和 <code>color</code>属性，所有实例对象（上例是 <code>cat1</code>）都会生成这两个属性，即这两个属性会定义在实例对象上面。</p>
<p>通过构造函数为实例对象定义属性，虽然很方便，但是有一个缺点。同一个构造函数的多个实例之间，无法共享属性，从而造成对系统资源的浪费。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function Cat(name, color) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.color &#x3D; color;</span><br><span class="line">  this.meow &#x3D; function () &#123;</span><br><span class="line">    console.log(&#39;喵喵&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cat1 &#x3D; new Cat(&#39;大毛&#39;, &#39;白色&#39;);</span><br><span class="line">var cat2 &#x3D; new Cat(&#39;二毛&#39;, &#39;黑色&#39;);</span><br><span class="line"></span><br><span class="line">cat1.meow &#x3D;&#x3D;&#x3D; cat2.meow</span><br><span class="line">&#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>cat1</code>和 <code>cat2</code>是同一个构造函数的两个实例，它们都具有 <code>meow</code>方法。由于 <code>meow</code>方法是生成在每个实例对象上面，所以两个实例就生成了两次。也就是说，每新建一个实例，就会新建一个 <code>meow</code>方法。这既没有必要，又浪费系统资源，因为所有 <code>meow</code>方法都是同样的行为，完全应该共享。</p>
<p>这个问题的解决方法，就是 JavaScript 的原型对象（prototype）。</p>
<h4 id="prototype-属性的作用"><a href="#prototype-属性的作用" class="headerlink" title="prototype 属性的作用"></a>prototype 属性的作用</h4><p>JavaScript 继承机制的设计思想就是，原型对象的所有属性和方法，都能被实例对象共享。也就是说，如果属性和方法定义在原型上，那么所有实例对象就能共享，不仅节省了内存，还体现了实例对象之间的联系。</p>
<p>下面，先看怎么为对象指定原型。JavaScript 规定，每个函数都有一个 <code>prototype</code>属性，指向一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f.prototype &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 <code>f</code>默认具有 <code>prototype</code>属性，指向一个对象。</p>
<p>对于普通函数来说，该属性基本无用。但是，对于构造函数来说，生成实例的时候，该属性会自动成为实例对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Animal(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.color &#x3D; &#39;white&#39;;</span><br><span class="line"></span><br><span class="line">var cat1 &#x3D; new Animal(&#39;大毛&#39;);</span><br><span class="line">var cat2 &#x3D; new Animal(&#39;二毛&#39;);</span><br><span class="line"></span><br><span class="line">cat1.color &#x2F;&#x2F; &#39;white&#39;</span><br><span class="line">cat2.color &#x2F;&#x2F; &#39;white&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数 <code>Animal</code>的 <code>prototype</code>属性，就是实例对象 <code>cat1</code>和 <code>cat2</code>的原型对象。原型对象上添加一个 <code>color</code>属性，结果，实例对象都共享了该属性。</p>
<p>原型对象的属性不是实例对象自身的属性。只要修改原型对象，变动就立刻会体现在<strong>所有</strong>实例对象上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.color &#x3D; &#39;yellow&#39;;</span><br><span class="line"></span><br><span class="line">cat1.color &#x2F;&#x2F; &quot;yellow&quot;</span><br><span class="line">cat2.color &#x2F;&#x2F; &quot;yellow&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，原型对象的 <code>color</code>属性的值变为 <code>yellow</code>，两个实例对象的 <code>color</code>属性立刻跟着变了。这是因为实例对象其实没有 <code>color</code>属性，都是读取原型对象的 <code>color</code>属性。也就是说，当实例对象本身没有某个属性或方法的时候，它会到原型对象去寻找该属性或方法。这就是原型对象的特殊之处。</p>
<p>如果实例对象自身就有某个属性或方法，它就不会再去原型对象寻找这个属性或方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">cat1.color &#x3D; &#39;black&#39;;</span><br><span class="line"></span><br><span class="line">cat1.color &#x2F;&#x2F; &#39;black&#39;</span><br><span class="line">cat2.color &#x2F;&#x2F; &#39;yellow&#39;</span><br><span class="line">Animal.prototype.color &#x2F;&#x2F; &#39;yellow&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象 <code>cat1</code>的 <code>color</code>属性改为 <code>black</code>，就使得它不再去原型对象读取 <code>color</code>属性，后者的值依然为 <code>yellow</code>。</p>
<p>总结一下，原型对象的作用，就是定义所有实例对象共享的属性和方法。这也是它被称为原型对象的原因，而实例对象可以视作从原型对象衍生出来的子对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.walk &#x3D; function () &#123;</span><br><span class="line">  console.log(this.name + &#39; is walking&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Animal.prototype</code>对象上面定义了一个 <code>walk</code>方法，这个方法将可以在所有 <code>Animal</code>实例对象上面调用。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>JavaScript 规定，所有对象都有自己的原型对象（prototype）。一方面，任何一个对象，都可以充当其他对象的原型；另一方面，由于原型对象也是对象，所以它也有自己的原型。因此，就会形成一个“原型链”（prototype chain）：对象到原型，再到原型的原型……</p>
<p>如果一层层地上溯，所有对象的原型最终都可以上溯到 <code>Object.prototype</code>，即 <code>Object</code>构造函数的 <code>prototype</code>属性。也就是说，所有对象都继承了 <code>Object.prototype</code>的属性。这就是所有对象都有 <code>valueOf</code>和 <code>toString</code>方法的原因，因为这是从 <code>Object.prototype</code>继承的。</p>
<p>那么，<code>Object.prototype</code>对象有没有它的原型呢？回答是 <code>Object.prototype</code>的原型是 <code>null</code>。<code>null</code>没有任何属性和方法，也没有自己的原型。因此，原型链的尽头就是 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(Object.prototype)</span><br><span class="line">&#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>Object.prototype</code>对象的原型是 <code>null</code>，由于 <code>null</code>没有任何属性，所以原型链到此为止。<code>Object.getPrototypeOf</code>方法返回参数对象的原型，具体介绍请看后文。</p>
<p>读取对象的某个属性时，JavaScript 引擎先寻找对象本身的属性，如果找不到，就到它的原型去找，如果还是找不到，就到原型的原型去找。如果直到最顶层的 <code>Object.prototype</code>还是找不到，则返回 <code>undefined</code>。如果对象自身和它的原型，都定义了一个同名属性，那么优先读取对象自身的属性，这叫做“覆盖”（overriding）。</p>
<p>注意，一级级向上，在整个原型链上寻找某个属性，对性能是有影响的。所寻找的属性在越上层的原型对象，对性能的影响越大。如果寻找某个不存在的属性，将会遍历整个原型链。</p>
<p>举例来说，如果让构造函数的 <code>prototype</code>属性指向一个数组，就意味着实例对象可以调用数组方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var MyArray &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">MyArray.prototype &#x3D; new Array();</span><br><span class="line">MyArray.prototype.constructor &#x3D; MyArray;</span><br><span class="line"></span><br><span class="line">var mine &#x3D; new MyArray();</span><br><span class="line">mine.push(1, 2, 3);</span><br><span class="line">mine.length &#x2F;&#x2F; 3</span><br><span class="line">mine instanceof Array &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>mine</code>是构造函数 <code>MyArray</code>的实例对象，由于 <code>MyArray.prototype</code>指向一个数组实例，使得 <code>mine</code>可以调用数组方法（这些方法定义在数组实例的 <code>prototype</code>对象上面）。最后那行 <code>instanceof</code>表达式，用来比较一个对象是否为某个构造函数的实例，结果就是证明 <code>mine</code>为 <code>Array</code>的实例，<code>instanceof</code>运算符的详细解释详见后文。</p>
<p>上面代码还出现了原型对象的 <code>constructor</code>属性，这个属性的含义下一节就来解释。</p>
<h4 id="constructor-属性"><a href="#constructor-属性" class="headerlink" title="constructor 属性"></a>constructor 属性</h4><p><code>prototype</code>对象有一个 <code>constructor</code>属性，默认指向 <code>prototype</code>对象所在的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function P() &#123;&#125;</span><br><span class="line">P.prototype.constructor &#x3D;&#x3D;&#x3D; P &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>由于 <code>constructor</code>属性定义在 <code>prototype</code>对象上面，意味着可以被所有实例对象继承。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function P() &#123;&#125;</span><br><span class="line">var p &#x3D; new P();</span><br><span class="line"></span><br><span class="line">p.constructor &#x3D;&#x3D;&#x3D; P &#x2F;&#x2F; true</span><br><span class="line">p.constructor &#x3D;&#x3D;&#x3D; P.prototype.constructor &#x2F;&#x2F; true</span><br><span class="line">p.hasOwnProperty(&#39;constructor&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p</code>是构造函数 <code>P</code>的实例对象，但是 <code>p</code>自身没有 <code>constructor</code>属性，该属性其实是读取原型链上面的 <code>P.prototype.constructor</code>属性。</p>
<p><code>constructor</code>属性的作用是，可以得知某个实例对象，到底是哪一个构造函数产生的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function F() &#123;&#125;;</span><br><span class="line">var f &#x3D; new F();</span><br><span class="line"></span><br><span class="line">f.constructor &#x3D;&#x3D;&#x3D; F &#x2F;&#x2F; true</span><br><span class="line">f.constructor &#x3D;&#x3D;&#x3D; RegExp &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>constructor</code>属性确定了实例对象 <code>f</code>的构造函数是 <code>F</code>，而不是 <code>RegExp</code>。</p>
<p>另一方面，有了 <code>constructor</code>属性，就可以从一个实例对象新建另一个实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function Constr() &#123;&#125;</span><br><span class="line">var x &#x3D; new Constr();</span><br><span class="line"></span><br><span class="line">var y &#x3D; new x.constructor();</span><br><span class="line">y instanceof Constr &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>x</code>是构造函数 <code>Constr</code>的实例，可以从 <code>x.constructor</code>间接调用构造函数。这使得在实例方法中，调用自身的构造函数成为可能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Constr.prototype.createCopy &#x3D; function () &#123;</span><br><span class="line">  return new this.constructor();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>createCopy</code>方法调用构造函数，新建另一个实例。</p>
<p><code>constructor</code>属性表示原型对象与构造函数之间的关联关系，如果修改了原型对象，一般会同时修改 <code>constructor</code>属性，防止引用的时候出错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor &#x3D;&#x3D;&#x3D; Person &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">  method: function () &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Person.prototype.constructor &#x3D;&#x3D;&#x3D; Person &#x2F;&#x2F; false</span><br><span class="line">Person.prototype.constructor &#x3D;&#x3D;&#x3D; Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数 <code>Person</code>的原型对象改掉了，但是没有修改 <code>constructor</code>属性，导致这个属性不再指向 <code>Person</code>。由于 <code>Person</code>的新原型是一个普通对象，而普通对象的 <code>constructor</code>属性指向 <code>Object</code>构造函数，导致 <code>Person.prototype.constructor</code>变成了 <code>Object</code>。</p>
<p>所以，修改原型对象时，一般要同时修改 <code>constructor</code>属性的指向。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 坏的写法</span><br><span class="line">C.prototype &#x3D; &#123;</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 好的写法</span><br><span class="line">C.prototype &#x3D; &#123;</span><br><span class="line">  constructor: C,</span><br><span class="line">  method1: function (...) &#123; ... &#125;,</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 更好的写法</span><br><span class="line">C.prototype.method1 &#x3D; function (...) &#123; ... &#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，要么将 <code>constructor</code>属性重新指向原来的构造函数，要么只在原型对象上添加方法，这样可以保证 <code>instanceof</code>运算符不会失真。</p>
<p>如果不能确定 <code>constructor</code>属性是什么函数，还有一个办法：通过 <code>name</code>属性，从实例得到构造函数的名称。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function Foo() &#123;&#125;</span><br><span class="line">var f &#x3D; new Foo();</span><br><span class="line">f.constructor.name &#x2F;&#x2F; &quot;Foo&quot;</span><br></pre></td></tr></table></figure>

<h3 id="instanceof-运算符"><a href="#instanceof-运算符" class="headerlink" title="instanceof 运算符"></a>instanceof 运算符</h3><p><code>instanceof</code>运算符返回一个布尔值，表示对象是否为某个构造函数的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var v &#x3D; new Vehicle();</span><br><span class="line">v instanceof Vehicle &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象 <code>v</code>是构造函数 <code>Vehicle</code>的实例，所以返回 <code>true</code>。</p>
<p><code>instanceof</code>运算符的左边是实例对象，右边是构造函数。它会检查右边构造函数的原型对象（prototype），是否在左边对象的原型链上。因此，下面两种写法是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">v instanceof Vehicle</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">Vehicle.prototype.isPrototypeOf(v)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Vehicle</code>是对象 <code>v</code>的构造函数，它的原型对象是 <code>Vehicle.prototype</code>，<code>isPrototypeOf()</code>方法是 JavaScript 提供的原生方法，用于检查某个对象是否为另一个对象的原型，详细解释见后文。</p>
<p>由于 <code>instanceof</code>检查整个原型链，因此同一个实例对象，可能会对多个构造函数都返回 <code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var d &#x3D; new Date();</span><br><span class="line">d instanceof Date &#x2F;&#x2F; true</span><br><span class="line">d instanceof Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>d</code>同时是 <code>Date</code>和 <code>Object</code>的实例，因此对这两个构造函数都返回 <code>true</code>。</p>
<p>由于任意对象（除了 <code>null</code>）都是 <code>Object</code>的实例，所以 <code>instanceof</code>运算符可以判断一个值是否为非 <code>null</code>的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; foo: 123 &#125;;</span><br><span class="line">obj instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">null instanceof Object &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，除了 <code>null</code>，其他对象的 <code>instanceOf Object</code>的运算结果都是 <code>true</code>。</p>
<p><code>instanceof</code>的原理是检查右边构造函数的 <code>prototype</code>属性，是否在左边对象的原型链上。有一种特殊情况，就是左边对象的原型链上，只有 <code>null</code>对象。这时，<code>instanceof</code>判断会失真。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; Object.create(null);</span><br><span class="line">typeof obj &#x2F;&#x2F; &quot;object&quot;</span><br><span class="line">obj instanceof Object &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create(null)</code>返回一个新对象 <code>obj</code>，它的原型是 <code>null</code>（<code>Object.create()</code>的详细介绍见后文）。右边的构造函数 <code>Object</code>的 <code>prototype</code>属性，不在左边的原型链上，因此 <code>instanceof</code>就认为 <code>obj</code>不是 <code>Object</code>的实例。这是唯一的 <code>instanceof</code>运算符判断会失真的情况（一个对象的原型是 <code>null</code>）。</p>
<p><code>instanceof</code>运算符的一个用处，是判断值的类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; [1, 2, 3];</span><br><span class="line">var y &#x3D; &#123;&#125;;</span><br><span class="line">x instanceof Array &#x2F;&#x2F; true</span><br><span class="line">y instanceof Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>instanceof</code>运算符判断，变量 <code>x</code>是数组，变量 <code>y</code>是对象。</p>
<p>注意，<code>instanceof</code>运算符只能用于对象，不适用原始类型的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &#39;hello&#39;;</span><br><span class="line">s instanceof String &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，字符串不是 <code>String</code>对象的实例（因为字符串不是对象），所以返回 <code>false</code>。</p>
<p>此外，对于 <code>undefined</code>和 <code>null</code>，<code>instanceof</code>运算符总是返回 <code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undefined instanceof Object &#x2F;&#x2F; false</span><br><span class="line">null instanceof Object &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>利用 <code>instanceof</code>运算符，还可以巧妙地解决，调用构造函数时，忘了加 <code>new</code>命令的问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function Fubar (foo, bar) &#123;</span><br><span class="line">  if (this instanceof Fubar) &#123;</span><br><span class="line">    this._foo &#x3D; foo;</span><br><span class="line">    this._bar &#x3D; bar;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return new Fubar(foo, bar);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码使用 <code>instanceof</code>运算符，在函数体内部判断 <code>this</code>关键字是否为构造函数 <code>Fubar</code>的实例。如果不是，就表明忘了加 <code>new</code>命令。</p>
<h3 id="构造函数的继承"><a href="#构造函数的继承" class="headerlink" title="构造函数的继承"></a>构造函数的继承</h3><p>让一个构造函数继承另一个构造函数，是非常常见的需求。这可以分成两步实现。第一步是在子类的构造函数中，调用父类的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function Sub(value) &#123;</span><br><span class="line">  Super.call(this);</span><br><span class="line">  this.prop &#x3D; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub</code>是子类的构造函数，<code>this</code>是子类的实例。在实例上调用父类的构造函数 <code>Super</code>，就会让子类实例具有父类实例的属性。</p>
<p>第二步，是让子类的原型指向父类的原型，这样子类就可以继承父类原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype &#x3D; Object.create(Super.prototype);</span><br><span class="line">Sub.prototype.constructor &#x3D; Sub;</span><br><span class="line">Sub.prototype.method &#x3D; &#39;...&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Sub.prototype</code>是子类的原型，要将它赋值为 <code>Object.create(Super.prototype)</code>，而不是直接等于 <code>Super.prototype</code>。否则后面两行对 <code>Sub.prototype</code>的操作，会连父类的原型 <code>Super.prototype</code>一起修改掉。</p>
<p>另外一种写法是 <code>Sub.prototype</code>等于一个父类实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sub.prototype &#x3D; new Super();</span><br></pre></td></tr></table></figure>

<p>上面这种写法也有继承的效果，但是子类会具有父类实例的方法。有时，这可能不是我们需要的，所以不推荐使用这种写法。</p>
<p>举例来说，下面是一个 <code>Shape</code>构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function Shape() &#123;</span><br><span class="line">  this.x &#x3D; 0;</span><br><span class="line">  this.y &#x3D; 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Shape.prototype.move &#x3D; function (x, y) &#123;</span><br><span class="line">  this.x +&#x3D; x;</span><br><span class="line">  this.y +&#x3D; y;</span><br><span class="line">  console.info(&#39;Shape moved.&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>我们需要让 <code>Rectangle</code>构造函数继承 <code>Shape</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 第一步，子类继承父类的实例</span><br><span class="line">function Rectangle() &#123;</span><br><span class="line">  Shape.call(this); &#x2F;&#x2F; 调用父类构造函数</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 另一种写法</span><br><span class="line">function Rectangle() &#123;</span><br><span class="line">  this.base &#x3D; Shape;</span><br><span class="line">  this.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 第二步，子类继承父类的原型</span><br><span class="line">Rectangle.prototype &#x3D; Object.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor &#x3D; Rectangle;</span><br></pre></td></tr></table></figure>

<p>采用这样的写法以后，<code>instanceof</code>运算符会对子类和父类的构造函数，都返回 <code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var rect &#x3D; new Rectangle();</span><br><span class="line"></span><br><span class="line">rect instanceof Rectangle  &#x2F;&#x2F; true</span><br><span class="line">rect instanceof Shape  &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类是整体继承父类。有时只需要单个方法的继承，这时可以采用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassB.prototype.print &#x3D; function() &#123;</span><br><span class="line">  ClassA.prototype.print.call(this);</span><br><span class="line">  &#x2F;&#x2F; some code</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类 <code>B</code>的 <code>print</code>方法先调用父类 <code>A</code>的 <code>print</code>方法，再部署自己的代码。这就等于继承了父类 <code>A</code>的 <code>print</code>方法。</p>
<h3 id="多重继承"><a href="#多重继承" class="headerlink" title="多重继承"></a>多重继承</h3><p>JavaScript 不提供多重继承功能，即不允许一个对象同时继承多个对象。但是，可以通过变通方法，实现这个功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function M1() &#123;</span><br><span class="line">  this.hello &#x3D; &#39;hello&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function M2() &#123;</span><br><span class="line">  this.world &#x3D; &#39;world&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function S() &#123;</span><br><span class="line">  M1.call(this);</span><br><span class="line">  M2.call(this);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 继承 M1</span><br><span class="line">S.prototype &#x3D; Object.create(M1.prototype);</span><br><span class="line">&#x2F;&#x2F; 继承链上加入 M2</span><br><span class="line">Object.assign(S.prototype, M2.prototype);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定构造函数</span><br><span class="line">S.prototype.constructor &#x3D; S;</span><br><span class="line"></span><br><span class="line">var s &#x3D; new S();</span><br><span class="line">s.hello &#x2F;&#x2F; &#39;hello&#39;</span><br><span class="line">s.world &#x2F;&#x2F; &#39;world&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子类 <code>S</code>同时继承了父类 <code>M1</code>和 <code>M2</code>。这种模式又称为 Mixin（混入）。</p>
<h3 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h3><p>随着网站逐渐变成“互联网应用程序”，嵌入网页的 JavaScript 代码越来越庞大，越来越复杂。网页越来越像桌面程序，需要一个团队分工协作、进度管理、单元测试等等……开发者必须使用软件工程的方法，管理网页的业务逻辑。</p>
<p>JavaScript 模块化编程，已经成为一个迫切的需求。理想情况下，开发者只需要实现核心的业务逻辑，其他都可以加载别人已经写好的模块。</p>
<p>但是，JavaScript 不是一种模块化编程语言，ES6 才开始支持“类”和“模块”。下面介绍传统的做法，如何利用对象实现模块的效果。</p>
<h4 id="基本的实现方法"><a href="#基本的实现方法" class="headerlink" title="基本的实现方法"></a>基本的实现方法</h4><p>模块是实现特定功能的一组属性和方法的封装。</p>
<p>简单的做法是把模块写成一个对象，所有的模块成员都放到这个对象里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var module1 &#x3D; new Object(&#123;</span><br><span class="line">　_count : 0,</span><br><span class="line">　m1 : function ()&#123;</span><br><span class="line">　　&#x2F;&#x2F;...</span><br><span class="line">　&#125;,</span><br><span class="line">　m2 : function ()&#123;</span><br><span class="line">  　&#x2F;&#x2F;...</span><br><span class="line">　&#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的函数 <code>m1</code>和 <code>m2</code>，都封装在 <code>module1</code>对象里。使用的时候，就是调用这个对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1.m1();</span><br></pre></td></tr></table></figure>

<p>但是，这样的写法会暴露所有模块成员，内部状态可以被外部改写。比如，外部代码可以直接改变内部计数器的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module1._count &#x3D; 5;</span><br></pre></td></tr></table></figure>

<h4 id="封装私有变量：构造函数的写法"><a href="#封装私有变量：构造函数的写法" class="headerlink" title="封装私有变量：构造函数的写法"></a>封装私有变量：构造函数的写法</h4><p>我们可以利用构造函数，封装私有变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function StringBuilder() &#123;</span><br><span class="line">  var buffer &#x3D; [];</span><br><span class="line"></span><br><span class="line">  this.add &#x3D; function (str) &#123;</span><br><span class="line">     buffer.push(str);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  this.toString &#x3D; function () &#123;</span><br><span class="line">    return buffer.join(&#39;&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>buffer</code>是模块的私有变量。一旦生成实例对象，外部是无法直接访问 <code>buffer</code>的。但是，这种方法将私有变量封装在构造函数中，导致构造函数与实例对象是一体的，总是存在于内存之中，无法在使用完成后清除。这意味着，构造函数有双重作用，既用来塑造实例对象，又用来保存实例对象的数据，违背了构造函数与实例对象在数据上相分离的原则（即实例对象的数据，不应该保存在实例对象以外）。同时，非常耗费内存。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function StringBuilder() &#123;</span><br><span class="line">  this._buffer &#x3D; [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StringBuilder.prototype &#x3D; &#123;</span><br><span class="line">  constructor: StringBuilder,</span><br><span class="line">  add: function (str) &#123;</span><br><span class="line">    this._buffer.push(str);</span><br><span class="line">  &#125;,</span><br><span class="line">  toString: function () &#123;</span><br><span class="line">    return this._buffer.join(&#39;&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种方法将私有变量放入实例对象中，好处是看上去更自然，但是它的私有变量可以从外部读写，不是很安全。</p>
<h4 id="封装私有变量：立即执行函数的写法"><a href="#封装私有变量：立即执行函数的写法" class="headerlink" title="封装私有变量：立即执行函数的写法"></a>封装私有变量：立即执行函数的写法</h4><p>另一种做法是使用“立即执行函数”（Immediately-Invoked Function Expression，IIFE），将相关的属性和方法封装在一个函数作用域里面，可以达到不暴露私有成员的目的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var module1 &#x3D; (function () &#123;</span><br><span class="line">　var _count &#x3D; 0;</span><br><span class="line">　var m1 &#x3D; function () &#123;</span><br><span class="line">　  &#x2F;&#x2F;...</span><br><span class="line">　&#125;;</span><br><span class="line">　var m2 &#x3D; function () &#123;</span><br><span class="line">　　&#x2F;&#x2F;...</span><br><span class="line">　&#125;;</span><br><span class="line">　return &#123;</span><br><span class="line">　　m1 : m1,</span><br><span class="line">　　m2 : m2</span><br><span class="line">　&#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>使用上面的写法，外部代码无法读取内部的 <code>_count</code>变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.info(module1._count); &#x2F;&#x2F;undefined</span><br></pre></td></tr></table></figure>

<p>上面的 <code>module1</code>就是 JavaScript 模块的基本写法。下面，再对这种写法进行加工。</p>
<h4 id="模块的放大模式"><a href="#模块的放大模式" class="headerlink" title="模块的放大模式"></a>模块的放大模式</h4><p>如果一个模块很大，必须分成几个部分，或者一个模块需要继承另一个模块，这时就有必要采用“放大模式”（augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var module1 &#x3D; (function (mod)&#123;</span><br><span class="line">　mod.m3 &#x3D; function () &#123;</span><br><span class="line">　　&#x2F;&#x2F;...</span><br><span class="line">　&#125;;</span><br><span class="line">　return mod;</span><br><span class="line">&#125;)(module1);</span><br></pre></td></tr></table></figure>

<p>上面的代码为 <code>module1</code>模块添加了一个新方法 <code>m3()</code>，然后返回新的 <code>module1</code>模块。</p>
<p>在浏览器环境中，模块的各个部分通常都是从网上获取的，有时无法知道哪个部分会先加载。如果采用上面的写法，第一个执行的部分有可能加载一个不存在空对象，这时就要采用”宽放大模式”（Loose augmentation）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var module1 &#x3D; (function (mod) &#123;</span><br><span class="line">　&#x2F;&#x2F;...</span><br><span class="line">　return mod;</span><br><span class="line">&#125;)(window.module1 || &#123;&#125;);</span><br></pre></td></tr></table></figure>

<p>与”放大模式”相比，“宽放大模式”就是“立即执行函数”的参数可以是空对象。</p>
<h4 id="输入全局变量"><a href="#输入全局变量" class="headerlink" title="输入全局变量"></a>输入全局变量</h4><p>独立性是模块的重要特点，模块内部最好不与程序的其他部分直接交互。</p>
<p>为了在模块内部调用全局变量，必须显式地将其他变量输入模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var module1 &#x3D; (function ($, YAHOO) &#123;</span><br><span class="line">　&#x2F;&#x2F;...</span><br><span class="line">&#125;)(jQuery, YAHOO);</span><br></pre></td></tr></table></figure>

<p>上面的 <code>module1</code>模块需要使用 jQuery 库和 YUI 库，就把这两个库（其实是两个模块）当作参数输入 <code>module1</code>。这样做除了保证模块的独立性，还使得模块之间的依赖关系变得明显。</p>
<p>立即执行函数还可以起到命名空间的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(function($, window, document) &#123;</span><br><span class="line"></span><br><span class="line">  function go(num) &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function handleEvents() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function initialize() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function dieCarouselDie() &#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F;attach to the global scope</span><br><span class="line">  window.finalCarousel &#x3D; &#123;</span><br><span class="line">    init : initialize,</span><br><span class="line">    destroy : dieCarouselDie</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;)( jQuery, window, document );</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>finalCarousel</code>对象输出到全局，对外暴露 <code>init</code>和 <code>destroy</code>接口，内部方法 <code>go</code>、<code>handleEvents</code>、<code>initialize</code>、<code>dieCarouselDie</code>都是外部无法调用的。</p>
<h2 id="Object对象的相关方法"><a href="#Object对象的相关方法" class="headerlink" title="Object对象的相关方法"></a>Object对象的相关方法</h2><p>JavaScript 在 <code>Object</code>对象上面，提供了很多相关方法，处理面向对象编程的相关操作。本章介绍这些方法。</p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p><code>Object.getPrototypeOf</code>方法返回参数对象的原型。这是获取原型对象的标准方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var F &#x3D; function () &#123;&#125;;</span><br><span class="line">var f &#x3D; new F();</span><br><span class="line">Object.getPrototypeOf(f) &#x3D;&#x3D;&#x3D; F.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象 <code>f</code>的原型是 <code>F.prototype</code>。</p>
<p>下面是几种特殊对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 空对象的原型是 Object.prototype</span><br><span class="line">Object.getPrototypeOf(&#123;&#125;) &#x3D;&#x3D;&#x3D; Object.prototype &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Object.prototype 的原型是 null</span><br><span class="line">Object.getPrototypeOf(Object.prototype) &#x3D;&#x3D;&#x3D; null &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数的原型是 Function.prototype</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">Object.getPrototypeOf(f) &#x3D;&#x3D;&#x3D; Function.prototype &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法为参数对象设置原型，返回该参数对象。它接受两个参数，第一个是现有对象，第二个是原型对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; &#123;&#125;;</span><br><span class="line">var b &#x3D; &#123;x: 1&#125;;</span><br><span class="line">Object.setPrototypeOf(a, b);</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(a) &#x3D;&#x3D;&#x3D; b &#x2F;&#x2F; true</span><br><span class="line">a.x &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.setPrototypeOf</code>方法将对象 <code>a</code>的原型，设置为对象 <code>b</code>，因此 <code>a</code>可以共享 <code>b</code>的属性。</p>
<p><code>new</code>命令可以使用 <code>Object.setPrototypeOf</code>方法模拟。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var F &#x3D; function () &#123;</span><br><span class="line">  this.foo &#x3D; &#39;bar&#39;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var f &#x3D; new F();</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">var f &#x3D; Object.setPrototypeOf(&#123;&#125;, F.prototype);</span><br><span class="line">F.call(f);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>new</code>命令新建实例对象，其实可以分成两步。第一步，将一个空对象的原型设为构造函数的 <code>prototype</code>属性（上例是 <code>F.prototype</code>）；第二步，将构造函数内部的 <code>this</code>绑定这个空对象，然后执行构造函数，使得定义在 <code>this</code>上面的方法和属性（上例是 <code>this.foo</code>），都转移到这个空对象上。</p>
<h3 id="Object-create"><a href="#Object-create" class="headerlink" title="Object.create()"></a>Object.create()</h3><p>生成实例对象的常用方法是，使用 <code>new</code>命令让构造函数返回一个实例。但是很多时候，只能拿到一个实例对象，它可能根本不是由构建函数生成的，那么能不能从一个实例对象，生成另一个实例对象呢？</p>
<p>JavaScript 提供了 <code>Object.create()</code>方法，用来满足这种需求。该方法接受一个对象作为参数，然后以它为原型，返回一个实例对象。该实例完全继承原型对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 原型对象</span><br><span class="line">var A &#x3D; &#123;</span><br><span class="line">  print: function () &#123;</span><br><span class="line">    console.log(&#39;hello&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 实例对象</span><br><span class="line">var B &#x3D; Object.create(A);</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(B) &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F; true</span><br><span class="line">B.print() &#x2F;&#x2F; hello</span><br><span class="line">B.print &#x3D;&#x3D;&#x3D; A.print &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.create()</code>方法以 <code>A</code>对象为原型，生成了 <code>B</code>对象。<code>B</code>继承了 <code>A</code>的所有属性和方法。</p>
<p>实际上，<code>Object.create()</code>方法可以用下面的代码代替。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if (typeof Object.create !&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">  Object.create &#x3D; function (obj) &#123;</span><br><span class="line">    function F() &#123;&#125;</span><br><span class="line">    F.prototype &#x3D; obj;</span><br><span class="line">    return new F();</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Object.create()</code>方法的实质是新建一个空的构造函数 <code>F</code>，然后让 <code>F.prototype</code>属性指向参数对象 <code>obj</code>，最后返回一个 <code>F</code>的实例，从而实现让该实例继承 <code>obj</code>的属性。</p>
<p>下面三种方式生成的新对象是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; Object.create(&#123;&#125;);</span><br><span class="line">var obj2 &#x3D; Object.create(Object.prototype);</span><br><span class="line">var obj3 &#x3D; new Object();</span><br></pre></td></tr></table></figure>

<p>如果想要生成一个不继承任何属性（比如没有 <code>toString()</code>和 <code>valueOf()</code>方法）的对象，可以将 <code>Object.create()</code>的参数设为 <code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; Object.create(null);</span><br><span class="line"></span><br><span class="line">obj.valueOf()</span><br><span class="line">&#x2F;&#x2F; TypeError: Object [object Object] has no method &#39;valueOf&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象 <code>obj</code>的原型是 <code>null</code>，它就不具备一些定义在 <code>Object.prototype</code>对象上面的属性，比如 <code>valueOf()</code>方法。</p>
<p>使用 <code>Object.create()</code>方法的时候，必须提供对象原型，即参数不能为空，或者不是对象，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.create()</span><br><span class="line">&#x2F;&#x2F; TypeError: Object prototype may only be an Object or null</span><br><span class="line">Object.create(123)</span><br><span class="line">&#x2F;&#x2F; TypeError: Object prototype may only be an Object or null</span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code>方法生成的新对象，动态继承了原型。在原型上添加或修改任何方法，会立刻反映在新对象之上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123; p: 1 &#125;;</span><br><span class="line">var obj2 &#x3D; Object.create(obj1);</span><br><span class="line"></span><br><span class="line">obj1.p &#x3D; 2;</span><br><span class="line">obj2.p &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，修改对象原型 <code>obj1</code>会影响到实例对象 <code>obj2</code>。</p>
<p>除了对象的原型，<code>Object.create()</code>方法还可以接受第二个参数。该参数是一个属性描述对象，它所描述的对象属性，会添加到实例对象，作为该对象自身的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; Object.create(&#123;&#125;, &#123;</span><br><span class="line">  p1: &#123;</span><br><span class="line">    value: 123,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">  &#125;,</span><br><span class="line">  p2: &#123;</span><br><span class="line">    value: &#39;abc&#39;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true,</span><br><span class="line">    writable: true,</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">var obj &#x3D; Object.create(&#123;&#125;);</span><br><span class="line">obj.p1 &#x3D; 123;</span><br><span class="line">obj.p2 &#x3D; &#39;abc&#39;;</span><br></pre></td></tr></table></figure>

<p><code>Object.create()</code>方法生成的对象，继承了它的原型对象的构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">var a &#x3D; new A();</span><br><span class="line">var b &#x3D; Object.create(a);</span><br><span class="line"></span><br><span class="line">b.constructor &#x3D;&#x3D;&#x3D; A &#x2F;&#x2F; true</span><br><span class="line">b instanceof A &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>b</code>对象的原型是 <code>a</code>对象，因此继承了 <code>a</code>对象的构造函数 <code>A</code>。</p>
<h3 id="Object-prototype-isPrototypeOf"><a href="#Object-prototype-isPrototypeOf" class="headerlink" title="Object.prototype.isPrototypeOf()"></a>Object.prototype.isPrototypeOf()</h3><p>实例对象的 <code>isPrototypeOf</code>方法，用来判断该对象是否为参数对象的原型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123;&#125;;</span><br><span class="line">var o2 &#x3D; Object.create(o1);</span><br><span class="line">var o3 &#x3D; Object.create(o2);</span><br><span class="line"></span><br><span class="line">o2.isPrototypeOf(o3) &#x2F;&#x2F; true</span><br><span class="line">o1.isPrototypeOf(o3) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和 <code>o2</code>都是 <code>o3</code>的原型。这表明只要实例对象处在参数对象的原型链上，<code>isPrototypeOf</code>方法都返回 <code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Object.prototype.isPrototypeOf(&#123;&#125;) &#x2F;&#x2F; true</span><br><span class="line">Object.prototype.isPrototypeOf([]) &#x2F;&#x2F; true</span><br><span class="line">Object.prototype.isPrototypeOf(&#x2F;xyz&#x2F;) &#x2F;&#x2F; true</span><br><span class="line">Object.prototype.isPrototypeOf(Object.create(null)) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 <code>Object.prototype</code>处于原型链的最顶端，所以对各种实例都返回 <code>true</code>，只有直接继承自 <code>null</code>的对象除外。</p>
<h3 id="Object-prototype-proto"><a href="#Object-prototype-proto" class="headerlink" title="Object.prototype.proto"></a>Object.prototype.<strong>proto</strong></h3><p>实例对象的 <code>__proto__</code>属性（前后各两个下划线），返回该对象的原型。该属性可读写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">var p &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.__proto__ &#x3D; p;</span><br><span class="line">Object.getPrototypeOf(obj) &#x3D;&#x3D;&#x3D; p &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码通过 <code>__proto__</code>属性，将 <code>p</code>对象设为 <code>obj</code>对象的原型。</p>
<p>根据语言标准，<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以没有这个属性。它前后的两根下划线，表明它本质是一个内部属性，不应该对使用者暴露。因此，应该尽量少用这个属性，而是用 <code>Object.getPrototypeOf()</code>和 <code>Object.setPrototypeOf()</code>，进行原型对象的读写操作。</p>
<p>原型链可以用 <code>__proto__</code>很直观地表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var A &#x3D; &#123;</span><br><span class="line">  name: &#39;张三&#39;</span><br><span class="line">&#125;;</span><br><span class="line">var B &#x3D; &#123;</span><br><span class="line">  name: &#39;李四&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var proto &#x3D; &#123;</span><br><span class="line">  print: function () &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A.__proto__ &#x3D; proto;</span><br><span class="line">B.__proto__ &#x3D; proto;</span><br><span class="line"></span><br><span class="line">A.print() &#x2F;&#x2F; 张三</span><br><span class="line">B.print() &#x2F;&#x2F; 李四</span><br><span class="line"></span><br><span class="line">A.print &#x3D;&#x3D;&#x3D; B.print &#x2F;&#x2F; true</span><br><span class="line">A.print &#x3D;&#x3D;&#x3D; proto.print &#x2F;&#x2F; true</span><br><span class="line">B.print &#x3D;&#x3D;&#x3D; proto.print &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>A</code>对象和 <code>B</code>对象的原型都是 <code>proto</code>对象，它们都共享 <code>proto</code>对象的 <code>print</code>方法。也就是说，<code>A</code>和 <code>B</code>的 <code>print</code>方法，都是在调用 <code>proto</code>对象的 <code>print</code>方法。</p>
<h3 id="获取原型对象方法的比较"><a href="#获取原型对象方法的比较" class="headerlink" title="获取原型对象方法的比较"></a>获取原型对象方法的比较</h3><p>如前所述，<code>__proto__</code>属性指向当前对象的原型对象，即构造函数的 <code>prototype</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; new Object();</span><br><span class="line"></span><br><span class="line">obj.__proto__ &#x3D;&#x3D;&#x3D; Object.prototype</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line">obj.__proto__ &#x3D;&#x3D;&#x3D; obj.constructor.prototype</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码首先新建了一个对象 <code>obj</code>，它的 <code>__proto__</code>属性，指向构造函数（<code>Object</code>或 <code>obj.constructor</code>）的 <code>prototype</code>属性。</p>
<p>因此，获取实例对象 <code>obj</code>的原型对象，有三种方法。</p>
<ul>
<li><code>obj.__proto__</code></li>
<li><code>obj.constructor.prototype</code></li>
<li><code>Object.getPrototypeOf(obj)</code></li>
</ul>
<p>上面三种方法之中，前两种都不是很可靠。<code>__proto__</code>属性只有浏览器才需要部署，其他环境可以不部署。而 <code>obj.constructor.prototype</code>在手动改变原型对象时，可能会失效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var P &#x3D; function () &#123;&#125;;</span><br><span class="line">var p &#x3D; new P();</span><br><span class="line"></span><br><span class="line">var C &#x3D; function () &#123;&#125;;</span><br><span class="line">C.prototype &#x3D; p;</span><br><span class="line">var c &#x3D; new C();</span><br><span class="line"></span><br><span class="line">c.constructor.prototype &#x3D;&#x3D;&#x3D; p &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，构造函数 <code>C</code>的原型对象被改成了 <code>p</code>，但是实例对象的 <code>c.constructor.prototype</code>却没有指向 <code>p</code>。所以，在改变原型对象时，一般要同时设置 <code>constructor</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C.prototype &#x3D; p;</span><br><span class="line">C.prototype.constructor &#x3D; C;</span><br><span class="line"></span><br><span class="line">var c &#x3D; new C();</span><br><span class="line">c.constructor.prototype &#x3D;&#x3D;&#x3D; p &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>因此，推荐使用第三种 <code>Object.getPrototypeOf</code>方法，获取原型对象。</p>
<h3 id="Object-getOwnPropertyNames"><a href="#Object-getOwnPropertyNames" class="headerlink" title="Object.getOwnPropertyNames()"></a>Object.getOwnPropertyNames()</h3><p><code>Object.getOwnPropertyNames</code>方法返回一个数组，成员是参数对象本身的所有属性的键名，不包含继承的属性键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyNames(Date)</span><br><span class="line">&#x2F;&#x2F; [&quot;parse&quot;, &quot;arguments&quot;, &quot;UTC&quot;, &quot;caller&quot;, &quot;name&quot;, &quot;prototype&quot;, &quot;now&quot;, &quot;length&quot;]</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.getOwnPropertyNames</code>方法返回 <code>Date</code>所有自身的属性名。</p>
<p>对象本身的属性之中，有的是可以遍历的（enumerable），有的是不可以遍历的。<code>Object.getOwnPropertyNames</code>方法返回所有键名，不管是否可以遍历。只获取那些可以遍历的属性，使用 <code>Object.keys</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object.keys(Date) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date</code>对象所有自身的属性，都是不可以遍历的。</p>
<h3 id="Object-prototype-hasOwnProperty"><a href="#Object-prototype-hasOwnProperty" class="headerlink" title="Object.prototype.hasOwnProperty()"></a>Object.prototype.hasOwnProperty()</h3><p>对象实例的 <code>hasOwnProperty</code>方法返回一个布尔值，用于判断某个属性定义在对象自身，还是定义在原型链上。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Date.hasOwnProperty(&#39;length&#39;) &#x2F;&#x2F; true</span><br><span class="line">Date.hasOwnProperty(&#39;toString&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>Date.length</code>（构造函数 <code>Date</code>可以接受多少个参数）是 <code>Date</code>自身的属性，<code>Date.toString</code>是继承的属性。</p>
<p>另外，<code>hasOwnProperty</code>方法是 JavaScript 之中唯一一个处理对象属性时，不会遍历原型链的方法。</p>
<h3 id="in-运算符和-for…in-循环"><a href="#in-运算符和-for…in-循环" class="headerlink" title="in 运算符和 for…in 循环"></a>in 运算符和 for…in 循环</h3><p><code>in</code>运算符返回一个布尔值，表示一个对象是否具有某个属性。它不区分该属性是对象自身的属性，还是继承的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;length&#39; in Date &#x2F;&#x2F; true</span><br><span class="line">&#39;toString&#39; in Date &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符常用于检查一个属性是否存在。</p>
<p>获得对象的所有可遍历属性（不管是自身的还是继承的），可以使用 <code>for...in</code>循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123; p1: 123 &#125;;</span><br><span class="line"></span><br><span class="line">var o2 &#x3D; Object.create(o1, &#123;</span><br><span class="line">  p2: &#123; value: &quot;abc&quot;, enumerable: true &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">for (p in o2) &#123;</span><br><span class="line">  console.info(p);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; p2</span><br><span class="line">&#x2F;&#x2F; p1</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象 <code>o2</code>的 <code>p2</code>属性是自身的，<code>p1</code>属性是继承的。这两个属性都会被 <code>for...in</code>循环遍历。</p>
<p>为了在 <code>for...in</code>循环中获得对象自身的属性，可以采用 <code>hasOwnProperty</code>方法判断一下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for ( var name in object ) &#123;</span><br><span class="line">  if ( object.hasOwnProperty(name) ) &#123;</span><br><span class="line">    &#x2F;* loop code *&#x2F;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>获得对象的所有属性（不管是自身的还是继承的，也不管是否可枚举），可以使用下面的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function inheritedPropertyNames(obj) &#123;</span><br><span class="line">  var props &#x3D; &#123;&#125;;</span><br><span class="line">  while(obj) &#123;</span><br><span class="line">    Object.getOwnPropertyNames(obj).forEach(function(p) &#123;</span><br><span class="line">      props[p] &#x3D; true;</span><br><span class="line">    &#125;);</span><br><span class="line">    obj &#x3D; Object.getPrototypeOf(obj);</span><br><span class="line">  &#125;</span><br><span class="line">  return Object.getOwnPropertyNames(props);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码依次获取 <code>obj</code>对象的每一级原型对象“自身”的属性，从而获取 <code>obj</code>对象的“所有”属性，不管是否可遍历。</p>
<p>下面是一个例子，列出 <code>Date</code>对象的所有属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">inheritedPropertyNames(Date)</span><br><span class="line">&#x2F;&#x2F; [</span><br><span class="line">&#x2F;&#x2F;  &quot;caller&quot;,</span><br><span class="line">&#x2F;&#x2F;  &quot;constructor&quot;,</span><br><span class="line">&#x2F;&#x2F;  &quot;toString&quot;,</span><br><span class="line">&#x2F;&#x2F;  &quot;UTC&quot;,</span><br><span class="line">&#x2F;&#x2F;  ...</span><br><span class="line">&#x2F;&#x2F; ]</span><br></pre></td></tr></table></figure>

<h3 id="对象的拷贝"><a href="#对象的拷贝" class="headerlink" title="对象的拷贝"></a>对象的拷贝</h3><p>如果要拷贝一个对象，需要做到下面两件事情。</p>
<ul>
<li>确保拷贝后的对象，与原对象具有同样的原型。</li>
<li>确保拷贝后的对象，与原对象具有同样的实例属性。</li>
</ul>
<p>下面就是根据上面两点，实现的对象拷贝函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function copyObject(orig) &#123;</span><br><span class="line">  var copy &#x3D; Object.create(Object.getPrototypeOf(orig));</span><br><span class="line">  copyOwnPropertiesFrom(copy, orig);</span><br><span class="line">  return copy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function copyOwnPropertiesFrom(target, source) &#123;</span><br><span class="line">  Object</span><br><span class="line">    .getOwnPropertyNames(source)</span><br><span class="line">    .forEach(function (propKey) &#123;</span><br><span class="line">      var desc &#x3D; Object.getOwnPropertyDescriptor(source, propKey);</span><br><span class="line">      Object.defineProperty(target, propKey, desc);</span><br><span class="line">    &#125;);</span><br><span class="line">  return target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>另一种更简单的写法，是利用 ES2017 才引入标准的 <code>Object.getOwnPropertyDescriptors</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function copyObject(orig) &#123;</span><br><span class="line">  return Object.create(</span><br><span class="line">    Object.getPrototypeOf(orig),</span><br><span class="line">    Object.getOwnPropertyDescriptors(orig)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h2><h3 id="设计目的"><a href="#设计目的" class="headerlink" title="设计目的"></a>设计目的</h3><p>早期的 JavaScript 语言有很多设计不合理的地方，但是为了兼容以前的代码，又不能改变老的语法，只能不断添加新的语法，引导程序员使用新语法。</p>
<p>严格模式是从 ES5 进入标准的，主要目的有以下几个。</p>
<ul>
<li>明确禁止一些不合理、不严谨的语法，减少 JavaScript 语言的一些怪异行为。</li>
<li>增加更多报错的场合，消除代码运行的一些不安全之处，保证代码运行的安全。</li>
<li>提高编译器效率，增加运行速度。</li>
<li>为未来新版本的 JavaScript 语法做好铺垫。</li>
</ul>
<p>总之，严格模式体现了 JavaScript 更合理、更安全、更严谨的发展方向。</p>
<h3 id="启用方法"><a href="#启用方法" class="headerlink" title="启用方法"></a>启用方法</h3><p>进入严格模式的标志，是一行字符串 <code>use strict</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br></pre></td></tr></table></figure>

<p>老版本的引擎会把它当作一行普通字符串，加以忽略。新版本的引擎就会进入严格模式。</p>
<p>严格模式可以用于整个脚本，也可以只用于单个函数。</p>
<p><strong>（1） 整个脚本文件</strong></p>
<p><code>use strict</code>放在脚本文件的第一行，整个脚本都将以严格模式运行。如果这行语句不在第一行就无效，整个脚本会以正常模式运行。(严格地说，只要前面不是产生实际运行结果的语句，<code>use strict</code>可以不在第一行，比如直接跟在一个空的分号后面，或者跟在注释后面。)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  console.log(&#39;这是严格模式&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;这是正常模式&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，一个网页文件依次有两段 JavaScript 代码。前一个 <code>&lt;script&gt;</code>标签是严格模式，后一个不是。</p>
<p>如果 <code>use strict</code>写成下面这样，则不起作用，严格模式必须从代码一开始就生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  console.log(&#39;这是正常模式&#39;);</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><strong>（2）单个函数</strong></p>
<p><code>use strict</code>放在函数体的第一行，则整个函数以严格模式运行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function strict() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  return &#39;这是严格模式&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function strict2() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  function f() &#123;</span><br><span class="line">    return &#39;这也是严格模式&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">  return f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function notStrict() &#123;</span><br><span class="line">  return &#39;这是正常模式&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有时，需要把不同的脚本合并在一个文件里面。如果一个脚本是严格模式，另一个脚本不是，它们的合并就可能出错。严格模式的脚本在前，则合并后的脚本都是严格模式；如果正常模式的脚本在前，则合并后的脚本都是正常模式。这两种情况下，合并后的结果都是不正确的。这时可以考虑把整个脚本文件放在一个立即执行的匿名函数之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  &#x2F;&#x2F; some code here</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<h3 id="显式报错"><a href="#显式报错" class="headerlink" title="显式报错"></a>显式报错</h3><p>严格模式使得 JavaScript 的语法变得更严格，更多的操作会显式报错。其中有些操作，在正常模式下只会默默地失败，不会报错。</p>
<h4 id="只读属性不可写"><a href="#只读属性不可写" class="headerlink" title="只读属性不可写"></a>只读属性不可写</h4><p>严格模式下，设置字符串的 <code>length</code>属性，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">&#39;abc&#39;.length &#x3D; 5;</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot assign to read only property &#39;length&#39; of string &#39;abc&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码报错，因为 <code>length</code>是只读属性，严格模式下不可写。正常模式下，改变 <code>length</code>属性是无效的，但不会报错。</p>
<p>严格模式下，对只读属性赋值，或者删除不可配置（non-configurable）属性都会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 对只读属性赋值会报错</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line">Object.defineProperty(&#123;&#125;, &#39;a&#39;, &#123;</span><br><span class="line">  value: 37,</span><br><span class="line">  writable: false</span><br><span class="line">&#125;);</span><br><span class="line">obj.a &#x3D; 123;</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot assign to read only property &#39;a&#39; of object #&lt;Object&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 删除不可配置的属性会报错</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line">var obj &#x3D; Object.defineProperty(&#123;&#125;, &#39;p&#39;, &#123;</span><br><span class="line">  value: 1,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line">delete obj.p</span><br><span class="line">&#x2F;&#x2F; TypeError: Cannot delete property &#39;p&#39; of #&lt;Object&gt;</span><br></pre></td></tr></table></figure>

<h4 id="只设置了取值器的属性不可写"><a href="#只设置了取值器的属性不可写" class="headerlink" title="只设置了取值器的属性不可写"></a>只设置了取值器的属性不可写</h4><p>严格模式下，对一个只有取值器（getter）、没有存值器（setter）的属性赋值，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  get v() &#123; return 1; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.v &#x3D; 2;</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: Cannot set property v of #&lt;Object&gt; which has only a getter</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.v</code>只有取值器，没有存值器，对它进行赋值就会报错。</p>
<h4 id="禁止扩展的对象不可扩展"><a href="#禁止扩展的对象不可扩展" class="headerlink" title="禁止扩展的对象不可扩展"></a>禁止扩展的对象不可扩展</h4><p>严格模式下，对禁止扩展的对象添加新属性，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">Object.preventExtensions(obj);</span><br><span class="line">obj.v &#x3D; 1;</span><br><span class="line">&#x2F;&#x2F; Uncaught TypeError: Cannot add property v, object is not extensible</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj</code>对象禁止扩展，添加属性就会报错。</p>
<h4 id="eval、arguments-不可用作标识名"><a href="#eval、arguments-不可用作标识名" class="headerlink" title="eval、arguments 不可用作标识名"></a>eval、arguments 不可用作标识名</h4><p>严格模式下，使用 <code>eval</code>或者 <code>arguments</code>作为标识名，将会报错。下面的语句都会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var eval &#x3D; 17;</span><br><span class="line">var arguments &#x3D; 17;</span><br><span class="line">var obj &#x3D; &#123; set p(arguments) &#123; &#125; &#125;;</span><br><span class="line">try &#123; &#125; catch (arguments) &#123; &#125;</span><br><span class="line">function x(eval) &#123; &#125;</span><br><span class="line">function arguments() &#123; &#125;</span><br><span class="line">var y &#x3D; function eval() &#123; &#125;;</span><br><span class="line">var f &#x3D; new Function(&#39;arguments&#39;, &quot;&#39;use strict&#39;; return 17;&quot;);</span><br><span class="line">&#x2F;&#x2F; SyntaxError: Unexpected eval or arguments in strict mode</span><br></pre></td></tr></table></figure>

<h4 id="函数不能有重名的参数"><a href="#函数不能有重名的参数" class="headerlink" title="函数不能有重名的参数"></a>函数不能有重名的参数</h4><p>正常模式下，如果函数有多个重名的参数，可以用 <code>arguments[i]</code>读取。严格模式下，这属于语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a, b) &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Duplicate parameter name not allowed in this context</span><br></pre></td></tr></table></figure>

<h4 id="禁止八进制的前缀0表示法"><a href="#禁止八进制的前缀0表示法" class="headerlink" title="禁止八进制的前缀0表示法"></a>禁止八进制的前缀0表示法</h4><p>正常模式下，整数的第一位如果是 <code>0</code>，表示这是八进制数，比如 <code>0100</code>等于十进制的64。严格模式禁止这种表示法，整数第一位为 <code>0</code>，将报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var n &#x3D; 0100;</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span><br></pre></td></tr></table></figure>

<h3 id="增强的安全措施"><a href="#增强的安全措施" class="headerlink" title="增强的安全措施"></a>增强的安全措施</h3><p>严格模式增强了安全保护，从语法上防止了一些不小心会出现的错误。</p>
<h4 id="全局变量显式声明"><a href="#全局变量显式声明" class="headerlink" title="全局变量显式声明"></a>全局变量显式声明</h4><p>正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，全局变量必须显式声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line"></span><br><span class="line">v &#x3D; 1; &#x2F;&#x2F; 报错，v未声明</span><br><span class="line"></span><br><span class="line">for (i &#x3D; 0; i &lt; 2; i++) &#123; &#x2F;&#x2F; 报错，i 未声明</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  x &#x3D; 123;</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; 报错，未声明就创建一个全局变量</span><br></pre></td></tr></table></figure>

<p>因此，严格模式下，变量都必须先声明，然后再使用。</p>
<h4 id="禁止-this-关键字指向全局对象"><a href="#禁止-this-关键字指向全局对象" class="headerlink" title="禁止 this 关键字指向全局对象"></a>禁止 this 关键字指向全局对象</h4><p>正常模式下，函数内部的 <code>this</code>可能会指向全局对象，严格模式禁止这种用法，避免无意间创造全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常模式</span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; window);</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 严格模式</span><br><span class="line">function f() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  console.log(this &#x3D;&#x3D;&#x3D; undefined);</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，严格模式的函数体内部 <code>this</code>是 <code>undefined</code>。</p>
<p>这种限制对于构造函数尤其有用。使用构造函数时，有时忘了加 <code>new</code>，这时 <code>this</code>不再指向全局对象，而是报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  this.a &#x3D; 1;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f();&#x2F;&#x2F; 报错，this 未定义</span><br></pre></td></tr></table></figure>

<p>严格模式下，函数直接调用时（不使用 <code>new</code>调用），函数内部的 <code>this</code>表示 <code>undefined</code>（未定义），因此可以用 <code>call</code>、<code>apply</code>和 <code>bind</code>方法，将任意值绑定在 <code>this</code>上面。正常模式下，<code>this</code>指向全局对象，如果绑定的值是非对象，将被自动转为对象再绑定上去，而 <code>null</code>和 <code>undefined</code>这两个无法转成对象的值，将被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 正常模式</span><br><span class="line">function fun() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun() &#x2F;&#x2F; window</span><br><span class="line">fun.call(2) &#x2F;&#x2F; Number &#123;2&#125;</span><br><span class="line">fun.call(true) &#x2F;&#x2F; Boolean &#123;true&#125;</span><br><span class="line">fun.call(null) &#x2F;&#x2F; window</span><br><span class="line">fun.call(undefined) &#x2F;&#x2F; window</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 严格模式</span><br><span class="line">&#39;use strict&#39;;</span><br><span class="line">function fun() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fun() &#x2F;&#x2F;undefined</span><br><span class="line">fun.call(2) &#x2F;&#x2F; 2</span><br><span class="line">fun.call(true) &#x2F;&#x2F; true</span><br><span class="line">fun.call(null) &#x2F;&#x2F; null</span><br><span class="line">fun.call(undefined) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>上面代码中，可以把任意类型的值，绑定在 <code>this</code>上面。</p>
<h4 id="禁止使用-fn-callee、fn-caller"><a href="#禁止使用-fn-callee、fn-caller" class="headerlink" title="禁止使用 fn.callee、fn.caller"></a>禁止使用 fn.callee、fn.caller</h4><p>函数内部不得使用 <code>fn.caller</code>、<code>fn.arguments</code>，否则会报错。这意味着不能在函数内部得到调用栈了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  f1.caller;    &#x2F;&#x2F; 报错</span><br><span class="line">  f1.arguments; &#x2F;&#x2F; 报错</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br></pre></td></tr></table></figure>

<h4 id="禁止使用-arguments-callee、arguments-caller"><a href="#禁止使用-arguments-callee、arguments-caller" class="headerlink" title="禁止使用 arguments.callee、arguments.caller"></a>禁止使用 arguments.callee、arguments.caller</h4><p><code>arguments.callee</code>和 <code>arguments.caller</code>是两个历史遗留的变量，从来没有标准化过，现在已经取消了。正常模式下调用它们没有什么作用，但是不会报错。严格模式明确规定，函数内部使用 <code>arguments.callee</code>、<code>arguments.caller</code>将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  return arguments.callee;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">f(); &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<h4 id="禁止删除变量"><a href="#禁止删除变量" class="headerlink" title="禁止删除变量"></a>禁止删除变量</h4><p>严格模式下无法删除变量，如果使用 <code>delete</code>命令删除一个变量，会报错。只有对象的属性，且属性的描述对象的 <code>configurable</code>属性设置为 <code>true</code>，才能被 <code>delete</code>命令删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var x;</span><br><span class="line">delete x; &#x2F;&#x2F; 语法错误</span><br><span class="line"></span><br><span class="line">var obj &#x3D; Object.create(null, &#123;</span><br><span class="line">  x: &#123;</span><br><span class="line">    value: 1,</span><br><span class="line">    configurable: true</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">delete obj.x; &#x2F;&#x2F; 删除成功</span><br></pre></td></tr></table></figure>

<h3 id="静态绑定"><a href="#静态绑定" class="headerlink" title="静态绑定"></a>静态绑定</h3><p>JavaScript 语言的一个特点，就是允许“动态绑定”，即某些属性和方法到底属于哪一个对象，不是在编译时确定的，而是在运行时（runtime）确定的。</p>
<p>严格模式对动态绑定做了一些限制。某些情况下，只允许静态绑定。也就是说，属性和方法到底归属哪个对象，必须在编译阶段就确定。这样做有利于编译效率的提高，也使得代码更容易阅读，更少出现意外。</p>
<p>具体来说，涉及以下几个方面。</p>
<h4 id="禁止使用-with-语句"><a href="#禁止使用-with-语句" class="headerlink" title="禁止使用 with 语句"></a>禁止使用 with 语句</h4><p>严格模式下，使用 <code>with</code>语句将报错。因为 <code>with</code>语句无法在编译时就确定，某个属性到底归属哪个对象，从而影响了编译效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">var v  &#x3D; 1;</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">with (obj) &#123;</span><br><span class="line">  v &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; Uncaught SyntaxError: Strict mode code may not include a with statement</span><br></pre></td></tr></table></figure>

<h4 id="创设-eval-作用域"><a href="#创设-eval-作用域" class="headerlink" title="创设 eval 作用域"></a>创设 eval 作用域</h4><p>正常模式下，JavaScript 语言有两种变量作用域（scope）：全局作用域和函数作用域。严格模式创设了第三种作用域：<code>eval</code>作用域。</p>
<p>正常模式下，<code>eval</code>语句的作用域，取决于它处于全局作用域，还是函数作用域。严格模式下，<code>eval</code>语句本身就是一个作用域，不再能够在其所运行的作用域创设新的变量了，也就是说，<code>eval</code>所生成的变量只能用于 <code>eval</code>内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  var x &#x3D; 2;</span><br><span class="line">  console.log(eval(&#39;var x &#x3D; 5; x&#39;)) &#x2F;&#x2F; 5</span><br><span class="line">  console.log(x) &#x2F;&#x2F; 2</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于 <code>eval</code>语句内部是一个独立作用域，所以内部的变量 <code>x</code>不会泄露到外部。</p>
<p>注意，如果希望 <code>eval</code>语句也使用严格模式，有两种方式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方式一</span><br><span class="line">function f1(str)&#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  return eval(str);</span><br><span class="line">&#125;</span><br><span class="line">f1(&#39;undeclared_variable &#x3D; 1&#39;); &#x2F;&#x2F; 报错</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方式二</span><br><span class="line">function f2(str)&#123;</span><br><span class="line">  return eval(str);</span><br><span class="line">&#125;</span><br><span class="line">f2(&#39;&quot;use strict&quot;;undeclared_variable &#x3D; 1&#39;)  &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>上面两种写法，<code>eval</code>内部使用的都是严格模式。</p>
<h4 id="arguments-不再追踪参数的变化"><a href="#arguments-不再追踪参数的变化" class="headerlink" title="arguments 不再追踪参数的变化"></a>arguments 不再追踪参数的变化</h4><p>变量 <code>arguments</code>代表函数的参数。严格模式下，函数内部改变参数与 <code>arguments</code>的联系被切断了，两者不再存在联动关系。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f(a) &#123;</span><br><span class="line">  a &#x3D; 2;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">f(1); &#x2F;&#x2F; 正常模式为[2, 2]</span><br><span class="line"></span><br><span class="line">function f(a) &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  a &#x3D; 2;</span><br><span class="line">  return [a, arguments[0]];</span><br><span class="line">&#125;</span><br><span class="line">f(1); &#x2F;&#x2F; 严格模式为[2, 1]</span><br></pre></td></tr></table></figure>

<p>上面代码中，改变函数的参数，不会反应到 <code>arguments</code>对象上来。</p>
<h3 id="向下一个版本的-JavaScript-过渡"><a href="#向下一个版本的-JavaScript-过渡" class="headerlink" title="向下一个版本的 JavaScript 过渡"></a>向下一个版本的 JavaScript 过渡</h3><p>JavaScript 语言的下一个版本是 ECMAScript 6，为了平稳过渡，严格模式引入了一些 ES6 语法。</p>
<h4 id="非函数代码块不得声明函数"><a href="#非函数代码块不得声明函数" class="headerlink" title="非函数代码块不得声明函数"></a>非函数代码块不得声明函数</h4><p>ES6 会引入块级作用域。为了与新版本接轨，ES5 的严格模式只允许在全局作用域或函数作用域声明函数。也就是说，不允许在非函数的代码块内声明函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#39;use strict&#39;;</span><br><span class="line">if (true) &#123;</span><br><span class="line">  function f1() &#123; &#125; &#x2F;&#x2F; 语法错误</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; 5; i++) &#123;</span><br><span class="line">  function f2() &#123; &#125; &#x2F;&#x2F; 语法错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码在 <code>if</code>代码块和 <code>for</code>代码块中声明了函数，ES5 环境会报错。</p>
<p>注意，如果是 ES6 环境，上面的代码不会报错，因为 ES6 允许在代码块之中声明函数。</p>
<h4 id="保留字"><a href="#保留字" class="headerlink" title="保留字"></a>保留字</h4><p>为了向将来 JavaScript 的新版本过渡，严格模式新增了一些保留字（implements、interface、let、package、private、protected、public、static、yield等）。使用这些词作为变量名将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function package(protected) &#123; &#x2F;&#x2F; 语法错误</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  var implements; &#x2F;&#x2F; 语法错误</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="异步操作"><a href="#异步操作" class="headerlink" title="异步操作"></a>异步操作</h2><h3 id="单线程模型"><a href="#单线程模型" class="headerlink" title="单线程模型"></a>单线程模型</h3><p>单线程模型指的是，JavaScript 只在一个线程上运行。也就是说，JavaScript 同时只能执行一个任务，其他任务都必须在后面排队等待。</p>
<p>注意，JavaScript 只在一个线程上运行，不代表 JavaScript 引擎只有一个线程。事实上，JavaScript 引擎有多个线程，单个脚本只能在一个线程上运行（称为主线程），其他线程都是在后台配合。</p>
<p>JavaScript 之所以采用单线程，而不是多线程，跟历史有关系。JavaScript 从诞生起就是单线程，原因是不想让浏览器变得太复杂，因为多线程需要共享资源、且有可能修改彼此的运行结果，对于一种网页脚本语言来说，这就太复杂了。如果 JavaScript 同时有两个线程，一个线程在网页 DOM 节点上添加内容，另一个线程删除了这个节点，这时浏览器应该以哪个线程为准？是不是还要有锁机制？所以，为了避免复杂性，JavaScript 一开始就是单线程，这已经成了这门语言的核心特征，将来也不会改变。</p>
<p>这种模式的好处是实现起来比较简单，执行环境相对单纯；坏处是只要有一个任务耗时很长，后面的任务都必须排队等着，会拖延整个程序的执行。常见的浏览器无响应（假死），往往就是因为某一段 JavaScript 代码长时间运行（比如死循环），导致整个页面卡在这个地方，其他任务无法执行。JavaScript 语言本身并不慢，慢的是读写外部数据，比如等待 Ajax 请求返回结果。这个时候，如果对方服务器迟迟没有响应，或者网络不通畅，就会导致脚本的长时间停滞。</p>
<p>如果排队是因为计算量大，CPU 忙不过来，倒也算了，但是很多时候 CPU 是闲着的，因为 IO 操作（输入输出）很慢（比如 Ajax 操作从网络读取数据），不得不等着结果出来，再往下执行。JavaScript 语言的设计者意识到，这时 CPU 完全可以不管 IO 操作，挂起处于等待中的任务，先运行排在后面的任务。等到 IO 操作返回了结果，再回过头，把挂起的任务继续执行下去。这种机制就是 JavaScript 内部采用的“事件循环”机制（Event Loop）。</p>
<p>单线程模型虽然对 JavaScript 构成了很大的限制，但也因此使它具备了其他语言不具备的优势。如果用得好，JavaScript 程序是不会出现堵塞的，这就是 Node.js 可以用很少的资源，应付大流量访问的原因。</p>
<p>为了利用多核 CPU 的计算能力，HTML5 提出 Web Worker 标准，允许 JavaScript 脚本创建多个线程，但是子线程完全受主线程控制，且不得操作 DOM。所以，这个新标准并没有改变 JavaScript 单线程的本质。</p>
<h3 id="同步任务和异步任务"><a href="#同步任务和异步任务" class="headerlink" title="同步任务和异步任务"></a>同步任务和异步任务</h3><p>程序里面所有的任务，可以分成两类：同步任务（synchronous）和异步任务（asynchronous）。</p>
<p>同步任务是那些没有被引擎挂起、在主线程上排队执行的任务。只有前一个任务执行完毕，才能执行后一个任务。</p>
<p>异步任务是那些被引擎放在一边，不进入主线程、而进入任务队列的任务。只有引擎认为某个异步任务可以执行了（比如 Ajax 操作从服务器得到了结果），该任务（采用回调函数的形式）才会进入主线程执行。排在异步任务后面的代码，不用等待异步任务结束会马上运行，也就是说，异步任务不具有“堵塞”效应。</p>
<p>举例来说，Ajax 操作可以当作同步任务处理，也可以当作异步任务处理，由开发者决定。如果是同步任务，主线程就等着 Ajax 操作返回结果，再往下执行；如果是异步任务，主线程在发出 Ajax 请求以后，就直接往下执行，等到 Ajax 操作有了结果，主线程再执行对应的回调函数。</p>
<h3 id="任务队列和事件循环"><a href="#任务队列和事件循环" class="headerlink" title="任务队列和事件循环"></a>任务队列和事件循环</h3><p>JavaScript 运行时，除了一个正在运行的主线程，引擎还提供一个任务队列（task queue），里面是各种需要当前程序处理的异步任务。（实际上，根据异步任务的类型，存在多个任务队列。为了方便理解，这里假设只存在一个队列。）</p>
<p>首先，主线程会去执行所有的同步任务。等到同步任务全部执行完，就会去看任务队列里面的异步任务。如果满足条件，那么异步任务就重新进入主线程开始执行，这时它就变成同步任务了。等到执行完，下一个异步任务再进入主线程开始执行。一旦任务队列清空，程序就结束执行。</p>
<p>异步任务的写法通常是回调函数。一旦异步任务重新进入主线程，就会执行对应的回调函数。如果一个异步任务没有回调函数，就不会进入任务队列，也就是说，不会重新进入主线程，因为没有用回调函数指定下一步的操作。</p>
<p>JavaScript 引擎怎么知道异步任务有没有结果，能不能进入主线程呢？答案就是引擎在不停地检查，一遍又一遍，只要同步任务执行完了，引擎就会去检查那些挂起来的异步任务，是不是可以进入主线程了。这种循环检查的机制，就叫做事件循环（Event Loop）。<a href="https://en.wikipedia.org/wiki/Event_loop" target="_blank" rel="noopener">维基百科</a>的定义是：“事件循环是一个程序结构，用于等待和发送消息和事件（a programming construct that waits for and dispatches events or messages in a program）”。</p>
<h4 id="事件循环的基本原理"><a href="#事件循环的基本原理" class="headerlink" title="事件循环的基本原理"></a>事件循环的基本原理</h4><ol>
<li><strong>调用栈（Call Stack）</strong> ：调用栈是JavaScript引擎用来管理函数调用的结构。每次调用一个函数，都会把它压入栈顶，函数执行完毕后，从栈顶弹出。</li>
<li><strong>任务队列（Task Queue）</strong> ：任务队列存储待执行的异步任务（如定时器回调、网络请求回调等）。当调用栈为空时，事件循环会从任务队列中取出任务并将其压入调用栈执行。</li>
</ol>
<h4 id="事件循环的过程"><a href="#事件循环的过程" class="headerlink" title="事件循环的过程"></a>事件循环的过程</h4><ol>
<li><strong>执行同步代码</strong> ：所有同步代码都在调用栈中按顺序执行。当调用栈为空时，事件循环将继续执行下一步。</li>
<li><strong>处理微任务队列（Microtask Queue）</strong> ：微任务队列存储微任务（如 <code>Promise</code> 的回调函数、<code>MutationObserver</code> 回调等）。在每个宏任务（Macro Task）结束后，事件循环会先处理所有微任务队列中的任务。</li>
<li><strong>处理宏任务队列（Macro Task Queue）</strong> ：宏任务队列存储宏任务（如 <code>setTimeout</code> 回调、<code>setInterval</code> 回调、I&#x2F;O 操作等）。事件循环在处理完所有微任务后，会从宏任务队列中取出一个宏任务执行。</li>
</ol>
<h3 id="异步操作的模式"><a href="#异步操作的模式" class="headerlink" title="异步操作的模式"></a>异步操作的模式</h3><p>下面总结一下异步操作的几种模式。</p>
<h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p>回调函数是异步操作最基本的方法。</p>
<p>下面是两个函数 <code>f1</code>和 <code>f2</code>，编程的意图是 <code>f2</code>必须等到 <code>f1</code>执行完成，才能执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1();</span><br><span class="line">f2();</span><br></pre></td></tr></table></figure>

<p>上面代码的问题在于，如果 <code>f1</code>是异步操作，<code>f2</code>会立即执行，不会等到 <code>f1</code>结束再执行。</p>
<p>这时，可以考虑改写 <code>f1</code>，把 <code>f2</code>写成 <code>f1</code>的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1(callback) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  callback();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f2() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f1(f2);</span><br></pre></td></tr></table></figure>

<p>回调函数的优点是简单、容易理解和实现，缺点是不利于代码的阅读和维护，各个部分之间高度<a href="https://en.wikipedia.org/wiki/Coupling_(computer_programming)" target="_blank" rel="noopener">耦合</a>（coupling），使得程序结构混乱、流程难以追踪（尤其是多个回调函数嵌套的情况），而且每个任务只能指定一个回调函数。</p>
<h4 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h4><p>另一种思路是采用事件驱动模式。异步任务的执行不取决于代码的顺序，而取决于某个事件是否发生。</p>
<p>还是以 <code>f1</code>和 <code>f2</code>为例。首先，为 <code>f1</code>绑定一个事件（这里采用的 jQuery 的<a href="https://api.jquery.com/on/" target="_blank" rel="noopener">写法</a>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">f1.on(&#39;done&#39;, f2);</span><br></pre></td></tr></table></figure>

<p>上面这行代码的意思是，当 <code>f1</code>发生 <code>done</code>事件，就执行 <code>f2</code>。然后，对 <code>f1</code>进行改写：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    f1.trigger(&#39;done&#39;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f1.trigger(&#39;done&#39;)</code>表示，执行完成后，立即触发 <code>done</code>事件，从而开始执行 <code>f2</code>。</p>
<p>这种方法的优点是比较容易理解，可以绑定多个事件，每个事件可以指定多个回调函数，而且可以“<a href="https://en.wikipedia.org/wiki/Decoupling" target="_blank" rel="noopener">去耦合</a>”（decoupling），有利于实现模块化。缺点是整个程序都要变成事件驱动型，运行流程会变得很不清晰。阅读代码的时候，很难看出主流程。</p>
<h4 id="发布-x2F-订阅"><a href="#发布-x2F-订阅" class="headerlink" title="发布&#x2F;订阅"></a>发布&#x2F;订阅</h4><p>事件完全可以理解成“信号”，如果存在一个“信号中心”，某个任务执行完成，就向信号中心“发布”（publish）一个信号，其他任务可以向信号中心“订阅”（subscribe）这个信号，从而知道什么时候自己可以开始执行。这就叫做”<a href="https://en.wikipedia.org/wiki/Publish-subscribe_pattern" target="_blank" rel="noopener">发布&#x2F;订阅模式</a>”（publish-subscribe pattern），又称“<a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="noopener">观察者模式</a>”（observer pattern）。</p>
<p>这个模式有多种<a href="https://msdn.microsoft.com/en-us/magazine/hh201955.aspx" target="_blank" rel="noopener">实现</a>，下面采用的是 Ben Alman 的 <a href="https://gist.github.com/661855" target="_blank" rel="noopener">Tiny Pub&#x2F;Sub</a>，这是 jQuery 的一个插件。</p>
<p>首先，<code>f2</code>向信号中心 <code>jQuery</code>订阅 <code>done</code>信号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.subscribe(&#39;done&#39;, f2);</span><br></pre></td></tr></table></figure>

<p>然后，<code>f1</code>进行如下改写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    jQuery.publish(&#39;done&#39;);</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>jQuery.publish(&#39;done&#39;)</code>的意思是，<code>f1</code>执行完成后，向信号中心 <code>jQuery</code>发布 <code>done</code>信号，从而引发 <code>f2</code>的执行。</p>
<p><code>f2</code>完成执行后，可以取消订阅（unsubscribe）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.unsubscribe(&#39;done&#39;, f2);</span><br></pre></td></tr></table></figure>

<p>这种方法的性质与“事件监听”类似，但是明显优于后者。因为可以通过查看“消息中心”，了解存在多少信号、每个信号有多少订阅者，从而监控程序的运行。</p>
<h3 id="异步操作的流程控制"><a href="#异步操作的流程控制" class="headerlink" title="异步操作的流程控制"></a>异步操作的流程控制</h3><p>如果有多个异步操作，就存在一个流程控制的问题：如何确定异步操作执行的顺序，以及如何保证遵守这种顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function async(arg, callback) &#123;</span><br><span class="line">  console.log(&#39;参数为 &#39; + arg +&#39; , 1秒后返回结果&#39;);</span><br><span class="line">  setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的 <code>async</code>函数是一个异步任务，非常耗时，每次执行需要1秒才能完成，然后再调用回调函数。</p>
<p>如果有六个这样的异步任务，需要全部完成后，才能执行最后的 <code>final</code>函数。请问应该如何安排操作流程？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">function final(value) &#123;</span><br><span class="line">  console.log(&#39;完成: &#39;, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async(1, function (value) &#123;</span><br><span class="line">  async(2, function (value) &#123;</span><br><span class="line">    async(3, function (value) &#123;</span><br><span class="line">      async(4, function (value) &#123;</span><br><span class="line">        async(5, function (value) &#123;</span><br><span class="line">          async(6, final);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 参数为 1 , 1秒后返回结果</span><br><span class="line">&#x2F;&#x2F; 参数为 2 , 1秒后返回结果</span><br><span class="line">&#x2F;&#x2F; 参数为 3 , 1秒后返回结果</span><br><span class="line">&#x2F;&#x2F; 参数为 4 , 1秒后返回结果</span><br><span class="line">&#x2F;&#x2F; 参数为 5 , 1秒后返回结果</span><br><span class="line">&#x2F;&#x2F; 参数为 6 , 1秒后返回结果</span><br><span class="line">&#x2F;&#x2F; 完成:  12</span><br></pre></td></tr></table></figure>

<p>上面代码中，六个回调函数的嵌套，不仅写起来麻烦，容易出错，而且难以维护。</p>
<h4 id="串行执行"><a href="#串行执行" class="headerlink" title="串行执行"></a>串行执行</h4><p>我们可以编写一个流程控制函数，让它来控制异步任务，一个任务完成以后，再执行另一个。这就叫串行执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var items &#x3D; [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line">var results &#x3D; [];</span><br><span class="line"></span><br><span class="line">function async(arg, callback) &#123;</span><br><span class="line">  console.log(&#39;参数为 &#39; + arg +&#39; , 1秒后返回结果&#39;);</span><br><span class="line">  setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function final(value) &#123;</span><br><span class="line">  console.log(&#39;完成: &#39;, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function series(item) &#123;</span><br><span class="line">  if(item) &#123;</span><br><span class="line">    async( item, function(result) &#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      return series(items.shift());</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return final(results[results.length - 1]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">series(items.shift());</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数 <code>series</code>就是串行函数，它会依次执行异步任务，所有任务都完成后，才会执行 <code>final</code>函数。<code>items</code>数组保存每一个异步任务的参数，<code>results</code>数组保存每一个异步任务的运行结果。</p>
<p>注意，上面的写法需要六秒，才能完成整个脚本。</p>
<h4 id="并行执行"><a href="#并行执行" class="headerlink" title="并行执行"></a>并行执行</h4><p>流程控制函数也可以是并行执行，即所有异步任务同时执行，等到全部完成以后，才执行 <code>final</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var items &#x3D; [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line">var results &#x3D; [];</span><br><span class="line"></span><br><span class="line">function async(arg, callback) &#123;</span><br><span class="line">  console.log(&#39;参数为 &#39; + arg +&#39; , 1秒后返回结果&#39;);</span><br><span class="line">  setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function final(value) &#123;</span><br><span class="line">  console.log(&#39;完成: &#39;, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">items.forEach(function(item) &#123;</span><br><span class="line">  async(item, function(result)&#123;</span><br><span class="line">    results.push(result);</span><br><span class="line">    if(results.length &#x3D;&#x3D;&#x3D; items.length) &#123;</span><br><span class="line">      final(results[results.length - 1]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>forEach</code>方法会同时发起六个异步任务，等到它们全部完成以后，才会执行 <code>final</code>函数。</p>
<p>相比而言，上面的写法只要一秒，就能完成整个脚本。这就是说，并行执行的效率较高，比起串行执行一次只能执行一个任务，较为节约时间。但是问题在于如果并行的任务较多，很容易耗尽系统资源，拖慢运行速度。因此有了第三种流程控制方式。</p>
<h4 id="并行与串行的结合"><a href="#并行与串行的结合" class="headerlink" title="并行与串行的结合"></a>并行与串行的结合</h4><p>所谓并行与串行的结合，就是设置一个门槛，每次最多只能并行执行 <code>n</code>个异步任务，这样就避免了过分占用系统资源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">var items &#x3D; [ 1, 2, 3, 4, 5, 6 ];</span><br><span class="line">var results &#x3D; [];</span><br><span class="line">var running &#x3D; 0;</span><br><span class="line">var limit &#x3D; 2;</span><br><span class="line"></span><br><span class="line">function async(arg, callback) &#123;</span><br><span class="line">  console.log(&#39;参数为 &#39; + arg +&#39; , 1秒后返回结果&#39;);</span><br><span class="line">  setTimeout(function () &#123; callback(arg * 2); &#125;, 1000);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function final(value) &#123;</span><br><span class="line">  console.log(&#39;完成: &#39;, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function launcher() &#123;</span><br><span class="line">  while(running &lt; limit &amp;&amp; items.length &gt; 0) &#123;</span><br><span class="line">    var item &#x3D; items.shift();</span><br><span class="line">    async(item, function(result) &#123;</span><br><span class="line">      results.push(result);</span><br><span class="line">      running--;</span><br><span class="line">      if(items.length &gt; 0) &#123;</span><br><span class="line">        launcher();</span><br><span class="line">      &#125; else if(running &#x3D;&#x3D; 0) &#123;</span><br><span class="line">        final(results);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    running++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">launcher();</span><br></pre></td></tr></table></figure>

<p>上面代码中，最多只能同时运行两个异步任务。变量 <code>running</code>记录当前正在运行的任务数，只要低于门槛值，就再启动一个新的任务，如果等于 <code>0</code>，就表示所有任务都执行完了，这时就执行 <code>final</code>函数。</p>
<p>这段代码需要三秒完成整个脚本，处在串行执行和并行执行之间。通过调节 <code>limit</code>变量，达到效率和资源的最佳平衡。</p>
<h2 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h2><p>JavaScript 提供定时执行代码的功能，叫做定时器（timer），主要由setTimeout()和setInterval()这两个函数来完成。它们向任务队列添加定时任务。</p>
<h3 id="setTimeout"><a href="#setTimeout" class="headerlink" title="setTimeout()"></a>setTimeout()</h3><p><code>setTimeout</code>函数用来指定某个函数或某段代码，在多少毫秒之后执行。它返回一个整数，表示定时器的编号，以后可以用来取消这个定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var timerId &#x3D; setTimeout(func|code, delay);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout</code>函数接受两个参数，第一个参数 <code>func|code</code>是将要推迟执行的函数名或者一段代码，第二个参数 <code>delay</code>是推迟执行的毫秒数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">console.log(1);</span><br><span class="line">setTimeout(&#39;console.log(2)&#39;,1000);</span><br><span class="line">console.log(3);</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码会先输出1和3，然后等待1000毫秒再输出2。注意，<code>console.log(2)</code>必须以字符串的形式，作为 <code>setTimeout</code>的参数。</p>
<p>如果推迟执行的是函数，就直接将函数名，作为 <code>setTimeout</code>的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setTimeout(f, 1000);</span><br></pre></td></tr></table></figure>

<p><code>setTimeout</code>的第二个参数如果省略，则默认为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(f)</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">setTimeout(f, 0)</span><br></pre></td></tr></table></figure>

<p>除了前两个参数，<code>setTimeout</code>还允许更多的参数。它们将依次传入推迟执行的函数（回调函数）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function (a,b) &#123;</span><br><span class="line">  console.log(a + b);</span><br><span class="line">&#125;, 1000, 1, 1);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setTimeout</code>共有4个参数。最后那两个参数，将在1000毫秒之后回调函数执行时，作为回调函数的参数。</p>
<p>还有一个需要注意的地方，如果回调函数是对象的方法，那么 <code>setTimeout</code>使得方法内部的 <code>this</code>关键字指向全局环境，而不是定义时所在的那个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  x: 2,</span><br><span class="line">  y: function () &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(obj.y, 1000) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码输出的是1，而不是2。因为当 <code>obj.y</code>在1000毫秒后运行时，<code>this</code>所指向的已经不是 <code>obj</code>了，而是全局环境。</p>
<p>为了防止出现这个问题，一种解决方法是将 <code>obj.y</code>放入一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  x: 2,</span><br><span class="line">  y: function () &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  obj.y();</span><br><span class="line">&#125;, 1000);</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>obj.y</code>放在一个匿名函数之中，这使得 <code>obj.y</code>在 <code>obj</code>的作用域执行，而不是在全局作用域内执行，所以能够显示正确的值。</p>
<p>另一种解决方法是，使用 <code>bind</code>方法，将 <code>obj.y</code>这个方法绑定在 <code>obj</code>上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  x: 2,</span><br><span class="line">  y: function () &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">setTimeout(obj.y.bind(obj), 1000)</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h3 id="setInterval"><a href="#setInterval" class="headerlink" title="setInterval()"></a>setInterval()</h3><p><code>setInterval</code>函数的用法与 <code>setTimeout</code>完全一致，区别仅仅在于 <code>setInterval</code>指定某个任务每隔一段时间就执行一次，也就是无限次的定时执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var i &#x3D; 1</span><br><span class="line">var timer &#x3D; setInterval(function() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;, 1000)</span><br></pre></td></tr></table></figure>

<p>上面代码中，每隔1000毫秒就输出一个2，会无限运行下去，直到关闭当前窗口。</p>
<p>与 <code>setTimeout</code>一样，除了前两个参数，<code>setInterval</code>方法还可以接受更多的参数，它们会传入回调函数。</p>
<p>下面是一个通过 <code>setInterval</code>方法实现网页动画的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;someDiv&#39;);</span><br><span class="line">var opacity &#x3D; 1;</span><br><span class="line">var fader &#x3D; setInterval(function() &#123;</span><br><span class="line">  opacity -&#x3D; 0.1;</span><br><span class="line">  if (opacity &gt;&#x3D; 0) &#123;</span><br><span class="line">    div.style.opacity &#x3D; opacity;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    clearInterval(fader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 100);</span><br></pre></td></tr></table></figure>

<p>上面代码每隔100毫秒，设置一次 <code>div</code>元素的透明度，直至其完全透明为止。</p>
<p><code>setInterval</code>的一个常见用途是实现轮询。下面是一个轮询 URL 的 Hash 值是否发生变化的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var hash &#x3D; window.location.hash;</span><br><span class="line">var hashWatcher &#x3D; setInterval(function() &#123;</span><br><span class="line">  if (window.location.hash !&#x3D; hash) &#123;</span><br><span class="line">    updatePage();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p><code>setInterval</code>指定的是“开始执行”之间的间隔，并不考虑每次任务执行本身所消耗的时间。因此实际上，两次执行之间的间隔会小于指定的时间。比如，<code>setInterval</code>指定每 100ms 执行一次，每次执行需要 5ms，那么第一次执行结束后95毫秒，第二次执行就会开始。如果某次执行耗时特别长，比如需要105毫秒，那么它结束后，下一次执行就会立即开始。</p>
<p>为了确保两次执行之间有固定的间隔，可以不用 <code>setInterval</code>，而是每次执行结束后，使用 <code>setTimeout</code>指定下一次执行的具体时间。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var i &#x3D; 1;</span><br><span class="line">var timer &#x3D; setTimeout(function f() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">  timer &#x3D; setTimeout(f, 2000);</span><br><span class="line">&#125;, 2000);</span><br></pre></td></tr></table></figure>

<p>上面代码可以确保，下一次执行总是在本次执行结束之后的2000毫秒开始。</p>
<h3 id="clearTimeout-，clearInterval"><a href="#clearTimeout-，clearInterval" class="headerlink" title="clearTimeout()，clearInterval()"></a>clearTimeout()，clearInterval()</h3><p><code>setTimeout</code>和 <code>setInterval</code>函数，都返回一个整数值，表示计数器编号。将该整数传入 <code>clearTimeout</code>和 <code>clearInterval</code>函数，就可以取消对应的定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var id1 &#x3D; setTimeout(f, 1000);</span><br><span class="line">var id2 &#x3D; setInterval(f, 1000);</span><br><span class="line"></span><br><span class="line">clearTimeout(id1);</span><br><span class="line">clearInterval(id2);</span><br></pre></td></tr></table></figure>

<p>上面代码中，回调函数 <code>f</code>不会再执行了，因为两个定时器都被取消了。</p>
<p><code>setTimeout</code>和 <code>setInterval</code>返回的整数值是连续的，也就是说，第二个 <code>setTimeout</code>方法返回的整数值，将比第一个的整数值大1。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">setTimeout(f, 1000) &#x2F;&#x2F; 10</span><br><span class="line">setTimeout(f, 1000) &#x2F;&#x2F; 11</span><br><span class="line">setTimeout(f, 1000) &#x2F;&#x2F; 12</span><br></pre></td></tr></table></figure>

<p>上面代码中，连续调用三次 <code>setTimeout</code>，返回值都比上一次大了1。</p>
<p>利用这一点，可以写一个函数，取消当前所有的 <code>setTimeout</code>定时器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(function() &#123;</span><br><span class="line">  &#x2F;&#x2F; 每轮事件循环检查一次</span><br><span class="line">  var gid &#x3D; setInterval(clearAllTimeouts, 0);</span><br><span class="line"></span><br><span class="line">  function clearAllTimeouts() &#123;</span><br><span class="line">    var id &#x3D; setTimeout(function() &#123;&#125;, 0);</span><br><span class="line">    while (id &gt; 0) &#123;</span><br><span class="line">      if (id !&#x3D;&#x3D; gid) &#123;</span><br><span class="line">        clearTimeout(id);</span><br><span class="line">      &#125;</span><br><span class="line">      id--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>上面代码中，先调用 <code>setTimeout</code>，得到一个计算器编号，然后把编号比它小的计数器全部取消。</p>
<h3 id="实例：debounce-函数"><a href="#实例：debounce-函数" class="headerlink" title="实例：debounce 函数"></a>实例：debounce 函数</h3><p>有时，我们不希望回调函数被频繁调用。比如，用户填入网页输入框的内容，希望通过 Ajax 方法传回服务器，jQuery 的写法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;textarea&#39;).on(&#39;keydown&#39;, ajaxAction);</span><br></pre></td></tr></table></figure>

<p>这样写有一个很大的缺点，就是如果用户连续击键，就会连续触发 <code>keydown</code>事件，造成大量的 Ajax 通信。这是不必要的，而且很可能产生性能问题。正确的做法应该是，设置一个门槛值，表示两次 Ajax 通信的最小间隔时间。如果在间隔时间内，发生新的 <code>keydown</code>事件，则不触发 Ajax 通信，并且重新开始计时。如果过了指定时间，没有发生新的 <code>keydown</code>事件，再将数据发送出去。</p>
<p>这种做法叫做 debounce（防抖动）。假定两次 Ajax 通信的间隔不得小于2500毫秒，上面的代码可以改写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(&#39;textarea&#39;).on(&#39;keydown&#39;, debounce(ajaxAction, 2500));</span><br><span class="line"></span><br><span class="line">function debounce(fn, delay)&#123;</span><br><span class="line">  var timer &#x3D; null; &#x2F;&#x2F; 声明计时器</span><br><span class="line">  return function() &#123;</span><br><span class="line">    var context &#x3D; this;</span><br><span class="line">    var args &#x3D; arguments;</span><br><span class="line">    clearTimeout(timer);</span><br><span class="line">    timer &#x3D; setTimeout(function () &#123;</span><br><span class="line">      fn.apply(context, args);</span><br><span class="line">    &#125;, delay);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只要在2500毫秒之内，用户再次击键，就会取消上一次的定时器，然后再新建一个定时器。这样就保证了回调函数之间的调用间隔，至少是2500毫秒。</p>
<h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p><code>setTimeout</code>和 <code>setInterval</code>的运行机制，是将指定的代码移出本轮事件循环，等到下一轮事件循环，再检查是否到了指定时间。如果到了，就执行对应的代码；如果不到，就继续等待。</p>
<p>这意味着，<code>setTimeout</code>和 <code>setInterval</code>指定的回调函数，必须等到本轮事件循环的所有同步任务都执行完，才会开始执行。由于前面的任务到底需要多少时间执行完，是不确定的，所以没有办法保证，<code>setTimeout</code>和 <code>setInterval</code>指定的任务，一定会按照预定时间执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(someTask, 100);</span><br><span class="line">veryLongTask();</span><br></pre></td></tr></table></figure>

<p>上面代码的 <code>setTimeout</code>，指定100毫秒以后运行一个任务。但是，如果后面的 <code>veryLongTask</code>函数（同步任务）运行时间非常长，过了100毫秒还无法结束，那么被推迟运行的 <code>someTask</code>就只有等着，等到 <code>veryLongTask</code>运行结束，才轮到它执行。</p>
<p>再看一个 <code>setInterval</code>的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">setInterval(function () &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;, 1000);</span><br><span class="line"></span><br><span class="line">sleep(3000);</span><br><span class="line"></span><br><span class="line">function sleep(ms) &#123;</span><br><span class="line">  var start &#x3D; Date.now();</span><br><span class="line">  while ((Date.now() - start) &lt; ms) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setInterval</code>要求每隔1000毫秒，就输出一个2。但是，紧接着的 <code>sleep</code>语句需要3000毫秒才能完成，那么 <code>setInterval</code>就必须推迟到3000毫秒之后才开始生效。注意，生效后 <code>setInterval</code>不会产生累积效应，即不会一下子输出三个2，而是只会输出一个2。</p>
<h3 id="setTimeout-f-0"><a href="#setTimeout-f-0" class="headerlink" title="setTimeout(f, 0)"></a>setTimeout(f, 0)</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p><code>setTimeout</code>的作用是将代码推迟到指定时间执行，如果指定时间为 <code>0</code>，即 <code>setTimeout(f, 0)</code>，那么会立刻执行吗？</p>
<p>答案是不会。因为上一节说过，必须要等到当前脚本的同步任务，全部处理完以后，才会执行 <code>setTimeout</code>指定的回调函数 <code>f</code>。也就是说，<code>setTimeout(f, 0)</code>会在下一轮事件循环一开始就执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line">console.log(2);</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码先输出 <code>2</code>，再输出 <code>1</code>。因为 <code>2</code>是同步任务，在本轮事件循环执行，而 <code>1</code>是下一轮事件循环执行。</p>
<p>总之，<code>setTimeout(f, 0)</code>这种写法的目的是，尽可能早地执行 <code>f</code>，但是并不能保证立刻就执行 <code>f</code>。</p>
<p>实际上，<code>setTimeout(f, 0)</code>不会真的在0毫秒之后运行，不同的浏览器有不同的实现。以 Edge 浏览器为例，会等到4毫秒之后运行。如果电脑正在使用电池供电，会等到16毫秒之后运行；如果网页不在当前 Tab 页，会推迟到1000毫秒（1秒）之后运行。这样是为了节省系统资源。</p>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p><code>setTimeout(f, 0)</code>有几个非常重要的用途。它的一大应用是，可以调整事件的发生顺序。比如，网页开发中，某个事件先发生在子元素，然后冒泡到父元素，即子元素的事件回调函数，会早于父元素的事件回调函数触发。如果，想让父元素的事件回调函数先发生，就要用到 <code>setTimeout(f, 0)</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;myButton&quot; value&#x3D;&quot;click&quot;&gt;</span><br><span class="line"></span><br><span class="line">var input &#x3D; document.getElementById(&#39;myButton&#39;);</span><br><span class="line"></span><br><span class="line">input.onclick &#x3D; function A() &#123;</span><br><span class="line">  setTimeout(function B() &#123;</span><br><span class="line">    input.value +&#x3D;&#39; input&#39;;</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">document.body.onclick &#x3D; function C() &#123;</span><br><span class="line">  input.value +&#x3D; &#39; body&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码在点击按钮后，先触发回调函数 <code>A</code>，然后触发函数 <code>C</code>。函数 <code>A</code>中，<code>setTimeout</code>将函数 <code>B</code>推迟到下一轮事件循环执行，这样就起到了，先触发父元素的回调函数 <code>C</code>的目的了。</p>
<p>另一个应用是，用户自定义的回调函数，通常在浏览器的默认动作之前触发。比如，用户在输入框输入文本，<code>keypress</code>事件会在浏览器接收文本之前触发。因此，下面的回调函数是达不到目的的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;input-box&quot;&gt;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;input-box&#39;).onkeypress &#x3D; function (event) &#123;</span><br><span class="line">  this.value &#x3D; this.value.toUpperCase();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码想在用户每次输入文本后，立即将字符转为大写。但是实际上，它只能将本次输入前的字符转为大写，因为浏览器此时还没接收到新的文本，所以 <code>this.value</code>取不到最新输入的那个字符。只有用 <code>setTimeout</code>改写，上面的代码才能发挥作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;input-box&#39;).onkeypress &#x3D; function() &#123;</span><br><span class="line">  var self &#x3D; this;</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    self.value &#x3D; self.value.toUpperCase();</span><br><span class="line">  &#125;, 0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码将代码放入 <code>setTimeout</code>之中，就能使得它在浏览器接收到文本之后触发。</p>
<p>由于 <code>setTimeout(f, 0)</code>实际上意味着，将任务放到浏览器最早可得的空闲时段执行，所以那些计算量大、耗时长的任务，常常会被放到几个小部分，分别放到 <code>setTimeout(f, 0)</code>里面执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementsByTagName(&#39;div&#39;)[0];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">for (var i &#x3D; 0xA00000; i &lt; 0xFFFFFF; i++) &#123;</span><br><span class="line">  div.style.backgroundColor &#x3D; &#39;#&#39; + i.toString(16);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">var timer;</span><br><span class="line">var i&#x3D;0x100000;</span><br><span class="line"></span><br><span class="line">function func() &#123;</span><br><span class="line">  timer &#x3D; setTimeout(func, 0);</span><br><span class="line">  div.style.backgroundColor &#x3D; &#39;#&#39; + i.toString(16);</span><br><span class="line">  if (i++ &#x3D;&#x3D; 0xFFFFFF) clearTimeout(timer);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timer &#x3D; setTimeout(func, 0);</span><br></pre></td></tr></table></figure>

<p>上面代码有两种写法，都是改变一个网页元素的背景色。写法一会造成浏览器“堵塞”，因为 JavaScript 执行速度远高于 DOM，会造成大量 DOM 操作“堆积”，而写法二就不会，这就是 <code>setTimeout(f, 0)</code>的好处。</p>
<p>另一个使用这种技巧的例子是代码高亮的处理。如果代码块很大，一次性处理，可能会对性能造成很大的压力，那么将其分成一个个小块，一次处理一块，比如写成 <code>setTimeout(highlightNext, 50)</code>的样子，性能压力就会减轻。</p>
<h2 id="Promise-对象"><a href="#Promise-对象" class="headerlink" title="Promise 对象"></a>Promise 对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>Promise 对象是 JavaScript 的异步操作解决方案，为异步操作提供统一接口。它起到代理作用（proxy），充当异步操作与回调函数之间的中介，使得异步操作具备同步操作的接口。Promise 可以让异步操作写起来，就像在写同步操作的流程，而不必一层层地嵌套回调函数。<br>首先，Promise 是一个对象，也是一个构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f1(resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; 异步代码...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; new Promise(f1);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise</code>构造函数接受一个回调函数 <code>f1</code>作为参数，<code>f1</code>里面是异步操作的代码。然后，返回的 <code>p1</code>就是一个 Promise 实例。</p>
<p>Promise 的设计思想是，所有异步任务都返回一个 Promise 实例。Promise 实例有一个 <code>then</code>方法，用来指定下一步的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(f1);</span><br><span class="line">p1.then(f2);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f1</code>的异步操作执行完成，就会执行 <code>f2</code>。</p>
<p>传统的写法可能需要把 <code>f2</code>作为回调函数传入 <code>f1</code>，比如写成 <code>f1(f2)</code>，异步操作完成后，在 <code>f1</code>内部调用 <code>f2</code>。Promise 使得 <code>f1</code>和 <code>f2</code>变成了链式写法。不仅改善了可读性，而且对于多层嵌套的回调函数尤其方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 传统写法</span><br><span class="line">step1(function (value1) &#123;</span><br><span class="line">  step2(value1, function(value2) &#123;</span><br><span class="line">    step3(value2, function(value3) &#123;</span><br><span class="line">      step4(value3, function(value4) &#123;</span><br><span class="line">        &#x2F;&#x2F; ...</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Promise 的写法</span><br><span class="line">(new Promise(step1))</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(step4);</span><br></pre></td></tr></table></figure>

<p>从上面代码可以看到，采用 Promises 以后，程序流程变得非常清楚，十分易读。注意，为了便于理解，上面代码的 <code>Promise</code>实例的生成格式，做了简化，真正的语法请参照下文。</p>
<p>总的来说，传统的回调函数写法使得代码混成一团，变得横向发展而不是向下发展。Promise 就是解决这个问题，使得异步流程可以写成同步流程。</p>
<p>Promise 原本只是社区提出的一个构想，一些函数库率先实现了这个功能。ECMAScript 6 将其写入语言标准，目前 JavaScript 原生支持 Promise 对象。</p>
<h3 id="Promise-对象的状态"><a href="#Promise-对象的状态" class="headerlink" title="Promise 对象的状态"></a>Promise 对象的状态</h3><p>Promise 对象通过自身的状态，来控制异步操作。Promise 实例具有三种状态。</p>
<ul>
<li>异步操作未完成（pending）</li>
<li>异步操作成功（fulfilled）</li>
<li>异步操作失败（rejected）</li>
</ul>
<p>上面三种状态里面，<code>fulfilled</code>和 <code>rejected</code>合在一起称为 <code>resolved</code>（已定型）。</p>
<p>这三种的状态的变化途径只有两种。</p>
<ul>
<li>从“未完成”到“成功”</li>
<li>从“未完成”到“失败”</li>
</ul>
<p>一旦状态发生变化，就凝固了，不会再有新的状态变化。这也是 Promise 这个名字的由来，它的英语意思是“承诺”，一旦承诺成效，就不得再改变了。这也意味着，Promise 实例的状态变化只可能发生一次。</p>
<p>因此，Promise 的最终结果只有两种。</p>
<ul>
<li>异步操作成功，Promise 实例传回一个值（value），状态变为 <code>fulfilled</code>。</li>
<li>异步操作失败，Promise 实例抛出一个错误（error），状态变为 <code>rejected</code>。</li>
</ul>
<h3 id="Promise-构造函数"><a href="#Promise-构造函数" class="headerlink" title="Promise 构造函数"></a>Promise 构造函数</h3><p>JavaScript 提供原生的 <code>Promise</code>构造函数，用来生成 Promise 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var promise &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line"></span><br><span class="line">  if (&#x2F;* 异步操作成功 *&#x2F;)&#123;</span><br><span class="line">    resolve(value);</span><br><span class="line">  &#125; else &#123; &#x2F;* 异步操作失败 *&#x2F;</span><br><span class="line">    reject(new Error());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Promise</code>构造函数接受一个函数作为参数，该函数的两个参数分别是 <code>resolve</code>和 <code>reject</code>。它们是两个函数，由 JavaScript 引擎提供，不用自己实现。</p>
<p><code>resolve</code>函数的作用是，将 <code>Promise</code>实例的状态从“未完成”变为“成功”（即从 <code>pending</code>变为 <code>fulfilled</code>），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去。<code>reject</code>函数的作用是，将 <code>Promise</code>实例的状态从“未完成”变为“失败”（即从 <code>pending</code>变为 <code>rejected</code>），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function timeout(ms) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(resolve, ms, &#39;done&#39;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">timeout(100)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>timeout(100)</code>返回一个 Promise 实例。100毫秒以后，该实例的状态会变为 <code>fulfilled</code>。</p>
<h3 id="Promise-prototype-then"><a href="#Promise-prototype-then" class="headerlink" title="Promise.prototype.then()"></a>Promise.prototype.then()</h3><p>Promise 实例的 <code>then</code>方法，用来添加回调函数。</p>
<p><code>then</code>方法可以接受两个回调函数，第一个是异步操作成功时（变为 <code>fulfilled</code>状态）的回调函数，第二个是异步操作失败（变为 <code>rejected</code>）时的回调函数（该参数可以省略）。一旦状态改变，就调用相应的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var p1 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(&#39;成功&#39;);</span><br><span class="line">&#125;);</span><br><span class="line">p1.then(console.log, console.error);</span><br><span class="line">&#x2F;&#x2F; &quot;成功&quot;</span><br><span class="line"></span><br><span class="line">var p2 &#x3D; new Promise(function (resolve, reject) &#123;</span><br><span class="line">  reject(new Error(&#39;失败&#39;));</span><br><span class="line">&#125;);</span><br><span class="line">p2.then(console.log, console.error);</span><br><span class="line">&#x2F;&#x2F; Error: 失败</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>和 <code>p2</code>都是Promise 实例，它们的 <code>then</code>方法绑定两个回调函数：成功时的回调函数 <code>console.log</code>，失败时的回调函数 <code>console.error</code>（可以省略）。<code>p1</code>的状态变为成功，<code>p2</code>的状态变为失败，对应的回调函数会收到异步操作传回的值，然后在控制台输出。</p>
<p><code>then</code>方法可以链式使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">p1</span><br><span class="line">  .then(step1)</span><br><span class="line">  .then(step2)</span><br><span class="line">  .then(step3)</span><br><span class="line">  .then(</span><br><span class="line">    console.log,</span><br><span class="line">    console.error</span><br><span class="line">  );</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>p1</code>后面有四个 <code>then</code>，意味依次有四个回调函数。只要前一步的状态变为 <code>fulfilled</code>，就会依次执行紧跟在后面的回调函数。</p>
<p>最后一个 <code>then</code>方法，回调函数是 <code>console.log</code>和 <code>console.error</code>，用法上有一点重要的区别。<code>console.log</code>只显示 <code>step3</code>的返回值，而 <code>console.error</code>可以显示 <code>p1</code>、<code>step1</code>、<code>step2</code>、<code>step3</code>之中任意一个发生的错误。举例来说，如果 <code>step1</code>的状态变为 <code>rejected</code>，那么 <code>step2</code>和 <code>step3</code>都不会执行了（因为它们是 <code>resolved</code>的回调函数）。Promise 开始寻找，接下来第一个为 <code>rejected</code>的回调函数，在上面代码中是 <code>console.error</code>。这就是说，Promise 对象的报错具有传递性。</p>
<h3 id="then-用法辨析"><a href="#then-用法辨析" class="headerlink" title="then() 用法辨析"></a>then() 用法辨析</h3><p>Promise 的用法，简单说就是一句话：使用 <code>then</code>方法添加回调函数。但是，不同的写法有一些细微的差别，请看下面四种写法，它们的差别在哪里？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">f1().then(function () &#123;</span><br><span class="line">  return f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">f1().then(function () &#123;</span><br><span class="line">  f2();</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法三</span><br><span class="line">f1().then(f2());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法四</span><br><span class="line">f1().then(f2);</span><br></pre></td></tr></table></figure>

<p>为了便于讲解，下面这四种写法都再用 <code>then</code>方法接一个回调函数 <code>f3</code>。写法一的 <code>f3</code>回调函数的参数，是 <code>f2</code>函数的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f1().then(function () &#123;</span><br><span class="line">  return f2();</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>

<p>写法二的 <code>f3</code>回调函数的参数是 <code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1().then(function () &#123;</span><br><span class="line">  f2();</span><br><span class="line">  return;</span><br><span class="line">&#125;).then(f3);</span><br></pre></td></tr></table></figure>

<p>写法三的 <code>f3</code>回调函数的参数，是 <code>f2</code>函数返回的函数的运行结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().then(f2())</span><br><span class="line">  .then(f3);</span><br></pre></td></tr></table></figure>

<p>写法四与写法一只有一个差别，那就是 <code>f2</code>会接收到 <code>f1()</code>返回的结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f1().then(f2)</span><br><span class="line">  .then(f3);</span><br></pre></td></tr></table></figure>

<h3 id="实例：图片加载"><a href="#实例：图片加载" class="headerlink" title="实例：图片加载"></a>实例：图片加载</h3><p>下面是使用 Promise 完成图片的加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var preloadImage &#x3D; function (path) &#123;</span><br><span class="line">  return new Promise(function (resolve, reject) &#123;</span><br><span class="line">    var image &#x3D; new Image();</span><br><span class="line">    image.onload  &#x3D; resolve;</span><br><span class="line">    image.onerror &#x3D; reject;</span><br><span class="line">    image.src &#x3D; path;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>image</code>是一个图片对象的实例。它有两个事件监听属性，<code>onload</code>属性在图片加载成功后调用，<code>onerror</code>属性在加载失败调用。</p>
<p>上面的 <code>preloadImage()</code>函数用法如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">preloadImage(&#39;https:&#x2F;&#x2F;example.com&#x2F;my.jpg&#39;)</span><br><span class="line">  .then(function (e) &#123; document.body.append(e.target) &#125;)</span><br><span class="line">  .then(function () &#123; console.log(&#39;加载成功&#39;) &#125;)</span><br></pre></td></tr></table></figure>

<p>上面代码中，图片加载成功以后，<code>onload</code>属性会返回一个事件对象，因此第一个 <code>then()</code>方法的回调函数，会接收到这个事件对象。该对象的 <code>target</code>属性就是图片加载后生成的 DOM 节点。</p>
<h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>Promise 的优点在于，让回调函数变成了规范的链式写法，程序流程可以看得很清楚。它有一整套接口，可以实现许多强大的功能，比如同时执行多个异步操作，等到它们的状态都改变以后，再执行一个回调函数；再比如，为多个回调函数中抛出的错误，统一指定处理方法等等。</p>
<p>而且，Promise 还有一个传统写法没有的好处：它的状态一旦改变，无论何时查询，都能得到这个状态。这意味着，无论何时为 Promise 实例添加回调函数，该函数都能正确执行。所以，你不用担心是否错过了某个事件或信号。如果是传统写法，通过监听事件来执行回调函数，一旦错过了事件，再添加回调函数是不会执行的。</p>
<p>Promise 的缺点是，编写的难度比传统写法高，而且阅读代码也不是一眼可以看懂。你只会看到一堆 <code>then</code>，必须自己在 <code>then</code>的回调函数里面理清逻辑。</p>
<h3 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h3><p>Promise 的回调函数属于异步任务，会在同步任务之后执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(1);</span><br><span class="line">&#125;).then(console.log);</span><br><span class="line"></span><br><span class="line">console.log(2);</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码会先输出2，再输出1。因为 <code>console.log(2)</code>是同步任务，而 <code>then</code>的回调函数属于异步任务，一定晚于同步任务执行。</p>
<p>但是，Promise 的回调函数不是正常的异步任务，而是微任务（microtask）。它们的区别在于，正常任务追加到下一轮事件循环，微任务追加到本轮事件循环。这意味着，微任务的执行时间一定早于正常任务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">  resolve(2);</span><br><span class="line">&#125;).then(console.log);</span><br><span class="line"></span><br><span class="line">console.log(3);</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码的输出结果是 <code>321</code>。这说明 <code>then</code>的回调函数的执行时间，早于 <code>setTimeout(fn, 0)</code>。因为 <code>then</code>是本轮事件循环执行，<code>setTimeout(fn, 0)</code>在下一轮事件循环开始时执行。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">PanXiaoKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/09/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">http://example.com/2021/09/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">向阳榆木</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a><a class="post-meta__tags" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/">面向对象编程</a></div><div class="post_share"><div class="social-share" data-image="https://mpimg.cn/view.php/58dfeb8921e8fb4a93de3dae7d99a816.jpg" data-sites="qq,wechat,facebook,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t40mLD.th.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t4czVK.th.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/09/21/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8BDOM/"><img class="prev_cover lazyload" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.png'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">⑤JavaScript教程之DOM</div></div></a></div><div class="next-post pull_right"><a href="/2021/08/29/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%A0%87%E5%87%86%E5%BA%93/"><img class="next_cover lazyload" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.png'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">③JavaScript教程之标准库</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/11/07/JavaScript教程之网页元素接口/" title=" ⑧JavaScript教程之网页元素接口"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-07</div><div class="relatedPosts_title"> ⑧JavaScript教程之网页元素接口</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/17/JavaScript教程之浏览器模型/" title="⑦JavaScript教程之浏览器模型"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-17</div><div class="relatedPosts_title">⑦JavaScript教程之浏览器模型</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/04/JavaScript教程之事件/" title="⑥JavaScript教程之事件"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-04</div><div class="relatedPosts_title">⑥JavaScript教程之事件</div></div></a></div><div class="relatedPosts_item"><a href="/2021/09/21/JavaScript教程之DOM/" title="⑤JavaScript教程之DOM"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-09-21</div><div class="relatedPosts_title">⑤JavaScript教程之DOM</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/29/JavaScript教程之标准库/" title="③JavaScript教程之标准库"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-29</div><div class="relatedPosts_title">③JavaScript教程之标准库</div></div></a></div><div class="relatedPosts_item"><a href="/2021/05/04/JavaScript从进阶到熟悉/" title="②JavaScript从进阶到熟悉"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-04</div><div class="relatedPosts_title">②JavaScript从进阶到熟悉</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: true,
  appId: 'z2GwNsG7RRpWpx5rt7psedl5-MdYXbMMI',
  appKey: 'gI6Yhfwz4JiUIv9546gepko8',
  placeholder: '来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2026 By PanXiaoKang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">小伙伴们好！欢迎来到<a href="https://panyongkang.github.io/" target="_blank" rel="noopener">向阳榆木</a>的博客！</div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>黔ICP备54587259号</span></a></div><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2020,01,01,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/platelet.model.json"},"display":{"position":"right","width":200,"height":500},"mobile":{"show":true},"log":false});</script></body></html>