<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>①JavaScript从入门到进阶 | 向阳榆木</title><meta name="description" content="①JavaScript从入门到进阶"><meta name="keywords" content="JavaScript,前端技术,进阶之路"><meta name="author" content="PanXiaoKang"><meta name="copyright" content="PanXiaoKang"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/Lotus.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="https://fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="wyZknSW2XMDLHhrSvtifCN1aQwr2nn53ydI_lDzVJmI"/><meta name="baidu-site-verification" content="p1OeTLcEA8"/><meta name="twitter:card" content="summary"><meta name="twitter:title" content="①JavaScript从入门到进阶"><meta name="twitter:description" content="①JavaScript从入门到进阶"><meta name="twitter:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg"><meta property="og:type" content="article"><meta property="og:title" content="①JavaScript从入门到进阶"><meta property="og:url" content="http://example.com/2021/04/30/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"><meta property="og:site_name" content="向阳榆木"><meta property="og:description" content="①JavaScript从入门到进阶"><meta property="og:image" content="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg"><script src="https://cdn.jsdelivr.net/npm/js-cookie/dist/js.cookie.min.js"></script><script>var autoChangeMode = '1'
var t = Cookies.get("theme")
if (autoChangeMode == '1'){
  var isDarkMode = window.matchMedia("(prefers-color-scheme: dark)").matches
  var isLightMode = window.matchMedia("(prefers-color-scheme: light)").matches
  var isNotSpecified = window.matchMedia("(prefers-color-scheme: no-preference)").matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined){
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport){
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour < 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
  }
  } else if (t == 'light') activateLightMode()
  else activateDarkMode()

} else if (autoChangeMode == '2'){
  now = new Date();
  hour = now.getHours();
  isNight = hour < 6 || hour >= 18
  if(t === undefined) isNight? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode() 
} else {
  if ( t == 'dark' ) activateDarkMode()
  else if ( t == 'light') activateLightMode()
}

function activateDarkMode(){
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null){
    document.querySelector('meta[name="theme-color"]').setAttribute('content','#000')
  }
}
function activateLightMode(){
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null){
  document.querySelector('meta[name="theme-color"]').setAttribute('content','#fff')
  }
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><link rel="canonical" href="http://example.com/2021/04/30/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/"><link rel="prev" title="②JavaScript从进阶到熟悉" href="http://example.com/2021/05/04/JavaScript%E4%BB%8E%E8%BF%9B%E9%98%B6%E5%88%B0%E7%86%9F%E6%82%89/"><link rel="next" title="SpringBoot入门" href="http://example.com/2021/04/24/SpringBoot%E5%85%A5%E9%97%A8/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://xxx/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"簡"},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: true,
  copyright: undefined,
  ClickShowText: {"text":"最近有点失眠了,每天被自己帅醒,帅早已成为负担,除了帅一无所有,富强,民主,文明,和谐,自由,平等,公正,法治,爱国,敬业,诚信,友善","fontSize":"20px"},
  medium_zoom: false,
  fancybox: true,
  Snackbar: undefined,
  baiduPush: true,
  highlightCopy: true,
  highlightLang: true,
  highlightShrink: 'true',
  isFontAwesomeV5: false,
  isPhotoFigcaption: false
  
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isSidebar: true  
  }</script><noscript><style>
#page-header {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><meta name="generator" content="Hexo 4.2.1"></head><body><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://s1.ax1x.com/2020/06/09/t40ARx.th.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">76</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">139</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">24</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/SimpleNav/SimpleNav.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 简单导航</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://liuxiangyang.space/game2/" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 相册集</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D照片屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 生活相册</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li></ul></div></div></div></div><i class="fa fa-arrow-right on" id="toggle-sidebar" aria-hidden="true">     </i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#JavaScript入门"><span class="toc-number">1.</span> <span class="toc-text">JavaScript入门</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#JS术语介绍："><span class="toc-number">1.1.</span> <span class="toc-text">JS术语介绍：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript组成"><span class="toc-number">1.2.</span> <span class="toc-text">JavaScript组成</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-基本语法"><span class="toc-number">1.3.</span> <span class="toc-text">JavaScript 基本语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语句"><span class="toc-number">1.3.1.</span> <span class="toc-text">语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量"><span class="toc-number">1.3.2.</span> <span class="toc-text">变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标识符"><span class="toc-number">1.3.3.</span> <span class="toc-text">标识符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#注释"><span class="toc-number">1.3.4.</span> <span class="toc-text">注释</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#区块"><span class="toc-number">1.3.5.</span> <span class="toc-text">区块</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件语句"><span class="toc-number">1.3.6.</span> <span class="toc-text">条件语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#循环语句"><span class="toc-number">1.3.7.</span> <span class="toc-text">循环语句</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#标签（label）"><span class="toc-number">1.3.8.</span> <span class="toc-text">标签（label）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#JavaScript-数据类型"><span class="toc-number">1.4.</span> <span class="toc-text">JavaScript 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本类型"><span class="toc-number">1.4.1.</span> <span class="toc-text">基本类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象（object）类型"><span class="toc-number">1.4.2.</span> <span class="toc-text">对象（object）类型</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#typeof-运算符"><span class="toc-number">1.5.</span> <span class="toc-text">typeof 运算符</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#null-undefined-和布尔值"><span class="toc-number">1.6.</span> <span class="toc-text">null, undefined 和布尔值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#概述"><span class="toc-number">1.6.1.</span> <span class="toc-text">概述</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#用法和含义"><span class="toc-number">1.6.2.</span> <span class="toc-text">用法和含义</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布尔值"><span class="toc-number">1.7.</span> <span class="toc-text">布尔值</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数值"><span class="toc-number">1.8.</span> <span class="toc-text">数值</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#整数和浮点数"><span class="toc-number">1.8.1.</span> <span class="toc-text">整数和浮点数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值精度"><span class="toc-number">1.8.2.</span> <span class="toc-text">数值精度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值的表示法"><span class="toc-number">1.8.3.</span> <span class="toc-text">数值的表示法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值的进制"><span class="toc-number">1.8.4.</span> <span class="toc-text">数值的进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#特殊数值"><span class="toc-number">1.8.5.</span> <span class="toc-text">特殊数值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#NaN"><span class="toc-number">1.8.6.</span> <span class="toc-text">NaN</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Infinity"><span class="toc-number">1.8.7.</span> <span class="toc-text">Infinity</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#与数值相关的全局方法"><span class="toc-number">1.8.8.</span> <span class="toc-text">与数值相关的全局方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符串"><span class="toc-number">1.9.</span> <span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义"><span class="toc-number">1.9.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#转义"><span class="toc-number">1.9.2.</span> <span class="toc-text">转义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串与数组"><span class="toc-number">1.9.3.</span> <span class="toc-text">字符串与数组</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#length-属性"><span class="toc-number">1.9.4.</span> <span class="toc-text">length 属性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#字符集"><span class="toc-number">1.10.</span> <span class="toc-text">字符集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Base64转码"><span class="toc-number">1.11.</span> <span class="toc-text">Base64转码</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#对象"><span class="toc-number">1.12.</span> <span class="toc-text">对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#生成方法"><span class="toc-number">1.12.1.</span> <span class="toc-text">生成方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#键名"><span class="toc-number">1.12.2.</span> <span class="toc-text">键名</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的引用"><span class="toc-number">1.12.3.</span> <span class="toc-text">对象的引用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#属性的操作"><span class="toc-number">1.13.</span> <span class="toc-text">属性的操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的读取"><span class="toc-number">1.13.1.</span> <span class="toc-text">属性的读取</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的赋值"><span class="toc-number">1.13.2.</span> <span class="toc-text">属性的赋值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的查看"><span class="toc-number">1.13.3.</span> <span class="toc-text">属性的查看</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的删除"><span class="toc-number">1.13.4.</span> <span class="toc-text">属性的删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性是否存在：in-运算符"><span class="toc-number">1.13.5.</span> <span class="toc-text">属性是否存在：in 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性的遍历：for…in-循环"><span class="toc-number">1.13.6.</span> <span class="toc-text">属性的遍历：for…in 循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#with-语句"><span class="toc-number">1.13.7.</span> <span class="toc-text">with 语句</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#函数"><span class="toc-number">1.14.</span> <span class="toc-text">函数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的声明"><span class="toc-number">1.14.1.</span> <span class="toc-text">函数的声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的重复声明"><span class="toc-number">1.14.2.</span> <span class="toc-text">函数的重复声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#圆括号运算符，return-语句和递归"><span class="toc-number">1.14.3.</span> <span class="toc-text">圆括号运算符，return 语句和递归</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#第一等公民"><span class="toc-number">1.14.4.</span> <span class="toc-text">第一等公民</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数名的提升"><span class="toc-number">1.14.5.</span> <span class="toc-text">函数名的提升</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的属性和方法"><span class="toc-number">1.14.6.</span> <span class="toc-text">函数的属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数作用域"><span class="toc-number">1.14.7.</span> <span class="toc-text">函数作用域</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#参数"><span class="toc-number">1.15.</span> <span class="toc-text">参数</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义-1"><span class="toc-number">1.15.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#参数的省略"><span class="toc-number">1.15.2.</span> <span class="toc-text">参数的省略</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#传递方式"><span class="toc-number">1.15.3.</span> <span class="toc-text">传递方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#同名参数"><span class="toc-number">1.15.4.</span> <span class="toc-text">同名参数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#arguments-对象"><span class="toc-number">1.15.5.</span> <span class="toc-text">arguments 对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数的其他知识点"><span class="toc-number">1.15.6.</span> <span class="toc-text">函数的其他知识点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#立即调用的函数表达式（IIFE）"><span class="toc-number">1.15.7.</span> <span class="toc-text">立即调用的函数表达式（IIFE）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#eval-命令"><span class="toc-number">1.16.</span> <span class="toc-text">eval 命令</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#基本用法"><span class="toc-number">1.16.1.</span> <span class="toc-text">基本用法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#eval-的别名调用"><span class="toc-number">1.16.2.</span> <span class="toc-text">eval 的别名调用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数组"><span class="toc-number">1.17.</span> <span class="toc-text">数组</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#定义-2"><span class="toc-number">1.17.1.</span> <span class="toc-text">定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的本质"><span class="toc-number">1.17.2.</span> <span class="toc-text">数组的本质</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#length-属性-1"><span class="toc-number">1.17.3.</span> <span class="toc-text">length 属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#in-运算符"><span class="toc-number">1.17.4.</span> <span class="toc-text">in 运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#for…in-循环和数组的遍历"><span class="toc-number">1.17.5.</span> <span class="toc-text">for…in 循环和数组的遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数组的空位"><span class="toc-number">1.17.6.</span> <span class="toc-text">数组的空位</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#类似数组的对象"><span class="toc-number">1.17.7.</span> <span class="toc-text">类似数组的对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ES5"><span class="toc-number">1.18.</span> <span class="toc-text">什么是ES5</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么是ES6"><span class="toc-number">1.19.</span> <span class="toc-text">什么是ES6</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Javascript、TypeScript和ES6的关系与区别"><span class="toc-number">1.20.</span> <span class="toc-text">Javascript、TypeScript和ES6的关系与区别</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><div class="post-bg" id="nav" style="background-image: url(https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg)"><div id="page-header"><span class="pull_left" id="blog_name"><a class="blog_title" id="site-name" href="/">向阳榆木</a></span><span class="pull_right menus"><div id="search_button"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a></div><div class="menus_item"><a class="site-page" href="/random/"><i class="fa-fw fa fa-random"></i><span> 随机文章</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-th-large" aria-hidden="true"></i><span> 归档</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a></li><li><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/tagsnet/"><i class="fa-fw fa fa-connectdevelop"></i><span> 关系网</span></a></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-send-o" aria-hidden="true"></i><span> 导航栏</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://xyyum.icu/mypages/OnlyI.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 主页导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/xkzhdh/Integrated.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 综合导航</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/software/index.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-send"></i><span> 软件分享</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/SimpleNav/SimpleNav.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-paper-plane-o"></i><span> 简单导航</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-list" aria-hidden="true"></i><span> 列表</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/books/"><i class="fa-fw fa fa-book"></i><span> 书籍</span></a></li><li><a class="site-page" href="/movies/"><i class="fa-fw fa fa-film"></i><span> 电影</span></a></li><li><a class="site-page" href="/games/"><i class="fa-fw fa fa-gamepad"></i><span> 游戏</span></a></li><li><a class="site-page" href="/bilibili/"><i class="fa-fw fa fa-play-circle"></i><span> 番剧</span></a></li><li><a class="site-page" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page" href="/movie/"><i class="fa-fw fa fa-play-circle-o"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-link" aria-hidden="true"></i><span> 友情链接</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友情链接</span></a></li><li><a class="site-page" href="https://yumuxy.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 桑榆未晚</span></a></li><li><a class="site-page" href="https://lllzxqq.gitee.io/" target="_blank" rel="noopener"><i class="fa-fw fa fa-link"></i><span> 偏偏💖雨季</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-user-circle-o" aria-hidden="true"></i><span> 关于我</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="http://www.xbmu.edu.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-graduation-cap"></i><span> 母校</span></a></li><li><a class="site-page" href="/workshop/"><i class="fa-fw fa fa-heartbeat"></i><span> 作品</span></a></li><li><a class="site-page" href="/mybook/"><i class="fa-fw fa fa-book"></i><span> 自传</span></a></li><li><a class="site-page" href="/anires/"><i class="fa-fw fa fa-list-alt"></i><span> 简历</span></a></li><li><a class="site-page" href="/vcard/"><i class="fa-fw fa fa-vcard-o"></i><span> 名片</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gamepad" aria-hidden="true"></i><span> 娱乐</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="https://liuxiangyang.space/game2/" target="_blank" rel="noopener"><i class="fa-fw fa fa-gamepad"></i><span> 打字游戏</span></a></li><li><a class="site-page" href="https://xyyum.icu/mypages/GreedySnake/GreedySnake.html" target="_blank" rel="noopener"><i class="fa-fw fa fa-lastfm"></i><span> 贪吃蛇</span></a></li><li><a class="site-page" href="/petalage/"><i class="fa-fw fa fa-gamepad"></i><span> 表白时刻</span></a></li><li><a class="site-page" href="/yszq/"><i class="fa-fw fa fa-gamepad"></i><span> 3D元素</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-gear (alias)" aria-hidden="true"></i><span> 工具平台</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/xkdm/"><i class="fa-fw fa fa-star"></i><span> 星空弹幕</span></a></li><li><a class="site-page" href="https://xyym.avosapps.us/" target="_blank" rel="noopener"><i class="fa-fw fa fa-commenting-o"></i><span> 评论管理</span></a></li><li><a class="site-page" href="https://myhkw.cn/admin/user/login/" target="_blank" rel="noopener"><i class="fa-fw fa fa-music"></i><span> 音乐后台</span></a></li><li><a class="site-page" href="https://www.superbed.cn/" target="_blank" rel="noopener"><i class="fa-fw fa fa-area-chart"></i><span> 聚合图床</span></a></li></ul></div><div class="menus_item"><a class="site-page"><i class="fa-fw fa fa-heartbeat" aria-hidden="true"></i><span> 相册集</span><i class="fa fa-chevron-down menus-expand" aria-hidden="true"></i></a><ul class="menus_item_child"><li><a class="site-page" href="/3d-gallery/"><i class="fa-fw fa fa-university"></i><span> 3D照片屋</span></a></li><li><a class="site-page" href="/live-photo/"><i class="fa-fw fa fa-photo"></i><span> 生活相册</span></a></li><li><a class="site-page" href="/mtxx/"><i class="fa-fw fa fa-file-photo-o"></i><span> 美图秀秀</span></a></li></ul></div></div><span class="toggle-menu close"><a class="site-page"><i class="fa fa-bars fa-fw" aria-hidden="true"></i></a></span></span></div><div id="post-info"><div id="post-title"><div class="posttitle">①JavaScript从入门到进阶</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2021-04-30 20:50:00"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2021-04-30</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-10-17 21:24:45"><i class="fa fa-history" aria-hidden="true"></i> 更新于 2021-10-17</span></time><span class="post-meta__categories"><span class="post-meta__separator">|</span><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a></span></div><div class="meta-secondline"> </div><div class="meta-thirdline"><span class="post-meta-pv-cv"><i class="fa fa-eye post-meta__icon" aria-hidden="true"> </i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"><span class="post-meta__separator">|</span><i class="post-meta__icon fa fa-comment-o" aria-hidden="true"></i><span>评论数:</span><a href="/2021/04/30/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/#post-comment" itemprop="discussionUrl"><span class="valine-comment-count comment-count" data-xid="/2021/04/30/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/" itemprop="commentCount"></span></a></span></div></div></div></div><main class="layout_post" id="content-inner"><article id="post"><div id="article-container"><h2 id="JavaScript入门"><a href="#JavaScript入门" class="headerlink" title="JavaScript入门"></a>JavaScript入门</h2><p>入门参考教程（通俗易懂）：<a href="https://wangdoc.com/javascript/" target="_blank" rel="noopener">https://wangdoc.com/javascript/</a></p>
<h3 id="JS术语介绍："><a href="#JS术语介绍：" class="headerlink" title="JS术语介绍："></a>JS术语介绍：</h3><blockquote>
<p>JavaScript在1995年由Netscape公司的Brendan Eich，在网景导航者浏览器上首次设计实现而成。因为Netscape与Sun合作，Netscape管理层希望它外观看起来像Java，因此取名为JavaScript。但实际上它的语法风格与Self及Scheme较为接近。</p>
<ul>
<li><strong>ECMAScript</strong>：一个由 ECMA International 进行标准化，TC39 委员会进行监督的语言。通常用于指代标准本身。</li>
<li><strong>JavaScript</strong>：ECMAScript 标准的各种实现的最常用称呼。这个术语并不局限于某个特定版本的 ECMAScript 规范，并且可能被用于任何不同程度的任意版本的 ECMAScript 的实现。</li>
<li><strong>ECMAScript 5 (ES5)</strong>：ECMAScript 的第五版修订，于 2009 年完成标准化。这个规范在所有现代浏览器中都相当完全的实现了。</li>
<li><strong>ECMAScript 6 (ES6) / ECMAScript 2015 (ES2015)</strong>：ECMAScript 的第六版修订，于 2015 年完成标准化。这个标准被部分实现于大部分现代浏览器。可以查阅<a href="https://kangax.github.io/compat-table/es6/" target="_blank" rel="noopener">这张兼容性表</a>来查看不同浏览器和工具的实现情况。</li>
<li><strong>ECMAScript 2016</strong>：预计的第七版 ECMAScript 修订，计划于明年夏季发布。这份规范具体将包含哪些特性还没有最终确定</li>
<li><strong>ECMAScript Proposals</strong>：被考虑加入未来版本 ECMAScript 标准的特性与语法提案，他们需要经历五个阶段：Strawman（稻草人），Proposal（提议），Draft（草案），Candidate（候选）以及 Finished （完成）。</li>
</ul>
</blockquote>
<p><strong>定义：</strong>JavaScript是一种动态类型、弱类型、基于原型的客户端脚本语言，用来给HTML网页增加动态功能。</p>
<blockquote>
<p>动态：</p>
<p>在运行时确定数据类型。变量使用之前不需要类型声明，通常变量的类型是被赋值的那个值的类型。</p>
<p>弱类：</p>
<p>计算时可以不同类型之间对使用者透明地隐式转换，即使类型不正确，也能通过隐式转换来得到正确的类型。</p>
<p>原型：</p>
<p>新对象继承对象（作为模版），将自身的属性共享给新对象，模版对象称为原型。这样新对象实例化后不但可以享有自己创建时和运行时定义的属性，而且可以享有原型对象的属性。</p>
<p>PS：新对象指函数，模版对象是实例对象，实例对象是不能继承原型的，函数才可以的。</p>
</blockquote>
<p><strong>特点：</strong></p>
<ol>
<li>是一种边解释边执行的脚本语言，不需要编译。  </li>
<li>主要用来向HTML页面添加交互行为。  </li>
<li>可以直接嵌入HTML页面，但写成单独的js文件有利于结构和行为的分离。  </li>
<li>平台特性，在绝大多数浏览器的支持下，可以在多种平台下运行。  </li>
</ol>
<h3 id="JavaScript组成"><a href="#JavaScript组成" class="headerlink" title="JavaScript组成"></a>JavaScript组成</h3><p><strong>ECMAScript(核心)</strong></p>
<p>​    描述了该语言的语法和基本对象；作为核心，它规定了语言的组成部分：语法、类型、语句、关键字、保留字、操作符、对象 PS：*不完全兼容的实现</p>
<p><strong>DOM（文档对象模型）:</strong></p>
<p>​    操作Html标签的方法和接口；DOM把整个页面映射为一个多层节点结果，开发人员可借助DOM提供的API，轻松地删除、添加、替换或修改任何节点。 PS：DOM也有级别，分为DOM1、DOM2、DOM3，拓展不少规范和新接口。<br><strong>BOM（浏览器对象模型）:</strong></p>
<p>​    操作浏览器的方法和接口；支持可以访问和操作浏览器窗口的浏览器对象模型，开发人员可以控制浏览器显示的页面以外的部分。 PS：BOM未形成规范</p>
<p><strong>JavaScript日常用途：</strong></p>
<p>1.嵌入动态文本于HTML页面。<br>2.对浏览器事件做出响应。<br>3.读写HTML元素。<br>4.在数据被提交到服务器之前验证数据。<br>5.检测访客的浏览器信息。<br>6.控制cookies，包括创建和修改等。<br>7.基于Node.js技术进行服务器端编程。</p>
<p><strong>什么是函数？</strong><br>    函数的含义：类似于Java中的方法，是完成特定任务的代码语句块；<br>    使用更简单：不用定义属于某个类，直接使用；<br>    函数分类：系统函数和自定义函数</p>
<p><strong>BOM编程：</strong><br>1.BOM可实现功能：<br>      1.弹出新的浏览器窗口<br>      2.移动、关闭浏览器窗口以及调整窗口的大小<br>      3.页面的前进、后退<br>具体地址：<a href="https://blog.csdn.net/nanjinzhu/article/details/82718317" target="_blank" rel="noopener">https://blog.csdn.net/nanjinzhu/article/details/82718317</a></p>
<p><strong>DOM编程：</strong></p>
<ol>
<li>特点：任何一个节点都有若干个子节点，但却只有一个父节点。</li>
<li>地址：<a href="https://blog.csdn.net/yanyan965914478/article/details/90209377" target="_blank" rel="noopener">https://blog.csdn.net/yanyan965914478/article/details/90209377</a></li>
</ol>
<p>BOM和DOM具体内容：<a href="https://blog.csdn.net/qq877507054/article/details/51395830" target="_blank" rel="noopener">https://blog.csdn.net/qq877507054/article/details/51395830</a></p>
<p><strong>JavaScript作用域：</strong></p>
<blockquote>
<p> 在JavaScript中，作用域为可访问变量，对象，函数的集合。<br>变量在函数内部声明即为局部变量，在函数外部定义即为全局变量。<br>局部变量只能在函数内访问，全局变量在网页中所有脚本和函数均可访问。<br>（注意：如果变量在函数内没有使用var关键字，该变量自动为全局变量）<br>生命周期：局部变量在函数执行完毕后销毁，全局变量在页面关闭后销毁。</p>
</blockquote>
<h3 id="JavaScript-基本语法"><a href="#JavaScript-基本语法" class="headerlink" title="JavaScript 基本语法"></a>JavaScript 基本语法</h3><h4 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h4><p>JavaScript 程序的执行单位为行（line），也就是一行一行地执行。一般情况下，每一行就是一个语句。</p>
<p>语句以分号结尾，一个分号就表示一个语句结束。多个语句可以写在一行内。</p>
<p>分号前面可以没有任何内容，JavaScript 引擎将其视为空语句。</p>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><p>变量是对“值”的具名引用。变量就是为“值”起名，然后引用这个名字，就等同于引用这个值。变量的名字就是变量名。</p>
<p>注意，JavaScript 的变量名区分大小写，<code>A</code>和<code>a</code>是两个不同的变量。</p>
<p>如果只是声明变量而没有赋值，则该变量的值是<code>undefined</code>。<code>undefined</code>是一个特殊的值，表示“无定义”。</p>
<p>如果变量赋值的时候，忘了写<code>var</code>命令，这条语句也是有效的。但是，不写<code>var</code>的做法，不利于表达意图，而且容易不知不觉地创建全局变量，所以建议总是使用<code>var</code>命令声明变量。</p>
<p>JavaScript 是一种动态类型语言，也就是说，变量的类型没有限制，变量可以随时更改类型。</p>
<p>如果使用<code>var</code>重新声明一个已经存在的变量，是无效的。但是，如果第二次声明的时候还进行了赋值，则会覆盖掉前面的值。</p>
<p><strong>变量提升</strong></p>
<p>JavaScript 引擎的工作方式是，先解析代码，获取所有被声明的变量，然后再一行一行地运行。这造成的结果，就是所有的变量的声明语句，都会被提升到代码的头部，这就叫做变量提升（hoisting）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(a);</span><br><span class="line">var a &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>上面代码首先使用<code>console.log</code>方法，在控制台（console）显示变量<code>a</code>的值。这时变量<code>a</code>还没有声明和赋值，所以这是一种错误的做法，但是实际上不会报错。因为存在变量提升，真正运行的是下面的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a;</span><br><span class="line">console.log(a);</span><br><span class="line">a &#x3D; 1;</span><br></pre></td></tr></table></figure>

<p>最后的结果是显示<code>undefined</code>，表示变量<code>a</code>已声明，但还未赋值。</p>
<h4 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h4><p>标识符（identifier）指的是用来识别各种值的合法名称。最常见的标识符就是变量名，以及后面要提到的函数名。JavaScript 语言的标识符对大小写敏感，所以<code>a</code>和<code>A</code>是两个不同的标识符。</p>
<p>标识符有一套命名规则，不符合规则的就是非法标识符。JavaScript 引擎遇到非法标识符，就会报错。</p>
<p>简单说，标识符命名规则如下。</p>
<ul>
<li>第一个字符，可以是任意 Unicode 字母（包括英文字母和其他语言的字母），以及美元符号（<code>$</code>）和下划线（<code>_</code>）。</li>
<li>第二个字符及后面的字符，除了 Unicode 字母、美元符号和下划线，还可以用数字<code>0-9</code>。</li>
</ul>
<p>下面这些都是合法的标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">arg0</span><br><span class="line">_tmp</span><br><span class="line">$elem</span><br><span class="line">π</span><br></pre></td></tr></table></figure>

<p>下面这些则是不合法的标识符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">1a  &#x2F;&#x2F; 第一个字符不能是数字</span><br><span class="line">***  &#x2F;&#x2F; 标识符不能包含星号</span><br><span class="line">a+b  &#x2F;&#x2F; 标识符不能包含加号</span><br><span class="line">-d  &#x2F;&#x2F; 标识符不能包含减号或连词线</span><br></pre></td></tr></table></figure>

<p>中文是合法的标识符，可以用作变量名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var 临时变量 &#x3D; 1;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>JavaScript 有一些保留字，不能用作标识符：arguments、break、case、catch、class、const、continue、debugger、default、delete、do、else、enum、eval、export、extends、false、finally、for、function、if、implements、import、in、instanceof、interface、let、new、null、package、private、protected、public、return、static、super、switch、this、throw、true、try、typeof、var、void、while、with、yield。</p>
</blockquote>
<h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>源码中被 JavaScript 引擎忽略的部分就叫做注释，它的作用是对代码进行解释。JavaScript 提供两种注释的写法：一种是单行注释，用<code>//</code>起头；另一种是多行注释，放在<code>/*</code>和<code>*/</code>之间。此外，由于历史上 JavaScript 可以兼容 HTML 代码的注释，所以<code>&lt;!--</code>和<code>--&gt;</code>也被视为合法的单行注释。</p>
<h4 id="区块"><a href="#区块" class="headerlink" title="区块"></a>区块</h4><p>JavaScript 使用大括号，将多个相关的语句组合在一起，称为“区块”（block）。</p>
<p>对于<code>var</code>命令来说，JavaScript 的区块不构成单独的作用域（scope）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var a &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码在区块内部，使用<code>var</code>命令声明并赋值了变量<code>a</code>，然后在区块外部，变量<code>a</code>依然有效，区块对于<code>var</code>命令不构成单独的作用域，与不使用区块的情况没有任何区别。在 JavaScript 语言中，单独使用区块并不常见，区块往往用来构成其他更复杂的语法结构，比如<code>for</code>、<code>if</code>、<code>while</code>、<code>function</code>等。</p>
<h4 id="条件语句"><a href="#条件语句" class="headerlink" title="条件语句"></a>条件语句</h4><p>JavaScript 提供<code>if</code>结构和<code>switch</code>结构，完成条件判断，即只有满足预设的条件，才会执行相应的语句。</p>
<p>注意，<code>if</code>后面的表达式之中，不要混淆赋值表达式（<code>=</code>）、严格相等运算符（<code>===</code>）和相等运算符（<code>==</code>）。尤其是赋值表达式不具有比较作用。建议优先采用“严格相等运算符”（<code>===</code>），而不是“相等运算符”（<code>==</code>）。</p>
<p><strong>1. if 结构</strong></p>
<p><code>if</code>结构先判断一个表达式的布尔值，然后根据布尔值的真伪，执行不同的语句。所谓布尔值，指的是 JavaScript 的两个特殊值，<code>true</code>表示真，<code>false</code>表示<code>伪</code>。</p>
<p><strong>2. if…else 结构</strong></p>
<p><code>if</code>代码块后面，还可以跟一个<code>else</code>代码块，表示不满足条件时，所要执行的代码。</p>
<p><strong>3. switch 结构</strong></p>
<p>多个<code>if...else</code>连在一起使用的时候，可以转为使用更方便的<code>switch</code>结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">switch (fruit) &#123;</span><br><span class="line">  case &quot;banana&quot;:</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    break;</span><br><span class="line">  case &quot;apple&quot;:</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，每个<code>case</code>代码块内部的<code>break</code>语句不能少，否则会接下去执行下一个<code>case</code>代码块，而不是跳出<code>switch</code>结构。</p>
<p><code>switch</code>语句部分和<code>case</code>语句部分，都可以使用表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">switch (1 + 3) &#123;</span><br><span class="line">  case 2 + 2:</span><br><span class="line">    f();</span><br><span class="line">    break;</span><br><span class="line">  default:</span><br><span class="line">    neverHappens();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码的<code>default</code>部分，是永远不会执行到的。</p>
<p>需要注意的是，<code>switch</code>语句后面的表达式，与<code>case</code>语句后面的表示式比较运行结果时，采用的是严格相等运算符（<code>===</code>），而不是相等运算符（<code>==</code>），这意味着比较时不会发生类型转换。</p>
<p><strong>三元运算符 ?:</strong></p>
<p>JavaScript 还有一个三元运算符（即该运算符需要三个运算子）<code>?:</code>，也可以用于逻辑判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(条件) ? 表达式1 : 表达式2</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果“条件”为<code>true</code>，则返回“表达式1”的值，否则返回“表达式2”的值。这个三元运算符可以被视为<code>if...else...</code>的简写形式，因此可以用于多种场合。</p>
<h4 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h4><p><strong>1. while 循环</strong></p>
<p><code>While</code>语句包括一个循环条件和一段代码块，只要条件为真，就不断循环执行代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">while (条件)</span><br><span class="line">  语句;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">while (条件) 语句;</span><br></pre></td></tr></table></figure>

<p><strong>2. for 循环</strong></p>
<p><code>for</code>语句是循环命令的另一种形式，可以指定循环的起点、终点和终止条件。它的格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">for (初始化表达式; 条件; 递增表达式)</span><br><span class="line">  语句</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line"></span><br><span class="line">for (初始化表达式; 条件; 递增表达式) &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>for</code>语句后面的括号里面，有三个表达式。</p>
<ul>
<li>初始化表达式（initialize）：确定循环变量的初始值，只在循环开始时执行一次。</li>
<li>条件表达式（test）：每轮循环开始时，都要执行这个条件表达式，只有值为真，才继续进行循环。</li>
<li>递增表达式（increment）：每轮循环的最后一个操作，通常用来递增循环变量。</li>
</ul>
<p><code>for</code>语句的三个部分（initialize、test、increment），可以省略任何一个，也可以全部省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for ( ; ; )&#123;</span><br><span class="line">  console.log(&#39;Hello World&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码省略了<code>for</code>语句表达式的三个部分，结果就导致了一个无限循环。</p>
<p><strong>3. do…while 循环</strong></p>
<p><code>do...while</code>循环与<code>while</code>循环类似，唯一的区别就是先运行一次循环体，然后判断循环条件。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">do</span><br><span class="line">  语句</span><br><span class="line">while (条件);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">do &#123;</span><br><span class="line">  语句</span><br><span class="line">&#125; while (条件);</span><br></pre></td></tr></table></figure>

<p>不管条件是否为真，<code>do...while</code>循环至少运行一次，这是这种结构最大的特点。另外，<code>while</code>语句后面的分号注意不要省略。</p>
<p>下面是一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 3;</span><br><span class="line">var i &#x3D; 0;</span><br><span class="line"></span><br><span class="line">do &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">  i++;</span><br><span class="line">&#125; while(i &lt; x);</span><br></pre></td></tr></table></figure>

<p><strong>4.break 语句和 continue 语句</strong></p>
<p><code>break</code>语句和<code>continue</code>语句都具有跳转作用，可以让代码不按既有的顺序执行。</p>
<p><code>break</code>语句用于跳出代码块或循环。<code>if</code>循环或<code>for</code>循环都可以使用<code>break</code>语句跳出循环。</p>
<p><code>continue</code>语句用于立即终止本轮循环，返回循环结构的头部，开始下一轮循环。</p>
<h4 id="标签（label）"><a href="#标签（label）" class="headerlink" title="标签（label）"></a>标签（label）</h4><p>JavaScript 语言允许，语句的前面有标签（label），相当于定位符，用于跳转到程序的任意位置，标签的格式如下。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">label:</span><br><span class="line">  语句</span><br></pre></td></tr></table></figure>

<p>标签可以是任意的标识符，但不能是保留字，语句部分可以是任意语句。</p>
<p>标签通常与<code>break</code>语句和<code>continue</code>语句配合使用，跳出特定的循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1) break top;</span><br><span class="line">      console.log(&#39;i&#x3D;&#39; + i + &#39;, j&#x3D;&#39; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0, j&#x3D;0</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0, j&#x3D;1</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0, j&#x3D;2</span><br><span class="line">&#x2F;&#x2F; i&#x3D;1, j&#x3D;0</span><br></pre></td></tr></table></figure>

<p>上面代码为一个双重循环区块，<code>break</code>命令后面加上了<code>top</code>标签（注意，<code>top</code>不用加引号），满足条件时，直接跳出双层循环。如果<code>break</code>语句后面不使用标签，则只能跳出内层循环，进入下一次的外层循环。</p>
<p>标签也可以用于跳出代码块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo: &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">  break foo;</span><br><span class="line">  console.log(&#39;本行不会输出&#39;);</span><br><span class="line">&#125;</span><br><span class="line">console.log(2);</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码执行到<code>break foo</code>，就会跳出区块。</p>
<p><code>continue</code>语句也可以与标签配合使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">top:</span><br><span class="line">  for (var i &#x3D; 0; i &lt; 3; i++)&#123;</span><br><span class="line">    for (var j &#x3D; 0; j &lt; 3; j++)&#123;</span><br><span class="line">      if (i &#x3D;&#x3D;&#x3D; 1 &amp;&amp; j &#x3D;&#x3D;&#x3D; 1) continue top;</span><br><span class="line">      console.log(&#39;i&#x3D;&#39; + i + &#39;, j&#x3D;&#39; + j);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0, j&#x3D;0</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0, j&#x3D;1</span><br><span class="line">&#x2F;&#x2F; i&#x3D;0, j&#x3D;2</span><br><span class="line">&#x2F;&#x2F; i&#x3D;1, j&#x3D;0</span><br><span class="line">&#x2F;&#x2F; i&#x3D;2, j&#x3D;0</span><br><span class="line">&#x2F;&#x2F; i&#x3D;2, j&#x3D;1</span><br><span class="line">&#x2F;&#x2F; i&#x3D;2, j&#x3D;2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>continue</code>命令后面有一个标签名，满足条件时，会跳过当前循环，直接进入下一轮外层循环。如果<code>continue</code>语句后面不使用标签，则只能进入下一轮的内层循环。</p>
<h3 id="JavaScript-数据类型"><a href="#JavaScript-数据类型" class="headerlink" title="JavaScript 数据类型"></a>JavaScript 数据类型</h3><p><strong>面试常问：</strong>说一说<code>javascript</code>中有哪些数据类型?</p>
<p>答：<code>JavaScript</code> 中共有七种内置数据类型，包括<strong>基本类型</strong>和<strong>对象类型</strong>。</p>
<h4 id="基本类型"><a href="#基本类型" class="headerlink" title="基本类型"></a>基本类型</h4><p>基本类型分为以下六种：</p>
<ul>
<li>string（字符串）</li>
<li>boolean（布尔值）</li>
<li>number（数字）</li>
<li>symbol（符号）</li>
<li>null（空值）</li>
<li>undefined（未定义）</li>
</ul>
<p><strong>注意</strong>：</p>
<ol>
<li><code>string</code> 、<code>number</code> 、<code>boolean</code> 和 <code>null</code> <code>undefined</code> 这五种类型统称为<strong>原始类型</strong>（Primitive），表示不能再细分下去的基本类型;</li>
<li><code>symbol</code>是 ES6 中新增的数据类型，<code>symbol</code> 表示独一无二的值，通过 <code>Symbol</code> 函数调用生成，由于生成的 symbol 值为原始类型，所以 <code>Symbol</code> 函数不能使用<code>new</code> 调用；</li>
<li><code>null</code> 和 <code>undefined</code> 通常被认为是特殊值，这两种类型的值唯一，就是其本身。</li>
</ol>
<h4 id="对象（object）类型"><a href="#对象（object）类型" class="headerlink" title="对象（object）类型"></a>对象（object）类型</h4><p>对象类型也叫引用类型，是各种值组成的集合。</p>
<p>对象是最复杂的数据类型，又可以分成三个子类型。</p>
<ul>
<li>狭义的对象（object）</li>
<li>数组（array）</li>
<li>函数（function）</li>
</ul>
<p>对象在逻辑上是属性的无序集合，是存放各种值的容器。对象值存储的是引用地址，所以和基本类型值不可变的特性不同，对象值是可变的。</p>
<p>狭义的对象和数组是两种不同的数据组合方式，除非特别声明，本教程的“对象”都特指狭义的对象。函数其实是处理数据的方法，JavaScript 把它当成一种数据类型，可以赋值给变量，这为编程带来了很大的灵活性，也为 JavaScript 的“函数式编程”奠定了基础。</p>
<h3 id="typeof-运算符"><a href="#typeof-运算符" class="headerlink" title="typeof 运算符"></a>typeof 运算符</h3><p>JavaScript 有三种方法，可以确定一个值到底是什么类型。</p>
<ul>
<li><code>typeof</code>运算符</li>
<li><code>instanceof</code>运算符</li>
<li><code>Object.prototype.toString</code>方法</li>
</ul>
<p><code>instanceof</code>运算符和<code>Object.prototype.toString</code>方法，将在后文介绍。这里介绍<code>typeof</code>运算符。</p>
<p><code>typeof</code>运算符可以返回一个值的数据类型。</p>
<p>数值、字符串、布尔值分别返回<code>number</code>、<code>string</code>、<code>boolean</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof 123 &#x2F;&#x2F; &quot;number&quot;</span><br><span class="line">typeof &#39;123&#39; &#x2F;&#x2F; &quot;string&quot;</span><br><span class="line">typeof false &#x2F;&#x2F; &quot;boolean&quot;</span><br></pre></td></tr></table></figure>

<p>函数返回<code>function</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#125;</span><br><span class="line">typeof f</span><br><span class="line">&#x2F;&#x2F; &quot;function&quot;</span><br></pre></td></tr></table></figure>

<p><code>undefined</code>返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">typeof undefined</span><br><span class="line">&#x2F;&#x2F; &quot;undefined&quot;</span><br></pre></td></tr></table></figure>

<p>利用这一点，<code>typeof</code>可以用来检查一个没有声明的变量，而不报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">v</span><br><span class="line">&#x2F;&#x2F; ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">typeof v</span><br><span class="line">&#x2F;&#x2F; &quot;undefined&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>v</code>没有用<code>var</code>命令声明，直接使用就会报错。但是，放在<code>typeof</code>后面，就不报错了，而是返回<code>undefined</code>。</p>
<p>实际编程中，这个特点通常用在判断语句。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误的写法</span><br><span class="line">if (v) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ReferenceError: v is not defined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确的写法</span><br><span class="line">if (typeof v &#x3D;&#x3D;&#x3D; &quot;undefined&quot;) &#123;</span><br><span class="line">  &#x2F;&#x2F; ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对象返回<code>object</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">typeof window &#x2F;&#x2F; &quot;object&quot;</span><br><span class="line">typeof &#123;&#125; &#x2F;&#x2F; &quot;object&quot;</span><br><span class="line">typeof [] &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，空数组（<code>[]</code>）的类型也是<code>object</code>，这表示在 JavaScript 内部，数组本质上只是一种特殊的对象。这里顺便提一下，<code>instanceof</code>运算符可以区分数组和对象。<code>instanceof</code>运算符的详细解释，请见《面向对象编程》一章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o &#x3D; &#123;&#125;;</span><br><span class="line">var a &#x3D; [];</span><br><span class="line"></span><br><span class="line">o instanceof Array &#x2F;&#x2F; false</span><br><span class="line">a instanceof Array &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>null</code>返回<code>object</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof null &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<p><code>null</code>的类型是<code>object</code>，这是由于历史原因造成的。1995年的 JavaScript 语言第一版，只设计了五种数据类型（对象、整数、浮点数、字符串和布尔值），没考虑<code>null</code>，只把它当作<code>object</code>的一种特殊值。后来<code>null</code>独立出来，作为一种单独的数据类型，为了兼容以前的代码，<code>typeof null</code>返回<code>object</code>就没法改变了。</p>
<h3 id="null-undefined-和布尔值"><a href="#null-undefined-和布尔值" class="headerlink" title="null, undefined 和布尔值"></a>null, undefined 和布尔值</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><code>null</code>与<code>undefined</code>都可以表示“没有”，含义非常相似。将一个变量赋值为<code>undefined</code>或<code>null</code>，老实说，语法效果几乎没区别。</p>
<p>唯一区别：<code>null</code>是一个表示“空”的对象，转为数值时为<code>0</code>；<code>undefined</code>是一个表示”此处无定义”的原始值，转为数值时为<code>NaN</code>。</p>
<h4 id="用法和含义"><a href="#用法和含义" class="headerlink" title="用法和含义"></a>用法和含义</h4><p>对于<code>null</code>和<code>undefined</code>，大致可以像下面这样理解。</p>
<p><code>null</code>表示空值，即该处的值现在为空。调用函数时，某个参数未设置任何值，这时就可以传入<code>null</code>，表示该参数为空。比如，某个函数接受引擎抛出的错误作为参数，如果运行过程中未出错，那么这个参数就会传入<code>null</code>，表示未发生错误。</p>
<p><code>undefined</code>表示“未定义”，下面是返回<code>undefined</code>的典型场景。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 变量声明了，但没有赋值</span><br><span class="line">var i;</span><br><span class="line">i &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用函数时，应该提供的参数没有提供，该参数等于 undefined</span><br><span class="line">function f(x) &#123;</span><br><span class="line">  return x;</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 对象没有赋值的属性</span><br><span class="line">var  o &#x3D; new Object();</span><br><span class="line">o.p &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 函数没有返回值时，默认返回 undefined</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line">f() &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<h3 id="布尔值"><a href="#布尔值" class="headerlink" title="布尔值"></a>布尔值</h3><p>布尔值代表“真”和“假”两个状态。“真”用关键字<code>true</code>表示，“假”用关键字<code>false</code>表示。布尔值只有这两个值。</p>
<p>下列运算符会返回布尔值：</p>
<ul>
<li>前置逻辑运算符： <code>!</code> (Not)</li>
<li>相等运算符：<code>===</code>，<code>!==</code>，<code>==</code>，<code>!=</code></li>
<li>比较运算符：<code>&gt;</code>，<code>&gt;=</code>，<code>&lt;</code>，<code>&lt;=</code></li>
</ul>
<p>如果 JavaScript 预期某个位置应该是布尔值，会将该位置上现有的值自动转为布尔值。转换规则是除了下面六个值被转为<code>false</code>，其他值都视为<code>true</code>。</p>
<ul>
<li><code>undefined</code></li>
<li><code>null</code></li>
<li><code>false</code></li>
<li><code>0</code></li>
<li><code>NaN</code></li>
<li><code>&quot;&quot;</code>或<code>&#39;&#39;</code>（空字符串）</li>
</ul>
<p>布尔值往往用于程序流程的控制，请看一个例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (&#39;&#39;) &#123;</span><br><span class="line">  console.log(&#39;true&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 没有任何输出</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>if</code>命令后面的判断条件，预期应该是一个布尔值，所以 JavaScript 自动将空字符串，转为布尔值<code>false</code>，导致程序不会进入代码块，所以没有任何输出。</p>
<p>注意，空数组（<code>[]</code>）和空对象（<code>{}</code>）对应的布尔值，都是<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if ([]) &#123;</span><br><span class="line">  console.log(&#39;true&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">if (&#123;&#125;) &#123;</span><br><span class="line">  console.log(&#39;true&#39;);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<h3 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h3><h4 id="整数和浮点数"><a href="#整数和浮点数" class="headerlink" title="整数和浮点数"></a>整数和浮点数</h4><p>JavaScript 内部，所有数字都是以64位浮点数形式储存，即使整数也是如此。所以，<code>1</code>与<code>1.0</code>是相同的，是同一个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1 &#x3D;&#x3D;&#x3D; 1.0 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>这就是说，JavaScript 语言的底层根本没有整数，所有数字都是小数（64位浮点数）。容易造成混淆的是，某些运算只有整数才能完成，此时 JavaScript 会自动把64位浮点数，转成32位整数，然后再进行运算。</p>
<h4 id="数值精度"><a href="#数值精度" class="headerlink" title="数值精度"></a>数值精度</h4><p>根据国际标准 IEEE 754，JavaScript 浮点数的64个二进制位，从最左边开始，是这样组成的。</p>
<ul>
<li>第1位：符号位，<code>0</code>表示正数，<code>1</code>表示负数</li>
<li>第2位到第12位（共11位）：指数部分</li>
<li>第13位到第64位（共52位）：小数部分（即有效数字）</li>
</ul>
<p>符号位决定了一个数的正负，指数部分决定了数值的大小，小数部分决定了数值的精度。</p>
<h4 id="数值的表示法"><a href="#数值的表示法" class="headerlink" title="数值的表示法"></a>数值的表示法</h4><p>JavaScript 的数值有多种表示方法，可以用字面形式直接表示，比如<code>35</code>（十进制）和<code>0xFF</code>（十六进制）。</p>
<p>数值也可以采用科学计数法表示，下面是几个科学计数法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">123e3 &#x2F;&#x2F; 123000</span><br><span class="line">123e-3 &#x2F;&#x2F; 0.123</span><br><span class="line">-3.1E+12</span><br><span class="line">.1e-23</span><br></pre></td></tr></table></figure>

<p>科学计数法允许字母<code>e</code>或<code>E</code>的后面，跟着一个整数，表示这个数值的指数部分。</p>
<p>以下两种情况，JavaScript 会自动将数值转为科学计数法表示，其他情况都采用字面形式直接表示。</p>
<p><strong>（1）小数点前的数字多于21位。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1234567890123456789012</span><br><span class="line">&#x2F;&#x2F; 1.2345678901234568e+21</span><br><span class="line"></span><br><span class="line">123456789012345678901</span><br><span class="line">&#x2F;&#x2F; 123456789012345680000</span><br></pre></td></tr></table></figure>

<p><strong>（2）小数点后的零多于5个。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 小数点后紧跟5个以上的零，</span><br><span class="line">&#x2F;&#x2F; 就自动转为科学计数法</span><br><span class="line">0.0000003 &#x2F;&#x2F; 3e-7</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 否则，就保持原来的字面形式</span><br><span class="line">0.000003 &#x2F;&#x2F; 0.000003</span><br></pre></td></tr></table></figure>

<h4 id="数值的进制"><a href="#数值的进制" class="headerlink" title="数值的进制"></a>数值的进制</h4><p>使用字面量（literal）直接表示一个数值时，JavaScript 对整数提供四种进制的表示方法：十进制、十六进制、八进制、二进制。</p>
<ul>
<li>十进制：没有前导0的数值。</li>
<li>八进制：有前缀<code>0o</code>或<code>0O</code>的数值，或者有前导0、且只用到0-7的八个阿拉伯数字的数值。</li>
<li>十六进制：有前缀<code>0x</code>或<code>0X</code>的数值。</li>
<li>二进制：有前缀<code>0b</code>或<code>0B</code>的数值。</li>
</ul>
<p>默认情况下，JavaScript 内部会自动将八进制、十六进制、二进制转为十进制。下面是一些例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xff &#x2F;&#x2F; 255</span><br><span class="line">0o377 &#x2F;&#x2F; 255</span><br><span class="line">0b11 &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>如果八进制、十六进制、二进制的数值里面，出现不属于该进制的数字，就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0xzz &#x2F;&#x2F; 报错</span><br><span class="line">0o88 &#x2F;&#x2F; 报错</span><br><span class="line">0b22 &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>上面代码中，十六进制出现了字母<code>z</code>、八进制出现数字<code>8</code>、二进制出现数字<code>2</code>，因此报错。</p>
<p>通常来说，有前导0的数值会被视为八进制，但是如果前导0后面有数字<code>8</code>和<code>9</code>，则该数值被视为十进制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0888 &#x2F;&#x2F; 888</span><br><span class="line">0777 &#x2F;&#x2F; 511</span><br></pre></td></tr></table></figure>

<p>前导0表示八进制，处理时很容易造成混乱。ES5 的严格模式和 ES6，已经废除了这种表示法，但是浏览器为了兼容以前的代码，目前还继续支持这种表示法。</p>
<h4 id="特殊数值"><a href="#特殊数值" class="headerlink" title="特殊数值"></a>特殊数值</h4><p>JavaScript 提供了几个特殊的数值。</p>
<p><strong>正零和负零</strong></p>
<p>JavaScript 内部实际上存在2个<code>0</code>：一个是<code>+0</code>，一个是<code>-0</code>，区别就是64位浮点数表示法的符号位不同。它们是等价的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-0 &#x3D;&#x3D;&#x3D; +0 &#x2F;&#x2F; true</span><br><span class="line">0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br><span class="line">0 &#x3D;&#x3D;&#x3D; +0 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>几乎所有场合，正零和负零都会被当作正常的<code>0</code>。</p>
<p>唯一有区别的场合是，<code>+0</code>或<code>-0</code>当作分母，返回的值是不相等的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(1 &#x2F; +0) &#x3D;&#x3D;&#x3D; (1 &#x2F; -0) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面的代码之所以出现这样结果，是因为除以正零得到<code>+Infinity</code>，除以负零得到<code>-Infinity</code>，这两者是不相等的（关于<code>Infinity</code>详见下文介绍）。</p>
<h4 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h4><p><strong>（1）含义</strong></p>
<p><code>NaN</code>是 JavaScript 的特殊值，表示“非数字”（Not a Number），主要出现在将字符串解析成数字出错的场合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">5 - &#39;x&#39; &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p>上面代码运行时，会自动将字符串<code>x</code>转为数值，但是由于<code>x</code>不是数值，所以最后得到结果为<code>NaN</code>，表示它是“非数字”（<code>NaN</code>）。</p>
<p>另外，一些数学函数的运算结果会出现<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.acos(2) &#x2F;&#x2F; NaN</span><br><span class="line">Math.log(-1) &#x2F;&#x2F; NaN</span><br><span class="line">Math.sqrt(-1) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p><code>0</code>除以<code>0</code>也会得到<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 &#x2F; 0 &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>NaN</code>不是独立的数据类型，而是一个特殊数值，它的数据类型依然属于<code>Number</code>，使用<code>typeof</code>运算符可以看得很清楚。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof NaN &#x2F;&#x2F; &#39;number&#39;</span><br></pre></td></tr></table></figure>

<p><strong>（2）运算规则</strong></p>
<p><code>NaN</code>不等于任何值，包括它本身。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>数组的<code>indexOf</code>方法内部使用的是严格相等运算符，所以该方法对<code>NaN</code>不成立。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[NaN].indexOf(NaN) &#x2F;&#x2F; -1</span><br></pre></td></tr></table></figure>

<p><code>NaN</code>在布尔运算时被当作<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Boolean(NaN) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p><code>NaN</code>与任何数（包括它自己）的运算，得到的都是<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">NaN + 32 &#x2F;&#x2F; NaN</span><br><span class="line">NaN - 32 &#x2F;&#x2F; NaN</span><br><span class="line">NaN * 32 &#x2F;&#x2F; NaN</span><br><span class="line">NaN &#x2F; 32 &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<h4 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h4><p><strong>（1）含义</strong></p>
<p><code>Infinity</code>表示“无穷”，用来表示两种场景。一种是一个正的数值太大，或一个负的数值太小，无法表示；另一种是非0数值除以0，得到<code>Infinity</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 场景一</span><br><span class="line">Math.pow(2, 1024)</span><br><span class="line">&#x2F;&#x2F; Infinity</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 场景二</span><br><span class="line">0 &#x2F; 0 &#x2F;&#x2F; NaN</span><br><span class="line">1 &#x2F; 0 &#x2F;&#x2F; Infinity</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一个场景是一个表达式的计算结果太大，超出了能够表示的范围，因此返回<code>Infinity</code>。第二个场景是<code>0</code>除以<code>0</code>会得到<code>NaN</code>，而非0数值除以<code>0</code>，会返回<code>Infinity</code>。</p>
<p><code>Infinity</code>有正负之分，<code>Infinity</code>表示正的无穷，<code>-Infinity</code>表示负的无穷。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Infinity &#x3D;&#x3D;&#x3D; -Infinity &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">1 &#x2F; -0 &#x2F;&#x2F; -Infinity</span><br><span class="line">-1 &#x2F; -0 &#x2F;&#x2F; Infinity</span><br></pre></td></tr></table></figure>

<p>上面代码中，非零正数除以<code>-0</code>，会得到<code>-Infinity</code>，负数除以<code>-0</code>，会得到<code>Infinity</code>。</p>
<p>由于数值正向溢出（overflow）、负向溢出（underflow）和被<code>0</code>除，JavaScript 都不报错，所以单纯的数学运算几乎没有可能抛出错误。</p>
<p><code>Infinity</code>大于一切数值（除了<code>NaN</code>），<code>-Infinity</code>小于一切数值（除了<code>NaN</code>）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Infinity &gt; 1000 &#x2F;&#x2F; true</span><br><span class="line">-Infinity &lt; -1000 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>与<code>NaN</code>比较，总是返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Infinity &gt; NaN &#x2F;&#x2F; false</span><br><span class="line">-Infinity &gt; NaN &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">Infinity &lt; NaN &#x2F;&#x2F; false</span><br><span class="line">-Infinity &lt; NaN &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p><strong>（2）运算规则</strong></p>
<p><code>Infinity</code>的四则运算，符合无穷的数学计算规则。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">5 * Infinity &#x2F;&#x2F; Infinity</span><br><span class="line">5 - Infinity &#x2F;&#x2F; -Infinity</span><br><span class="line">Infinity &#x2F; 5 &#x2F;&#x2F; Infinity</span><br><span class="line">5 &#x2F; Infinity &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>0乘以<code>Infinity</code>，返回<code>NaN</code>；0除以<code>Infinity</code>，返回<code>0</code>；<code>Infinity</code>除以0，返回<code>Infinity</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0 * Infinity &#x2F;&#x2F; NaN</span><br><span class="line">0 &#x2F; Infinity &#x2F;&#x2F; 0</span><br><span class="line">Infinity &#x2F; 0 &#x2F;&#x2F; Infinity</span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>加上或乘以<code>Infinity</code>，返回的还是<code>Infinity</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Infinity + Infinity &#x2F;&#x2F; Infinity</span><br><span class="line">Infinity * Infinity &#x2F;&#x2F; Infinity</span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>减去或除以<code>Infinity</code>，得到<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Infinity - Infinity &#x2F;&#x2F; NaN</span><br><span class="line">Infinity &#x2F; Infinity &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>与<code>null</code>计算时，<code>null</code>会转成0，等同于与<code>0</code>的计算。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">null * Infinity &#x2F;&#x2F; NaN</span><br><span class="line">null &#x2F; Infinity &#x2F;&#x2F; 0</span><br><span class="line">Infinity &#x2F; null &#x2F;&#x2F; Infinity</span><br></pre></td></tr></table></figure>

<p><code>Infinity</code>与<code>undefined</code>计算，返回的都是<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">undefined + Infinity &#x2F;&#x2F; NaN</span><br><span class="line">undefined - Infinity &#x2F;&#x2F; NaN</span><br><span class="line">undefined * Infinity &#x2F;&#x2F; NaN</span><br><span class="line">undefined &#x2F; Infinity &#x2F;&#x2F; NaN</span><br><span class="line">Infinity &#x2F; undefined &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<h4 id="与数值相关的全局方法"><a href="#与数值相关的全局方法" class="headerlink" title="与数值相关的全局方法"></a>与数值相关的全局方法</h4><p><strong>parseInt()</strong></p>
<p><strong>（1）基本用法</strong></p>
<p><code>parseInt</code>方法用于将字符串转为整数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;123&#39;) &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure>

<p>如果字符串头部有空格，空格会被自动去除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;   81&#39;) &#x2F;&#x2F; 81</span><br></pre></td></tr></table></figure>

<p>如果<code>parseInt</code>的参数不是字符串，则会先转为字符串再转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(1.23) &#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">parseInt(&#39;1.23&#39;) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>字符串转为整数的时候，是一个个字符依次转换，如果遇到不能转为数字的字符，就不再进行下去，返回已经转好的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;8a&#39;) &#x2F;&#x2F; 8</span><br><span class="line">parseInt(&#39;12**&#39;) &#x2F;&#x2F; 12</span><br><span class="line">parseInt(&#39;12.34&#39;) &#x2F;&#x2F; 12</span><br><span class="line">parseInt(&#39;15e2&#39;) &#x2F;&#x2F; 15</span><br><span class="line">parseInt(&#39;15px&#39;) &#x2F;&#x2F; 15</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>parseInt</code>的参数都是字符串，结果只返回字符串头部可以转为数字的部分。</p>
<p><strong>进制转换</strong></p>
<p><code>parseInt</code>方法还可以接受第二个参数（2到36之间），表示被解析的值的进制，返回该值对应的十进制数。默认情况下，<code>parseInt</code>的第二个参数为10，即默认是十进制转十进制。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;1000&#39;) &#x2F;&#x2F; 1000</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">parseInt(&#39;1000&#39;, 10) &#x2F;&#x2F; 1000</span><br></pre></td></tr></table></figure>

<p>下面是转换指定进制的数的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseInt(&#39;1000&#39;, 2) &#x2F;&#x2F; 8</span><br><span class="line">parseInt(&#39;1000&#39;, 6) &#x2F;&#x2F; 216</span><br><span class="line">parseInt(&#39;1000&#39;, 8) &#x2F;&#x2F; 512</span><br></pre></td></tr></table></figure>

<p>上面代码中，二进制、六进制、八进制的<code>1000</code>，分别等于十进制的8、216和512。这意味着，可以用<code>parseInt</code>方法进行进制的转换。</p>
<p><strong>parseFloat()</strong></p>
<p><code>parseFloat</code>方法用于将一个字符串转为浮点数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#39;3.14&#39;) &#x2F;&#x2F; 3.14</span><br></pre></td></tr></table></figure>

<p>如果字符串符合科学计数法，则会进行相应的转换。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#39;314e-2&#39;) &#x2F;&#x2F; 3.14</span><br><span class="line">parseFloat(&#39;0.0314E+2&#39;) &#x2F;&#x2F; 3.14</span><br></pre></td></tr></table></figure>

<p>如果字符串包含不能转为浮点数的字符，则不再进行往后转换，返回已经转好的部分。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#39;3.14more non-digit characters&#39;) &#x2F;&#x2F; 3.14</span><br></pre></td></tr></table></figure>

<p><code>parseFloat</code>方法会自动过滤字符串前导的空格。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(&#39;\t\v\r12.34\n &#39;) &#x2F;&#x2F; 12.34</span><br></pre></td></tr></table></figure>

<p>如果参数不是字符串，或者字符串的第一个字符不能转化为浮点数，则返回<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">parseFloat([]) &#x2F;&#x2F; NaN</span><br><span class="line">parseFloat(&#39;FF2&#39;) &#x2F;&#x2F; NaN</span><br><span class="line">parseFloat(&#39;&#39;) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p>上面代码中，尤其值得注意，<code>parseFloat</code>会将空字符串转为<code>NaN</code>。</p>
<p>这些特点使得<code>parseFloat</code>的转换结果不同于<code>Number</code>函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">parseFloat(true)  &#x2F;&#x2F; NaN</span><br><span class="line">Number(true) &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">parseFloat(null) &#x2F;&#x2F; NaN</span><br><span class="line">Number(null) &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">parseFloat(&#39;&#39;) &#x2F;&#x2F; NaN</span><br><span class="line">Number(&#39;&#39;) &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">parseFloat(&#39;123.45#&#39;) &#x2F;&#x2F; 123.45</span><br><span class="line">Number(&#39;123.45#&#39;) &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>

<p><strong>isNaN()</strong></p>
<p><code>isNaN</code>方法可以用来判断一个值是否为<code>NaN</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">isNaN(NaN) &#x2F;&#x2F; true</span><br><span class="line">isNaN(123) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>但是，<code>isNaN</code>只对数值有效，如果传入其他值，会被先转成数值。比如，传入字符串的时候，字符串会被先转成<code>NaN</code>，所以最后返回<code>true</code>，这一点要特别引起注意。也就是说，<code>isNaN</code>为<code>true</code>的值，有可能不是<code>NaN</code>，而是一个字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&#39;Hello&#39;) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 相当于</span><br><span class="line">isNaN(Number(&#39;Hello&#39;)) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>出于同样的原因，对于对象和数组，<code>isNaN</code>也返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">isNaN(&#123;&#125;) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">isNaN(Number(&#123;&#125;)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">isNaN([&#39;xzy&#39;]) &#x2F;&#x2F; true</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">isNaN(Number([&#39;xzy&#39;])) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>但是，对于空数组和只有一个数值成员的数组，<code>isNaN</code>返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">isNaN([]) &#x2F;&#x2F; false</span><br><span class="line">isNaN([123]) &#x2F;&#x2F; false</span><br><span class="line">isNaN([&#39;123&#39;]) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码之所以返回<code>false</code>，原因是这些数组能被<code>Number</code>函数转成数值，请参见《数据类型转换》一章。</p>
<p>因此，使用<code>isNaN</code>之前，最好判断一下数据类型。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return typeof value &#x3D;&#x3D;&#x3D; &#39;number&#39; &amp;&amp; isNaN(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断<code>NaN</code>更可靠的方法是，利用<code>NaN</code>为唯一不等于自身的值的这个特点，进行判断。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function myIsNaN(value) &#123;</span><br><span class="line">  return value !&#x3D;&#x3D; value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>isFinite()</strong></p>
<p><code>isFinite</code>方法返回一个布尔值，表示某个值是否为正常的数值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isFinite(Infinity) &#x2F;&#x2F; false</span><br><span class="line">isFinite(-Infinity) &#x2F;&#x2F; false</span><br><span class="line">isFinite(NaN) &#x2F;&#x2F; false</span><br><span class="line">isFinite(undefined) &#x2F;&#x2F; false</span><br><span class="line">isFinite(null) &#x2F;&#x2F; true</span><br><span class="line">isFinite(-1) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>除了<code>Infinity</code>、<code>-Infinity</code>、<code>NaN</code>和<code>undefined</code>这几个值会返回<code>false</code>，<code>isFinite</code>对于其他的数值都会返回<code>true</code>。</p>
<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>字符串就是零个或多个排在一起的字符，放在单引号或双引号之中。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;abc&#39;</span><br><span class="line">&quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>单引号字符串的内部，可以使用双引号。双引号字符串的内部，可以使用单引号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;key &#x3D; &quot;value&quot;&#39;</span><br><span class="line">&quot;It&#39;s a long journey&quot;</span><br></pre></td></tr></table></figure>

<p>上面两个都是合法的字符串。</p>
<p>如果要在单引号字符串的内部，使用单引号，就必须在内部的单引号前面加上反斜杠，用来转义。双引号字符串内部使用双引号，也是如此。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#39;Did she say \&#39;Hello\&#39;?&#39;</span><br><span class="line">&#x2F;&#x2F; &quot;Did she say &#39;Hello&#39;?&quot;</span><br><span class="line"></span><br><span class="line">&quot;Did she say \&quot;Hello\&quot;?&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;Did she say &quot;Hello&quot;?&quot;</span><br></pre></td></tr></table></figure>

<p>由于 HTML 语言的属性值使用双引号，所以很多项目约定 JavaScript 语言的字符串只使用单引号，本教程遵守这个约定。当然，只使用双引号也完全可以。重要的是坚持使用一种风格，不要一会使用单引号表示字符串，一会又使用双引号表示。</p>
<p>字符串默认只能写在一行内，分成多行将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#39;a</span><br><span class="line">b</span><br><span class="line">c&#39;</span><br><span class="line">&#x2F;&#x2F; SyntaxError: Unexpected token ILLEGAL</span><br></pre></td></tr></table></figure>

<p>上面代码将一个字符串分成三行，JavaScript 就会报错。</p>
<p>如果长字符串必须分成多行，可以在每一行的尾部使用反斜杠。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var longString &#x3D; &#39;Long \</span><br><span class="line">long \</span><br><span class="line">long \</span><br><span class="line">string&#39;;</span><br><span class="line"></span><br><span class="line">longString</span><br><span class="line">&#x2F;&#x2F; &quot;Long long long string&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，加了反斜杠以后，原来写在一行的字符串，可以分成多行书写。但是，输出的时候还是单行，效果与写在同一行完全一样。注意，反斜杠的后面必须是换行符，而不能有其他字符（比如空格），否则会报错。</p>
<p>连接运算符（<code>+</code>）可以连接多个单行字符串，将长字符串拆成多行书写，输出的时候也是单行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var longString &#x3D; &#39;Long &#39;</span><br><span class="line">  + &#39;long &#39;</span><br><span class="line">  + &#39;long &#39;</span><br><span class="line">  + &#39;string&#39;;</span><br></pre></td></tr></table></figure>

<p>如果想输出多行字符串，有一种利用多行注释的变通方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">(function () &#123; &#x2F;*</span><br><span class="line">line 1</span><br><span class="line">line 2</span><br><span class="line">line 3</span><br><span class="line">*&#x2F;&#125;).toString().split(&#39;\n&#39;).slice(1, -1).join(&#39;\n&#39;)</span><br><span class="line">&#x2F;&#x2F; &quot;line 1</span><br><span class="line">&#x2F;&#x2F; line 2</span><br><span class="line">&#x2F;&#x2F; line 3&quot;</span><br></pre></td></tr></table></figure>

<p>上面的例子中，输出的字符串就是多行。</p>
<h4 id="转义"><a href="#转义" class="headerlink" title="转义"></a>转义</h4><p>反斜杠（\）在字符串内有特殊含义，用来表示一些特殊字符，所以又称为转义符。</p>
<p>需要用反斜杠转义的特殊字符，主要有下面这些。</p>
<ul>
<li><code>\0</code> ：null（<code>\u0000</code>）</li>
<li><code>\b</code> ：后退键（<code>\u0008</code>）</li>
<li><code>\f</code> ：换页符（<code>\u000C</code>）</li>
<li><code>\n</code> ：换行符（<code>\u000A</code>）</li>
<li><code>\r</code> ：回车键（<code>\u000D</code>）</li>
<li><code>\t</code> ：制表符（<code>\u0009</code>）</li>
<li><code>\v</code> ：垂直制表符（<code>\u000B</code>）</li>
<li><code>\&#39;</code> ：单引号（<code>\u0027</code>）</li>
<li><code>\&quot;</code> ：双引号（<code>\u0022</code>）</li>
<li><code>\\</code> ：反斜杠（<code>\u005C</code>）</li>
</ul>
<p>上面这些字符前面加上反斜杠，都表示特殊含义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.log(&#39;1\n2&#39;)</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>\n</code>表示换行，输出的时候就分成了两行。</p>
<p>反斜杠还有三种特殊用法。</p>
<p>（1）<code>\HHH</code></p>
<p>反斜杠后面紧跟三个八进制数（<code>000</code>到<code>377</code>），代表一个字符。<code>HHH</code>对应该字符的 Unicode 码点，比如<code>\251</code>表示版权符号。显然，这种方法只能输出256种字符。</p>
<p>（2）<code>\xHH</code></p>
<p><code>\x</code>后面紧跟两个十六进制数（<code>00</code>到<code>FF</code>），代表一个字符。<code>HH</code>对应该字符的 Unicode 码点，比如<code>\xA9</code>表示版权符号。这种方法也只能输出256种字符。</p>
<p>（3）<code>\uXXXX</code></p>
<p><code>\u</code>后面紧跟四个十六进制数（<code>0000</code>到<code>FFFF</code>），代表一个字符。<code>XXXX</code>对应该字符的 Unicode 码点，比如<code>\u00A9</code>表示版权符号。</p>
<p>下面是这三种字符特殊写法的例子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#39;\251&#39; &#x2F;&#x2F; &quot;©&quot;</span><br><span class="line">&#39;\xA9&#39; &#x2F;&#x2F; &quot;©&quot;</span><br><span class="line">&#39;\u00A9&#39; &#x2F;&#x2F; &quot;©&quot;</span><br><span class="line"></span><br><span class="line">&#39;\172&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br><span class="line">&#39;\x7A&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br><span class="line">&#39;\u007A&#39; &#x3D;&#x3D;&#x3D; &#39;z&#39; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>如果在非特殊字符前面使用反斜杠，则反斜杠会被省略。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#39;\a&#39;</span><br><span class="line">&#x2F;&#x2F; &quot;a&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>a</code>是一个正常字符，前面加反斜杠没有特殊含义，反斜杠会被自动省略。</p>
<p>如果字符串的正常内容之中，需要包含反斜杠，则反斜杠前面需要再加一个反斜杠，用来对自身转义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;Prev \\ Next&quot;</span><br><span class="line">&#x2F;&#x2F; &quot;Prev \ Next&quot;</span><br></pre></td></tr></table></figure>

<h4 id="字符串与数组"><a href="#字符串与数组" class="headerlink" title="字符串与数组"></a>字符串与数组</h4><p>字符串可以被视为字符数组，因此可以使用数组的方括号运算符，用来返回某个位置的字符（位置编号从0开始）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &#39;hello&#39;;</span><br><span class="line">s[0] &#x2F;&#x2F; &quot;h&quot;</span><br><span class="line">s[1] &#x2F;&#x2F; &quot;e&quot;</span><br><span class="line">s[4] &#x2F;&#x2F; &quot;o&quot;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 直接对字符串使用方括号运算符</span><br><span class="line">&#39;hello&#39;[1] &#x2F;&#x2F; &quot;e&quot;</span><br></pre></td></tr></table></figure>

<p>如果方括号中的数字超过字符串的长度，或者方括号中根本不是数字，则返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#39;abc&#39;[3] &#x2F;&#x2F; undefined</span><br><span class="line">&#39;abc&#39;[-1] &#x2F;&#x2F; undefined</span><br><span class="line">&#39;abc&#39;[&#39;x&#39;] &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>但是，字符串与数组的相似性仅此而已。实际上，无法改变字符串之中的单个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &#39;hello&#39;;</span><br><span class="line"></span><br><span class="line">delete s[0];</span><br><span class="line">s &#x2F;&#x2F; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">s[1] &#x3D; &#39;a&#39;;</span><br><span class="line">s &#x2F;&#x2F; &quot;hello&quot;</span><br><span class="line"></span><br><span class="line">s[5] &#x3D; &#39;!&#39;;</span><br><span class="line">s &#x2F;&#x2F; &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码表示，字符串内部的单个字符无法改变和增删，这些操作会默默地失败。</p>
<h4 id="length-属性"><a href="#length-属性" class="headerlink" title="length 属性"></a>length 属性</h4><p><code>length</code>属性返回字符串的长度，该属性也是无法改变的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &#39;hello&#39;;</span><br><span class="line">s.length &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">s.length &#x3D; 3;</span><br><span class="line">s.length &#x2F;&#x2F; 5</span><br><span class="line"></span><br><span class="line">s.length &#x3D; 7;</span><br><span class="line">s.length &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<p>上面代码表示字符串的<code>length</code>属性无法改变，但是不会报错。</p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>JavaScript 使用 Unicode 字符集。JavaScript 引擎内部，所有字符都用 Unicode 表示。</p>
<p>JavaScript 不仅以 Unicode 储存字符，还允许直接在程序中使用 Unicode 码点表示字符，即将字符写成<code>\uxxxx</code>的形式，其中<code>xxxx</code>代表该字符的 Unicode 码点。比如，<code>\u00A9</code>代表版权符号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var s &#x3D; &#39;\u00A9&#39;;</span><br><span class="line">s &#x2F;&#x2F; &quot;©&quot;</span><br></pre></td></tr></table></figure>

<p>解析代码的时候，JavaScript 会自动识别一个字符是字面形式表示，还是 Unicode 形式表示。输出给用户的时候，所有字符都会转成字面形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f\u006F\u006F &#x3D; &#39;abc&#39;;</span><br><span class="line">foo &#x2F;&#x2F; &quot;abc&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，第一行的变量名<code>foo</code>是 Unicode 形式表示，第二行是字面形式表示。JavaScript 会自动识别。</p>
<p>我们还需要知道，每个字符在 JavaScript 内部都是以16位（即2个字节）的 UTF-16 格式储存。也就是说，JavaScript 的单位字符长度固定为16位长度，即2个字节。</p>
<p>但是，UTF-16 有两种长度：对于码点在<code>U+0000</code>到<code>U+FFFF</code>之间的字符，长度为16位（即2个字节）；对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，长度为32位（即4个字节），而且前两个字节在<code>0xD800</code>到<code>0xDBFF</code>之间，后两个字节在<code>0xDC00</code>到<code>0xDFFF</code>之间。举例来说，码点<code>U+1D306</code>对应的字符为<code>𝌆，</code>它写成 UTF-16 就是<code>0xD834 0xDF06</code>。</p>
<p>JavaScript 对 UTF-16 的支持是不完整的，由于历史原因，只支持两字节的字符，不支持四字节的字符。这是因为 JavaScript 第一版发布的时候，Unicode 的码点只编到<code>U+FFFF</code>，因此两字节足够表示了。后来，Unicode 纳入的字符越来越多，出现了四字节的编码。但是，JavaScript 的标准此时已经定型了，统一将字符长度限制在两字节，导致无法识别四字节的字符。上一节的那个四字节字符<code>𝌆</code>，浏览器会正确识别这是一个字符，但是 JavaScript 无法识别，会认为这是两个字符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#39;𝌆&#39;.length &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，JavaScript 认为<code>𝌆</code>的长度为2，而不是1。</p>
<p>总结一下，对于码点在<code>U+10000</code>到<code>U+10FFFF</code>之间的字符，JavaScript 总是认为它们是两个字符（<code>length</code>属性为2）。所以处理的时候，必须把这一点考虑在内，也就是说，JavaScript 返回的字符串长度可能是不正确的。</p>
<h3 id="Base64转码"><a href="#Base64转码" class="headerlink" title="Base64转码"></a>Base64转码</h3><p>有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64 编码，将它们转成可以打印的字符。另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。</p>
<p>所谓 Base64 就是一种编码方法，可以将任意值转成 0～9、A～Z、a-z、<code>+</code>和<code>/</code>这64个字符组成的可打印字符。使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
<p>JavaScript 原生提供两个 Base64 相关的方法。</p>
<ul>
<li><code>btoa()</code>：任意值转为 Base64 编码</li>
<li><code>atob()</code>：Base64 编码转为原来的值</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var string &#x3D; &#39;Hello World!&#39;;</span><br><span class="line">btoa(string) &#x2F;&#x2F; &quot;SGVsbG8gV29ybGQh&quot;</span><br><span class="line">atob(&#39;SGVsbG8gV29ybGQh&#39;) &#x2F;&#x2F; &quot;Hello World!&quot;</span><br></pre></td></tr></table></figure>

<p>注意，这两个方法不适合非 ASCII 码的字符，会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">btoa(&#39;你好&#39;) &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>要将非 ASCII 码字符转为 Base64 编码，必须中间插入一个转码环节，再使用这两个方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function b64Encode(str) &#123;</span><br><span class="line">  return btoa(encodeURIComponent(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function b64Decode(str) &#123;</span><br><span class="line">  return decodeURIComponent(atob(str));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">b64Encode(&#39;你好&#39;) &#x2F;&#x2F; &quot;JUU0JUJEJUEwJUU1JUE1JUJE&quot;</span><br><span class="line">b64Decode(&#39;JUU0JUJEJUEwJUU1JUE1JUJE&#39;) &#x2F;&#x2F; &quot;你好&quot;</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><h4 id="生成方法"><a href="#生成方法" class="headerlink" title="生成方法"></a>生成方法</h4><p>对象（object）是 JavaScript 语言的核心概念，也是最重要的数据类型。</p>
<p>什么是对象？简单说，对象就是一组“键值对”（key-value）的集合，是一种无序的复合数据集合。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  foo: &#39;Hello&#39;,</span><br><span class="line">  bar: &#39;World&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，大括号就定义了一个对象，它被赋值给变量<code>obj</code>，所以变量<code>obj</code>就指向一个对象。该对象内部包含两个键值对（又称为两个“成员”），第一个键值对是<code>foo: &#39;Hello&#39;</code>，其中<code>foo</code>是“键名”（成员的名称），字符串<code>Hello</code>是“键值”（成员的值）。键名与键值之间用冒号分隔。第二个键值对是<code>bar: &#39;World&#39;</code>，<code>bar</code>是键名，<code>World</code>是键值。两个键值对之间用逗号分隔。</p>
<h4 id="键名"><a href="#键名" class="headerlink" title="键名"></a>键名</h4><p>对象的所有键名都是字符串（ES6 又引入了 Symbol 值也可以作为键名），所以加不加引号都可以。上面的代码也可以写成下面这样。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  &#39;foo&#39;: &#39;Hello&#39;,</span><br><span class="line">  &#39;bar&#39;: &#39;World&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>如果键名是数值，会被自动转为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  1: &#39;a&#39;,</span><br><span class="line">  3.2: &#39;b&#39;,</span><br><span class="line">  1e2: true,</span><br><span class="line">  1e-2: true,</span><br><span class="line">  .234: true,</span><br><span class="line">  0xFF: true</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj</span><br><span class="line">&#x2F;&#x2F; Object &#123;</span><br><span class="line">&#x2F;&#x2F;   1: &quot;a&quot;,</span><br><span class="line">&#x2F;&#x2F;   3.2: &quot;b&quot;,</span><br><span class="line">&#x2F;&#x2F;   100: true,</span><br><span class="line">&#x2F;&#x2F;   0.01: true,</span><br><span class="line">&#x2F;&#x2F;   0.234: true,</span><br><span class="line">&#x2F;&#x2F;   255: true</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br><span class="line"></span><br><span class="line">obj[&#39;100&#39;] &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的所有键名虽然看上去像数值，实际上都被自动转成了字符串。</p>
<p>如果键名不符合标识名的条件（比如第一个字符为数字，或者含有空格或运算符），且也不是数字，则必须加上引号，否则会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  1p: &#39;Hello World&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 不报错</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  &#39;1p&#39;: &#39;Hello World&#39;,</span><br><span class="line">  &#39;h w&#39;: &#39;Hello World&#39;,</span><br><span class="line">  &#39;p+q&#39;: &#39;Hello World&#39;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>上面对象的三个键名，都不符合标识名的条件，所以必须加上引号。</p>
<p>对象的每一个键名又称为“属性”（property），它的“键值”可以是任何数据类型。如果一个属性的值为函数，通常把这个属性称为“方法”，它可以像函数那样调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  p: function (x) &#123;</span><br><span class="line">    return 2 * x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p(1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的属性<code>p</code>，就指向一个函数。</p>
<p>如果属性的值还是一个对象，就形成了链式引用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123;&#125;;</span><br><span class="line">var o2 &#x3D; &#123; bar: &#39;hello&#39; &#125;;</span><br><span class="line"></span><br><span class="line">o1.foo &#x3D; o2;</span><br><span class="line">o1.foo.bar &#x2F;&#x2F; &quot;hello&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>o1</code>的属性<code>foo</code>指向对象<code>o2</code>，就可以链式引用<code>o2</code>的属性。</p>
<p>对象的属性之间用逗号分隔，最后一个属性后面可以加逗号（trailing comma），也可以不加。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  p: 123,</span><br><span class="line">  m: function () &#123; ... &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码中，<code>m</code>属性后面的那个逗号，有没有都可以。</p>
<p>属性可以动态创建，不必在对象声明时就指定。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.foo &#x3D; 123;</span><br><span class="line">obj.foo &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure>

<p>上面代码中，直接对<code>obj</code>对象的<code>foo</code>属性赋值，结果就在运行时创建了<code>foo</code>属性。</p>
<h4 id="对象的引用"><a href="#对象的引用" class="headerlink" title="对象的引用"></a>对象的引用</h4><p>如果不同的变量名指向同一个对象，那么它们都是这个对象的引用，也就是说指向同一个内存地址。修改其中一个变量，会影响到其他所有变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123;&#125;;</span><br><span class="line">var o2 &#x3D; o1;</span><br><span class="line"></span><br><span class="line">o1.a &#x3D; 1;</span><br><span class="line">o2.a &#x2F;&#x2F; 1</span><br><span class="line"></span><br><span class="line">o2.b &#x3D; 2;</span><br><span class="line">o1.b &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，因此为其中任何一个变量添加属性，另一个变量都可以读写该属性。</p>
<p>此时，如果取消某一个变量对于原对象的引用，不会影响到另一个变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var o1 &#x3D; &#123;&#125;;</span><br><span class="line">var o2 &#x3D; o1;</span><br><span class="line"></span><br><span class="line">o1 &#x3D; 1;</span><br><span class="line">o2 &#x2F;&#x2F; &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>o1</code>和<code>o2</code>指向同一个对象，然后<code>o1</code>的值变为1，这时不会对<code>o2</code>产生影响，<code>o2</code>还是指向原来的那个对象。</p>
<p>但是，这种引用只局限于对象，如果两个变量指向同一个原始类型的值。那么，变量这时都是值的拷贝。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; 1;</span><br><span class="line">var y &#x3D; x;</span><br><span class="line"></span><br><span class="line">x &#x3D; 2;</span><br><span class="line">y &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面的代码中，当<code>x</code>的值发生变化后，<code>y</code>的值并不变，这就表示<code>y</code>和<code>x</code>并不是指向同一个内存地址。</p>
<h3 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h3><h4 id="属性的读取"><a href="#属性的读取" class="headerlink" title="属性的读取"></a>属性的读取</h4><p>读取对象的属性，有两种方法，一种是使用点运算符，还有一种是使用方括号运算符。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  p: &#39;Hello World&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.p &#x2F;&#x2F; &quot;Hello World&quot;</span><br><span class="line">obj[&#39;p&#39;] &#x2F;&#x2F; &quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码分别采用点运算符和方括号运算符，读取属性<code>p</code>。</p>
<p>请注意，如果使用方括号运算符，键名必须放在引号里面，否则会被当作变量处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; &#39;bar&#39;;</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  foo: 1,</span><br><span class="line">  bar: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo  &#x2F;&#x2F; 1</span><br><span class="line">obj[foo]  &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，引用对象<code>obj</code>的<code>foo</code>属性时，如果使用点运算符，<code>foo</code>就是字符串；如果使用方括号运算符，但是不使用引号，那么<code>foo</code>就是一个变量，指向字符串<code>bar</code>。</p>
<p>方括号运算符内部还可以使用表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj[&#39;hello&#39; + &#39; world&#39;]</span><br><span class="line">obj[3 + 3]</span><br></pre></td></tr></table></figure>

<p>数字键可以不加引号，因为会自动转成字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  0.7: &#39;Hello World&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[&#39;0.7&#39;] &#x2F;&#x2F; &quot;Hello World&quot;</span><br><span class="line">obj[0.7] &#x2F;&#x2F; &quot;Hello World&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>的数字键<code>0.7</code>，加不加引号都可以，因为会被自动转为字符串。</p>
<p><code style="color=red;">注意，数值键名不能使用点运算符（因为会被当成小数点），只能使用方括号运算符。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  123: &#39;hello world&#39;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.123 &#x2F;&#x2F; 报错</span><br><span class="line">obj[123] &#x2F;&#x2F; &quot;hello world&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码的第一个表达式，对数值键名<code>123</code>使用点运算符，结果报错。第二个表达式使用方括号运算符，结果就是正确的。</p>
<h4 id="属性的赋值"><a href="#属性的赋值" class="headerlink" title="属性的赋值"></a>属性的赋值</h4><p>点运算符和方括号运算符，不仅可以用来读取值，还可以用来赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo &#x3D; &#39;Hello&#39;;</span><br><span class="line">obj[&#39;bar&#39;] &#x3D; &#39;World&#39;;</span><br></pre></td></tr></table></figure>

<p>上面代码中，分别使用点运算符和方括号运算符，对属性赋值。</p>
<p>JavaScript 允许属性的“后绑定”，也就是说，你可以在任意时刻新增属性，没必要在定义对象的时候，就定义好属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; p: 1 &#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等价于</span><br><span class="line"></span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">obj.p &#x3D; 1;</span><br></pre></td></tr></table></figure>

<h4 id="属性的查看"><a href="#属性的查看" class="headerlink" title="属性的查看"></a>属性的查看</h4><p>查看一个对象本身的所有属性，可以使用<code>Object.keys</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  key1: 1,</span><br><span class="line">  key2: 2</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.keys(obj);</span><br><span class="line">&#x2F;&#x2F; [&#39;key1&#39;, &#39;key2&#39;]</span><br></pre></td></tr></table></figure>

<h4 id="属性的删除"><a href="#属性的删除" class="headerlink" title="属性的删除"></a>属性的删除</h4><p><code>delete</code>命令用于删除对象的属性，删除成功后返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; p: 1 &#125;;</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; [&quot;p&quot;]</span><br><span class="line"></span><br><span class="line">delete obj.p &#x2F;&#x2F; true</span><br><span class="line">obj.p &#x2F;&#x2F; undefined</span><br><span class="line">Object.keys(obj) &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>delete</code>命令删除对象<code>obj</code>的<code>p</code>属性。删除后，再读取<code>p</code>属性就会返回<code>undefined</code>，而且<code>Object.keys</code>方法的返回值也不再包括该属性。</p>
<p>注意，删除一个不存在的属性，<code>delete</code>不报错，而且返回<code>true</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">delete obj.p &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>并没有<code>p</code>属性，但是<code>delete</code>命令照样返回<code>true</code>。因此，不能根据<code>delete</code>命令的结果，认定某个属性是存在的。</p>
<p>只有一种情况，<code>delete</code>命令会返回<code>false</code>，那就是该属性存在，且不得删除。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; Object.defineProperty(&#123;&#125;, &#39;p&#39;, &#123;</span><br><span class="line">  value: 123,</span><br><span class="line">  configurable: false</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">obj.p &#x2F;&#x2F; 123</span><br><span class="line">delete obj.p &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码之中，对象<code>obj</code>的<code>p</code>属性是不能删除的，所以<code>delete</code>命令返回<code>false</code>。</p>
<p>另外，需要注意的是，<code>delete</code>命令只能删除对象本身的属性，无法删除继承的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">delete obj.toString &#x2F;&#x2F; true</span><br><span class="line">obj.toString &#x2F;&#x2F; function toString() &#123; [native code] &#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>toString</code>是对象<code>obj</code>继承的属性，虽然<code>delete</code>命令返回<code>true</code>，但该属性并没有被删除，依然存在。这个例子还说明，即使<code>delete</code>返回<code>true</code>，该属性依然可能读取到值。</p>
<h4 id="属性是否存在：in-运算符"><a href="#属性是否存在：in-运算符" class="headerlink" title="属性是否存在：in 运算符"></a>属性是否存在：in 运算符</h4><p><code>in</code>运算符用于检查对象是否包含某个属性（注意，检查的是键名，不是键值），如果包含就返回<code>true</code>，否则返回<code>false</code>。它的左边是一个字符串，表示属性名，右边是一个对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; p: 1 &#125;;</span><br><span class="line">&#39;p&#39; in obj &#x2F;&#x2F; true</span><br><span class="line">&#39;toString&#39; in obj &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p><code>in</code>运算符的一个问题是，它不能识别哪些属性是对象自身的，哪些属性是继承的。就像上面代码中，对象<code>obj</code>本身并没有<code>toString</code>属性，但是<code>in</code>运算符会返回<code>true</code>，因为这个属性是继承的。</p>
<p>这时，可以使用对象的<code>hasOwnProperty</code>方法判断一下，是否为对象自身的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">if (&#39;toString&#39; in obj) &#123;</span><br><span class="line">  console.log(obj.hasOwnProperty(&#39;toString&#39;)) &#x2F;&#x2F; false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="属性的遍历：for…in-循环"><a href="#属性的遍历：for…in-循环" class="headerlink" title="属性的遍历：for…in 循环"></a>属性的遍历：for…in 循环</h4><p><code>for...in</code>循环用来遍历一个对象的全部属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;a: 1, b: 2, c: 3&#125;;</span><br><span class="line"></span><br><span class="line">for (var i in obj) &#123;</span><br><span class="line">  console.log(&#39;键名：&#39;, i);</span><br><span class="line">  console.log(&#39;键值：&#39;, obj[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 键名： a</span><br><span class="line">&#x2F;&#x2F; 键值： 1</span><br><span class="line">&#x2F;&#x2F; 键名： b</span><br><span class="line">&#x2F;&#x2F; 键值： 2</span><br><span class="line">&#x2F;&#x2F; 键名： c</span><br><span class="line">&#x2F;&#x2F; 键值： 3</span><br></pre></td></tr></table></figure>

<p><code>for...in</code>循环有两个使用注意点。</p>
<ul>
<li>它遍历的是对象所有可遍历（enumerable）的属性，会跳过不可遍历的属性。</li>
<li>它不仅遍历对象自身的属性，还遍历继承的属性。</li>
</ul>
<p>举例来说，对象都继承了<code>toString</code>属性，但是<code>for...in</code>循环不会遍历到这个属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; toString 属性是存在的</span><br><span class="line">obj.toString &#x2F;&#x2F; toString() &#123; [native code] &#125;</span><br><span class="line"></span><br><span class="line">for (var p in obj) &#123;</span><br><span class="line">  console.log(p);</span><br><span class="line">&#125; &#x2F;&#x2F; 没有任何输出</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>继承了<code>toString</code>属性，该属性不会被<code>for...in</code>循环遍历到，因为它默认是“不可遍历”的。</p>
<p>如果继承的属性是可遍历的，那么就会被<code>for...in</code>循环遍历到。但是，一般情况下，都是只想遍历对象自身的属性，所以使用<code>for...in</code>的时候，应该结合使用<code>hasOwnProperty</code>方法，在循环内部判断一下，某个属性是否为对象自身的属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person &#x3D; &#123; name: &#39;老张&#39; &#125;;</span><br><span class="line"></span><br><span class="line">for (var key in person) &#123;</span><br><span class="line">  if (person.hasOwnProperty(key)) &#123;</span><br><span class="line">    console.log(key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; name</span><br></pre></td></tr></table></figure>

<h4 id="with-语句"><a href="#with-语句" class="headerlink" title="with 语句"></a>with 语句</h4><p><code>with</code>语句的格式如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (对象) &#123;</span><br><span class="line">  语句;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>它的作用是操作同一个对象的多个属性时，提供一些书写的方便。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 例一</span><br><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  p1: 1,</span><br><span class="line">  p2: 2,</span><br><span class="line">&#125;;</span><br><span class="line">with (obj) &#123;</span><br><span class="line">  p1 &#x3D; 4;</span><br><span class="line">  p2 &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">obj.p1 &#x3D; 4;</span><br><span class="line">obj.p2 &#x3D; 5;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 例二</span><br><span class="line">with (document.links[0])&#123;</span><br><span class="line">  console.log(href);</span><br><span class="line">  console.log(title);</span><br><span class="line">  console.log(style);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">console.log(document.links[0].href);</span><br><span class="line">console.log(document.links[0].title);</span><br><span class="line">console.log(document.links[0].style);</span><br></pre></td></tr></table></figure>

<p>注意，如果<code>with</code>区块内部有变量的赋值操作，必须是当前对象已经存在的属性，否则会创造一个当前作用域的全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">with (obj) &#123;</span><br><span class="line">  p1 &#x3D; 4;</span><br><span class="line">  p2 &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">obj.p1 &#x2F;&#x2F; undefined</span><br><span class="line">p1 &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>并没有<code>p1</code>属性，对<code>p1</code>赋值等于创造了一个全局变量<code>p1</code>。正确的写法应该是，先定义对象<code>obj</code>的属性<code>p1</code>，然后在<code>with</code>区块内操作它。</p>
<p>这是因为<code>with</code>区块没有改变作用域，它的内部依然是当前作用域。这造成了<code>with</code>语句的一个很大的弊病，就是绑定对象不明确。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">with (obj) &#123;</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>单纯从上面的代码块，根本无法判断<code>x</code>到底是全局变量，还是对象<code>obj</code>的一个属性。这非常不利于代码的除错和模块化，编译器也无法对这段代码进行优化，只能留到运行时判断，这就拖慢了运行速度。<code style="color=red;">因此，建议不要使用<code>with</code>语句，可以考虑用一个临时变量代替<code>with</code>。</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">with(obj1.obj2.obj3) &#123;</span><br><span class="line">  console.log(p1 + p2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 可以写成</span><br><span class="line">var temp &#x3D; obj1.obj2.obj3;</span><br><span class="line">console.log(temp.p1 + temp.p2);</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>函数是一段可以反复调用的代码块。函数还能接受输入的参数，不同的参数会返回不同的值。</p>
<h4 id="函数的声明"><a href="#函数的声明" class="headerlink" title="函数的声明"></a>函数的声明</h4><p>JavaScript 有三种声明函数的方法。</p>
<p><strong>（1）function 命令</strong></p>
<p><code>function</code>命令声明的代码区块，就是一个函数。<code>function</code>命令后面是函数名，函数名后面是一对圆括号，里面是传入函数的参数。函数体放在大括号里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function print(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码命名了一个<code>print</code>函数，以后使用<code>print()</code>这种形式，就可以调用相应的代码。这叫做函数的声明。</p>
<p><strong>（2）函数表达式</strong></p>
<p>除了用<code>function</code>命令声明函数，还可以采用变量赋值的写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var print &#x3D; function(s) &#123;</span><br><span class="line">  console.log(s);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这种写法将一个匿名函数赋值给变量。这时，这个匿名函数又称函数表达式，因为赋值语句的等号右侧只能放表达式。</p>
<p>采用函数表达式声明函数时，<code>function</code>命令后面不带有函数名。如果加上函数名，该函数名只在函数体内部有效，在函数体外部无效。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var print &#x3D; function x()&#123;</span><br><span class="line">  console.log(typeof x);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">x</span><br><span class="line">&#x2F;&#x2F; ReferenceError: x is not defined</span><br><span class="line"></span><br><span class="line">print()</span><br><span class="line">&#x2F;&#x2F; function</span><br></pre></td></tr></table></figure>

<p>上面代码在函数表达式中，加入了函数名<code>x</code>。这个<code>x</code>只在函数体内部可用，指代函数表达式本身，其他地方都不可用。这种写法的用处有两个，一是可以在函数体内部调用自身，二是方便除错（除错工具显示函数调用栈时，将显示函数名，而不再显示这里是一个匿名函数）。因此，下面的形式声明函数也非常常见。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function f() &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，函数的表达式需要在语句的结尾加上分号，表示语句结束。而函数的声明在结尾的大括号后面不用加分号。总的来说，这两种声明函数的方式，差别很细微，可以近似认为是等价的。</p>
<p><strong>（3）Function 构造函数</strong></p>
<p>第三种声明函数的方式是<code>Function</code>构造函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var add &#x3D; new Function(</span><br><span class="line">  &#39;x&#39;,</span><br><span class="line">  &#39;y&#39;,</span><br><span class="line">  &#39;return x + y&#39;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Function</code>构造函数接受三个参数，除了最后一个参数是<code>add</code>函数的“函数体”，其他参数都是<code>add</code>函数的参数。</p>
<p>你可以传递任意数量的参数给<code>Function</code>构造函数，只有最后一个参数会被当做函数体，如果只有一个参数，该参数就是函数体。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var foo &#x3D; new Function(</span><br><span class="line">  &#39;return &quot;hello world&quot;;&#39;</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">function foo() &#123;</span><br><span class="line">  return &#39;hello world&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Function</code>构造函数可以不使用<code>new</code>命令，返回结果完全一样。</p>
<p>总的来说，这种声明函数的方式非常不直观，几乎无人使用。</p>
<h4 id="函数的重复声明"><a href="#函数的重复声明" class="headerlink" title="函数的重复声明"></a>函数的重复声明</h4><p>如果同一个函数被多次声明，后面的声明就会覆盖前面的声明。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  console.log(1);</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(2);</span><br><span class="line">&#125;</span><br><span class="line">f() &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，后一次的函数声明覆盖了前面一次。而且，由于函数名的提升（参见下文），前一次声明在任何时候都是无效的，这一点要特别注意。</p>
<h4 id="圆括号运算符，return-语句和递归"><a href="#圆括号运算符，return-语句和递归" class="headerlink" title="圆括号运算符，return 语句和递归"></a>圆括号运算符，return 语句和递归</h4><p>调用函数时，要使用圆括号运算符。圆括号之中，可以加入函数的参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数名后面紧跟一对圆括号，就会调用这个函数。</p>
<p>函数体内部的<code>return</code>语句，表示返回。JavaScript 引擎遇到<code>return</code>语句，就直接返回<code>return</code>后面的那个表达式的值，后面即使还有语句，也不会得到执行。也就是说，<code>return</code>语句所带的那个表达式，就是函数的返回值。<code>return</code>语句不是必需的，如果没有的话，该函数就不返回任何值，或者说返回<code>undefined</code>。</p>
<p>函数可以调用自身，这就是递归（recursion）。下面就是通过递归，计算斐波那契数列的代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fib(num) &#123;</span><br><span class="line">  if (num &#x3D;&#x3D;&#x3D; 0) return 0;</span><br><span class="line">  if (num &#x3D;&#x3D;&#x3D; 1) return 1;</span><br><span class="line">  return fib(num - 2) + fib(num - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fib(6) &#x2F;&#x2F; 8</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>fib</code>函数内部又调用了<code>fib</code>，计算得到斐波那契数列的第6个元素是8。</p>
<h4 id="第一等公民"><a href="#第一等公民" class="headerlink" title="第一等公民"></a>第一等公民</h4><p>JavaScript 语言将函数看作一种值，与其它值（数值、字符串、布尔值等等）地位相同。凡是可以使用值的地方，就能使用函数。比如，可以把函数赋值给变量和对象的属性，也可以当作参数传入其他函数，或者作为函数的结果返回。函数只是一个可以执行的值，此外并无特殊之处。</p>
<p>由于函数与其他数据类型地位平等，所以在 JavaScript 语言中又称函数为第一等公民。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function add(x, y) &#123;</span><br><span class="line">  return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将函数赋值给一个变量</span><br><span class="line">var operator &#x3D; add;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 将函数作为参数和返回值</span><br><span class="line">function a(op)&#123;</span><br><span class="line">  return op;</span><br><span class="line">&#125;</span><br><span class="line">a(add)(1, 1)</span><br><span class="line">&#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<h4 id="函数名的提升"><a href="#函数名的提升" class="headerlink" title="函数名的提升"></a>函数名的提升</h4><p>JavaScript 引擎将函数名视同变量名，所以采用<code>function</code>命令声明函数时，整个函数会像变量声明一样，被提升到代码头部。所以，下面的代码不会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line"></span><br><span class="line">function f() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>表面上，上面代码好像在声明之前就调用了函数<code>f</code>。但是实际上，由于“变量提升”，函数<code>f</code>被提升到了代码头部，也就是在调用之前已经声明了。但是，如果采用赋值语句定义函数，JavaScript 就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f();</span><br><span class="line">var f &#x3D; function ()&#123;&#125;;</span><br><span class="line">&#x2F;&#x2F; TypeError: undefined is not a function</span><br></pre></td></tr></table></figure>

<p>上面的代码等同于下面的形式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f;</span><br><span class="line">f();</span><br><span class="line">f &#x3D; function () &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>上面代码第二行，调用<code>f</code>的时候，<code>f</code>只是被声明了，还没有被赋值，等于<code>undefined</code>，所以会报错。</p>
<p>注意，如果像下面例子那样，采用<code>function</code>命令和<code>var</code>赋值语句声明同一个函数，由于存在函数提升，最后会采用<code>var</code>赋值语句的定义。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  console.log(&#39;1&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(&#39;2&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面例子中，表面上后面声明的函数<code>f</code>，应该覆盖前面的<code>var</code>赋值语句，但是由于存在函数提升，实际上正好反过来。</p>
<h4 id="函数的属性和方法"><a href="#函数的属性和方法" class="headerlink" title="函数的属性和方法"></a>函数的属性和方法</h4><p><strong>name 属性</strong></p>
<p>函数的<code>name</code>属性返回函数的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;&#125;</span><br><span class="line">f1.name &#x2F;&#x2F; &quot;f1&quot;</span><br></pre></td></tr></table></figure>

<p>如果是通过变量赋值定义的函数，那么<code>name</code>属性返回变量名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f2 &#x3D; function () &#123;&#125;;</span><br><span class="line">f2.name &#x2F;&#x2F; &quot;f2&quot;</span><br></pre></td></tr></table></figure>

<p>但是，上面这种情况，只有在变量的值是一个匿名函数时才是如此。如果变量的值是一个具名函数，那么<code>name</code>属性返回<code>function</code>关键字之后的那个函数名。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f3 &#x3D; function myName() &#123;&#125;;</span><br><span class="line">f3.name &#x2F;&#x2F; &#39;myName&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>f3.name</code>返回函数表达式的名字。注意，真正的函数名还是<code>f3</code>，而<code>myName</code>这个名字只在函数体内部可用。</p>
<p><code>name</code>属性的一个用处，就是获取参数函数的名字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var myFunc &#x3D; function () &#123;&#125;;</span><br><span class="line"></span><br><span class="line">function test(f) &#123;</span><br><span class="line">  console.log(f.name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">test(myFunc) &#x2F;&#x2F; myFunc</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>test</code>内部通过<code>name</code>属性，就可以知道传入的参数是什么函数。</p>
<p><strong>length 属性</strong></p>
<p>函数的<code>length</code>属性返回函数预期传入的参数个数，即函数定义之中的参数个数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;&#125;</span><br><span class="line">f.length &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码定义了空函数<code>f</code>，它的<code>length</code>属性就是定义时的参数个数。不管调用时输入了多少个参数，<code>length</code>属性始终等于2。</p>
<p><code>length</code>属性提供了一种机制，判断定义时和调用时参数的差异，以便实现面向对象编程的“方法重载”（overload）。</p>
<p><strong>toString()</strong></p>
<p>函数的<code>toString()</code>方法返回一个字符串，内容是函数的源码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  a();</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line">&#x2F;&#x2F; function f() &#123;</span><br><span class="line">&#x2F;&#x2F;  a();</span><br><span class="line">&#x2F;&#x2F;  b();</span><br><span class="line">&#x2F;&#x2F;  c();</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f</code>的<code>toString()</code>方法返回了<code>f</code>的源码，包含换行符在内。</p>
<p>对于那些原生的函数，<code>toString()</code>方法返回<code>function (){[native code]}</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt.toString()</span><br><span class="line">&#x2F;&#x2F; &quot;function sqrt() &#123; [native code] &#125;&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Math.sqrt()</code>是 JavaScript 引擎提供的原生函数，<code>toString()</code>方法就返回原生代码的提示。</p>
<p>函数内部的注释也可以返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;&#x2F;*</span><br><span class="line">  这是一个</span><br><span class="line">  多行注释</span><br><span class="line">*&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">f.toString()</span><br><span class="line">&#x2F;&#x2F; &quot;function f()&#123;&#x2F;*</span><br><span class="line">&#x2F;&#x2F;   这是一个</span><br><span class="line">&#x2F;&#x2F;   多行注释</span><br><span class="line">&#x2F;&#x2F; *&#x2F;&#125;&quot;</span><br></pre></td></tr></table></figure>

<p>利用这一点，可以变相实现多行字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var multiline &#x3D; function (fn) &#123;</span><br><span class="line">  var arr &#x3D; fn.toString().split(&#39;\n&#39;);</span><br><span class="line">  return arr.slice(1, arr.length - 1).join(&#39;\n&#39;);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;&#x2F;*</span><br><span class="line">  这是一个</span><br><span class="line">  多行注释</span><br><span class="line">*&#x2F;&#125;</span><br><span class="line"></span><br><span class="line">multiline(f);</span><br><span class="line">&#x2F;&#x2F; &quot; 这是一个</span><br><span class="line">&#x2F;&#x2F;   多行注释&quot;</span><br></pre></td></tr></table></figure>

<p>上面示例中，函数<code>f</code>内部有一个多行注释，<code>toString()</code>方法拿到<code>f</code>的源码后，去掉首尾两行，就得到了一个多行字符串。</p>
<h4 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h4><p><strong>定义</strong></p>
<p>作用域（scope）指的是变量存在的范围。在 ES5 的规范中，JavaScript 只有两种作用域：一种是全局作用域，变量在整个程序中一直存在，所有地方都可以读取；另一种是函数作用域，变量只在函数内部存在。ES6 又新增了块级作用域，本教程不涉及。</p>
<p>对于顶层函数来说，函数外部声明的变量就是全局变量，它可以在函数内部读取。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var v &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f()</span><br><span class="line">&#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面的代码表明，函数<code>f</code>内部可以读取全局变量<code>v</code>。</p>
<p>在函数内部定义的变量，外部无法读取，称为“局部变量”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">  var v &#x3D; 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">v &#x2F;&#x2F; ReferenceError: v is not defined</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>v</code>在函数内部定义，所以是一个局部变量，函数之外就无法读取。</p>
<p>函数内部定义的变量，会在该作用域内覆盖同名全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var v &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function f()&#123;</span><br><span class="line">  var v &#x3D; 2;</span><br><span class="line">  console.log(v);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; 2</span><br><span class="line">v &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>v</code>同时在函数的外部和内部有定义。结果，在函数内部定义，局部变量<code>v</code>覆盖了全局变量<code>v</code>。</p>
<p>注意，对于<code>var</code>命令来说，局部变量只能在函数内部声明，在其他区块中声明，一律都是全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if (true) &#123;</span><br><span class="line">  var x &#x3D; 5;</span><br><span class="line">&#125;</span><br><span class="line">console.log(x);  &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>x</code>在条件判断区块之中声明，结果就是一个全局变量，可以在区块之外读取。</p>
<p><strong>函数内部的变量提升</strong></p>
<p>与全局作用域一样，函数作用域内部也会产生“变量提升”现象。<code>var</code>命令声明的变量，不管在什么位置，变量声明都会被提升到函数体的头部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function foo(x) &#123;</span><br><span class="line">  if (x &gt; 100) &#123;</span><br><span class="line">    var tmp &#x3D; x - 100;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于</span><br><span class="line">function foo(x) &#123;</span><br><span class="line">  var tmp;</span><br><span class="line">  if (x &gt; 100) &#123;</span><br><span class="line">    tmp &#x3D; x - 100;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>函数本身的作用域</strong></p>
<p>函数本身也是一个值，也有自己的作用域。它的作用域与变量一样，就是其声明时所在的作用域，与其运行时所在的作用域无关。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">var x &#x3D; function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  x();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>x</code>是在函数<code>f</code>的外部声明的，所以它的作用域绑定外层，内部变量<code>a</code>不会到函数<code>f</code>体内取值，所以输出<code>1</code>，而不是<code>2</code>。</p>
<p>总之，函数执行时所在的作用域，是定义时的作用域，而不是调用时所在的作用域。</p>
<p>很容易犯错的一点是，如果函数<code>A</code>调用函数<code>B</code>，却没考虑到函数<code>B</code>不会引用函数<code>A</code>的内部变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var x &#x3D; function () &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function y(f) &#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  f();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">y(x)</span><br><span class="line">&#x2F;&#x2F; ReferenceError: a is not defined</span><br></pre></td></tr></table></figure>

<p>上面代码将函数<code>x</code>作为参数，传入函数<code>y</code>。但是，函数<code>x</code>是在函数<code>y</code>体外声明的，作用域绑定外层，因此找不到函数<code>y</code>的内部变量<code>a</code>，导致报错。</p>
<p>同样的，函数体内部声明的函数，作用域绑定函数体内部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  var x &#x3D; 1;</span><br><span class="line">  function bar() &#123;</span><br><span class="line">    console.log(x);</span><br><span class="line">  &#125;</span><br><span class="line">  return bar;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var x &#x3D; 2;</span><br><span class="line">var f &#x3D; foo();</span><br><span class="line">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>foo</code>内部声明了一个函数<code>bar</code>，<code>bar</code>的作用域绑定<code>foo</code>。当我们在<code>foo</code>外部取出<code>bar</code>执行时，变量<code>x</code>指向的是<code>foo</code>内部的<code>x</code>，而不是<code>foo</code>外部的<code>x</code>。正是这种机制，构成了下文要讲解的“闭包”现象。</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p>函数运行的时候，有时需要提供外部数据，不同的外部数据会得到不同的结果，这种外部数据就叫参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function square(x) &#123;</span><br><span class="line">  return x * x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">square(2) &#x2F;&#x2F; 4</span><br><span class="line">square(3) &#x2F;&#x2F; 9</span><br></pre></td></tr></table></figure>

<p>上式的<code>x</code>就是<code>square</code>函数的参数。每次运行的时候，需要提供这个值，否则得不到结果。</p>
<h4 id="参数的省略"><a href="#参数的省略" class="headerlink" title="参数的省略"></a>参数的省略</h4><p>函数参数不是必需的，JavaScript 允许省略参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) &#x2F;&#x2F; 1</span><br><span class="line">f(1) &#x2F;&#x2F; 1</span><br><span class="line">f() &#x2F;&#x2F; undefined</span><br><span class="line"></span><br><span class="line">f.length &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码的函数<code>f</code>定义了两个参数，但是运行时无论提供多少个参数（或者不提供参数），JavaScript 都不会报错。省略的参数的值就变为<code>undefined</code>。需要注意的是，函数的<code>length</code>属性与实际传入的参数个数无关，只反映函数预期传入的参数个数。</p>
<p>但是，没有办法只省略靠前的参数，而保留靠后的参数。如果一定要省略靠前的参数，只有显式传入<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f(a, b) &#123;</span><br><span class="line">  return a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f( , 1) &#x2F;&#x2F; SyntaxError: Unexpected token ,(…)</span><br><span class="line">f(undefined, 1) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>上面代码中，如果省略第一个参数，就会报错。</p>
<h4 id="传递方式"><a href="#传递方式" class="headerlink" title="传递方式"></a>传递方式</h4><p>函数参数如果是原始类型的值（数值、字符串、布尔值），传递方式是传值传递（passes by value）。这意味着，在函数体内修改参数值，不会影响到函数外部。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var p &#x3D; 2;</span><br><span class="line"></span><br><span class="line">function f(p) &#123;</span><br><span class="line">  p &#x3D; 3;</span><br><span class="line">&#125;</span><br><span class="line">f(p);</span><br><span class="line"></span><br><span class="line">p &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>p</code>是一个原始类型的值，传入函数<code>f</code>的方式是传值传递。因此，在函数内部，<code>p</code>的值是原始值的拷贝，无论怎么修改，都不会影响到原始值。</p>
<p>但是，如果函数参数是复合类型的值（数组、对象、其他函数），传递方式是传址传递（pass by reference）。也就是说，传入函数的原始值的地址，因此在函数内部修改参数，将会影响到原始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123; p: 1 &#125;;</span><br><span class="line"></span><br><span class="line">function f(o) &#123;</span><br><span class="line">  o.p &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj.p &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，传入函数<code>f</code>的是参数对象<code>obj</code>的地址。因此，在函数内部修改<code>obj</code>的属性<code>p</code>，会影响到原始值。</p>
<p>注意，如果函数内部修改的，不是参数对象的某个属性，而是替换掉整个参数，这时不会影响到原始值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">function f(o) &#123;</span><br><span class="line">  o &#x3D; [2, 3, 4];</span><br><span class="line">&#125;</span><br><span class="line">f(obj);</span><br><span class="line"></span><br><span class="line">obj &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>上面代码中，在函数<code>f()</code>内部，参数对象<code>obj</code>被整个替换成另一个值。这时不会影响到原始值。这是因为，形式参数（<code>o</code>）的值实际是参数<code>obj</code>的地址，重新对<code>o</code>赋值导致<code>o</code>指向另一个地址，保存在原地址上的值当然不受影响。</p>
<h4 id="同名参数"><a href="#同名参数" class="headerlink" title="同名参数"></a>同名参数</h4><p>如果有同名的参数，则取最后出现的那个值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f()</code>有两个参数，且参数名都是<code>a</code>。取值的时候，以后面的<code>a</code>为准，即使后面的<code>a</code>没有值或被省略，也是以其为准。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1) &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>调用函数<code>f()</code>的时候，没有提供第二个参数，<code>a</code>的取值就变成了<code>undefined</code>。这时，如果要获得第一个<code>a</code>的值，可以使用<code>arguments</code>对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function f(a, a) &#123;</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1) &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<h4 id="arguments-对象"><a href="#arguments-对象" class="headerlink" title="arguments 对象"></a>arguments 对象</h4><p><strong>（1）定义</strong></p>
<p>由于 JavaScript 允许函数有不定数目的参数，所以需要一种机制，可以在函数体内部读取所有参数。这就是<code>arguments</code>对象的由来。</p>
<p><code>arguments</code>对象包含了函数运行时的所有参数，<code>arguments[0]</code>就是第一个参数，<code>arguments[1]</code>就是第二个参数，以此类推。这个对象只有在函数体内部，才可以使用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function (one) &#123;</span><br><span class="line">  console.log(arguments[0]);</span><br><span class="line">  console.log(arguments[1]);</span><br><span class="line">  console.log(arguments[2]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3)</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>正常模式下，<code>arguments</code>对象可以在运行时修改。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function(a, b) &#123;</span><br><span class="line">  arguments[0] &#x3D; 3;</span><br><span class="line">  arguments[1] &#x3D; 2;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 1) &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f()</code>调用时传入的参数，在函数内部被修改成<code>3</code>和<code>2</code>。</p>
<p>严格模式下，<code>arguments</code>对象与函数参数不具有联动关系。也就是说，修改<code>arguments</code>对象不会影响到实际的函数参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function(a, b) &#123;</span><br><span class="line">  &#39;use strict&#39;; &#x2F;&#x2F; 开启严格模式</span><br><span class="line">  arguments[0] &#x3D; 3;</span><br><span class="line">  arguments[1] &#x3D; 2;</span><br><span class="line">  return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 1) &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数体内是严格模式，这时修改<code>arguments</code>对象，不会影响到真实参数<code>a</code>和<code>b</code>。</p>
<p>通过<code>arguments</code>对象的<code>length</code>属性，可以判断函数调用时到底带几个参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function f() &#123;</span><br><span class="line">  return arguments.length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(1, 2, 3) &#x2F;&#x2F; 3</span><br><span class="line">f(1) &#x2F;&#x2F; 1</span><br><span class="line">f() &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p><strong>（2）与数组的关系</strong></p>
<p>需要注意的是，虽然<code>arguments</code>很像数组，但它是一个对象。数组专有的方法（比如<code>slice</code>和<code>forEach</code>），不能在<code>arguments</code>对象上直接使用。</p>
<p>如果要让<code>arguments</code>对象使用数组方法，真正的解决方法是将<code>arguments</code>转为真正的数组。下面是两种常用的转换方法：<code>slice</code>方法和逐一填入新数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var args &#x3D; Array.prototype.slice.call(arguments);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">var args &#x3D; [];</span><br><span class="line">for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">  args.push(arguments[i]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>（3）callee 属性</strong></p>
<p><code>arguments</code>对象带有一个<code>callee</code>属性，返回它所对应的原函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function () &#123;</span><br><span class="line">  console.log(arguments.callee &#x3D;&#x3D;&#x3D; f);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<p>可以通过<code>arguments.callee</code>，达到调用函数自身的目的。这个属性在严格模式里面是禁用的，因此不建议使用。</p>
<h4 id="函数的其他知识点"><a href="#函数的其他知识点" class="headerlink" title="函数的其他知识点"></a>函数的其他知识点</h4><p><strong>闭包</strong></p>
<p>闭包（closure）是 JavaScript 语言的一个难点，也是它的特色，很多高级应用都要依靠闭包实现。</p>
<p>理解闭包，首先必须理解变量作用域。前面提到，JavaScript 有两种作用域：全局作用域和函数作用域。函数内部可以直接读取全局变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var n &#x3D; 999;</span><br><span class="line"></span><br><span class="line">function f1() &#123;</span><br><span class="line">  console.log(n);</span><br><span class="line">&#125;</span><br><span class="line">f1() &#x2F;&#x2F; 999</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>可以读取全局变量<code>n</code>。</p>
<p>但是，正常情况下，函数外部无法读取函数内部声明的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n &#x3D; 999;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(n)</span><br><span class="line">&#x2F;&#x2F; Uncaught ReferenceError: n is not defined(</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>内部声明的变量<code>n</code>，函数外是无法读取的。</p>
<p>如果出于种种原因，需要得到函数内的局部变量。正常情况下，这是办不到的，只有通过变通方法才能实现。那就是在函数的内部，再定义一个函数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n &#x3D; 999;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">　　console.log(n); &#x2F;&#x2F; 999</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f2</code>就在函数<code>f1</code>内部，这时<code>f1</code>内部的所有局部变量，对<code>f2</code>都是可见的。但是反过来就不行，<code>f2</code>内部的局部变量，对<code>f1</code>就是不可见的。这就是 JavaScript 语言特有的”链式作用域”结构（chain scope），子对象会一级一级地向上寻找所有父对象的变量。所以，父对象的所有变量，对子对象都是可见的，反之则不成立。</p>
<p>既然<code>f2</code>可以读取<code>f1</code>的局部变量，那么只要把<code>f2</code>作为返回值，我们不就可以在<code>f1</code>外部读取它的内部变量了吗！</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function f1() &#123;</span><br><span class="line">  var n &#x3D; 999;</span><br><span class="line">  function f2() &#123;</span><br><span class="line">    console.log(n);</span><br><span class="line">  &#125;</span><br><span class="line">  return f2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var result &#x3D; f1();</span><br><span class="line">result(); &#x2F;&#x2F; 999</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f1</code>的返回值就是函数<code>f2</code>，由于<code>f2</code>可以读取<code>f1</code>的内部变量，所以就可以在外部获得<code>f1</code>的内部变量了。</p>
<p>闭包就是函数<code>f2</code>，即能够读取其他函数内部变量的函数。由于在 JavaScript 语言中，只有函数内部的子函数才能读取内部变量，因此可以把闭包简单理解成“定义在一个函数内部的函数”。闭包最大的特点，就是它可以“记住”诞生的环境，比如<code>f2</code>记住了它诞生的环境<code>f1</code>，所以从<code>f2</code>可以得到<code>f1</code>的内部变量。在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
<p>闭包的最大用处有两个，一个是可以读取外层函数内部的变量，另一个就是让这些变量始终保持在内存中，即闭包可以使得它诞生环境一直存在。请看下面的例子，闭包使得内部变量记住上一次调用时的运算结果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function createIncrementor(start) &#123;</span><br><span class="line">  return function () &#123;</span><br><span class="line">    return start++;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var inc &#x3D; createIncrementor(5);</span><br><span class="line"></span><br><span class="line">inc() &#x2F;&#x2F; 5</span><br><span class="line">inc() &#x2F;&#x2F; 6</span><br><span class="line">inc() &#x2F;&#x2F; 7</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>start</code>是函数<code>createIncrementor</code>的内部变量。通过闭包，<code>start</code>的状态被保留了，每一次调用都是在上一次调用的基础上进行计算。从中可以看到，闭包<code>inc</code>使得函数<code>createIncrementor</code>的内部环境，一直存在。所以，闭包可以看作是函数内部作用域的一个接口。</p>
<p>为什么闭包能够返回外层函数的内部变量？原因是闭包（上例的<code>inc</code>）用到了外层变量（<code>start</code>），导致外层函数（<code>createIncrementor</code>）不能从内存释放。只要闭包没有被垃圾回收机制清除，外层函数提供的运行环境也不会被清除，它的内部变量就始终保存着当前值，供闭包读取。</p>
<p>闭包的另一个用处，是封装对象的私有属性和私有方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function Person(name) &#123;</span><br><span class="line">  var _age;</span><br><span class="line">  function setAge(n) &#123;</span><br><span class="line">    _age &#x3D; n;</span><br><span class="line">  &#125;</span><br><span class="line">  function getAge() &#123;</span><br><span class="line">    return _age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  return &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    getAge: getAge,</span><br><span class="line">    setAge: setAge</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var p1 &#x3D; Person(&#39;张三&#39;);</span><br><span class="line">p1.setAge(25);</span><br><span class="line">p1.getAge() &#x2F;&#x2F; 25</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>Person</code>的内部变量<code>_age</code>，通过闭包<code>getAge</code>和<code>setAge</code>，变成了返回对象<code>p1</code>的私有变量。</p>
<p>注意，外层函数每次运行，都会生成一个新的闭包，而这个闭包又会保留外层函数的内部变量，所以内存消耗很大。因此不能滥用闭包，否则会造成网页的性能问题。</p>
<h4 id="立即调用的函数表达式（IIFE）"><a href="#立即调用的函数表达式（IIFE）" class="headerlink" title="立即调用的函数表达式（IIFE）"></a>立即调用的函数表达式（IIFE）</h4><p>根据 JavaScript 的语法，圆括号<code>()</code>跟在函数名之后，表示调用该函数。比如，<code>print()</code>就表示调用<code>print</code>函数。</p>
<p>有时，我们需要在定义函数之后，立即调用该函数。这时，你不能在函数的定义之后加上圆括号，这会产生语法错误。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">function()&#123; &#x2F;* code *&#x2F; &#125;();</span><br><span class="line">&#x2F;&#x2F; SyntaxError: Unexpected token (</span><br></pre></td></tr></table></figure>

<p>产生这个错误的原因是，<code>function</code>这个关键字即可以当作语句，也可以当作表达式。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 语句</span><br><span class="line">function f() &#123;&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 表达式</span><br><span class="line">var f &#x3D; function f() &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>当作表达式时，函数可以定义后直接加圆括号调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var f &#x3D; function f()&#123; return 1&#125;();</span><br><span class="line">f &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面的代码中，函数定义后直接加圆括号调用，没有报错。原因就是<code>function</code>作为表达式，引擎就把函数定义当作一个值。这种情况下，就不会报错。</p>
<p>为了避免解析的歧义，JavaScript 规定，如果<code>function</code>关键字出现在行首，一律解释成语句。因此，引擎看到行首是<code>function</code>关键字之后，认为这一段都是函数的定义，不应该以圆括号结尾，所以就报错了。</p>
<p>函数定义后立即调用的解决方法，就是不要让<code>function</code>出现在行首，让引擎将其理解成一个表达式。最简单的处理，就是将其放在一个圆括号里面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function()&#123; &#x2F;* code *&#x2F; &#125;());</span><br><span class="line">&#x2F;&#x2F; 或者</span><br><span class="line">(function()&#123; &#x2F;* code *&#x2F; &#125;)();</span><br></pre></td></tr></table></figure>

<p>上面两种写法都是以圆括号开头，引擎就会认为后面跟的是一个表达式，而不是函数定义语句，所以就避免了错误。这就叫做“立即调用的函数表达式”（Immediately-Invoked Function Expression），简称 IIFE。</p>
<p>注意，上面两种写法最后的分号都是必须的。如果省略分号，遇到连着两个 IIFE，可能就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 报错</span><br><span class="line">(function()&#123; &#x2F;* code *&#x2F; &#125;())</span><br><span class="line">(function()&#123; &#x2F;* code *&#x2F; &#125;())</span><br></pre></td></tr></table></figure>

<p>上面代码的两行之间没有分号，JavaScript 会将它们连在一起解释，将第二行解释为第一行的参数。</p>
<p>推而广之，任何让解释器以表达式来处理函数定义的方法，都能产生同样的效果，比如下面三种写法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var i &#x3D; function()&#123; return 10; &#125;();</span><br><span class="line">true &amp;&amp; function()&#123; &#x2F;* code *&#x2F; &#125;();</span><br><span class="line">0, function()&#123; &#x2F;* code *&#x2F; &#125;();</span><br></pre></td></tr></table></figure>

<p>甚至像下面这样写，也是可以的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">!function () &#123; &#x2F;* code *&#x2F; &#125;();</span><br><span class="line">~function () &#123; &#x2F;* code *&#x2F; &#125;();</span><br><span class="line">-function () &#123; &#x2F;* code *&#x2F; &#125;();</span><br><span class="line">+function () &#123; &#x2F;* code *&#x2F; &#125;();</span><br></pre></td></tr></table></figure>

<p>通常情况下，只对匿名函数使用这种“立即执行的函数表达式”。它的目的有两个：一是不必为函数命名，避免了污染全局变量；二是 IIFE 内部形成了一个单独的作用域，可以封装一些外部无法读取的私有变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 写法一</span><br><span class="line">var tmp &#x3D; newData;</span><br><span class="line">processData(tmp);</span><br><span class="line">storeData(tmp);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 写法二</span><br><span class="line">(function () &#123;</span><br><span class="line">  var tmp &#x3D; newData;</span><br><span class="line">  processData(tmp);</span><br><span class="line">  storeData(tmp);</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>

<p>上面代码中，写法二比写法一更好，因为完全避免了污染全局变量。</p>
<h3 id="eval-命令"><a href="#eval-命令" class="headerlink" title="eval 命令"></a>eval 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>eval</code>命令接受一个字符串作为参数，并将这个字符串当作语句执行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">eval(&#39;var a &#x3D; 1;&#39;);</span><br><span class="line">a &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码将字符串当作语句运行，生成了变量<code>a</code>。</p>
<p>如果参数字符串无法当作语句运行，那么就会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&#39;3x&#39;) &#x2F;&#x2F; Uncaught SyntaxError: Invalid or unexpected token</span><br></pre></td></tr></table></figure>

<p>放在<code>eval</code>中的字符串，应该有独自存在的意义，不能用来与<code>eval</code>以外的命令配合使用。举例来说，下面的代码将会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(&#39;return;&#39;); &#x2F;&#x2F; Uncaught SyntaxError: Illegal return statement</span><br></pre></td></tr></table></figure>

<p>上面代码会报错，因为<code>return</code>不能单独使用，必须在函数中使用。</p>
<p>如果<code>eval</code>的参数不是字符串，那么会原样返回。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eval(123) &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure>

<p><code>eval</code>没有自己的作用域，都在当前作用域内执行，因此可能会修改当前作用域的变量的值，造成安全问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line">eval(&#39;a &#x3D; 2&#39;);</span><br><span class="line"></span><br><span class="line">a &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>eval</code>命令修改了外部变量<code>a</code>的值。由于这个原因，<code>eval</code>有安全风险。</p>
<p>为了防止这种风险，JavaScript 规定，如果使用严格模式，<code>eval</code>内部声明的变量，不会影响到外部作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function f() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  eval(&#39;var foo &#x3D; 123&#39;);</span><br><span class="line">  console.log(foo);  &#x2F;&#x2F; ReferenceError: foo is not defined</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上面代码中，函数<code>f</code>内部是严格模式，这时<code>eval</code>内部声明的<code>foo</code>变量，就不会影响到外部。</p>
<p>不过，即使在严格模式下，<code>eval</code>依然可以读写当前作用域的变量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(function f() &#123;</span><br><span class="line">  &#39;use strict&#39;;</span><br><span class="line">  var foo &#x3D; 1;</span><br><span class="line">  eval(&#39;foo &#x3D; 2&#39;);</span><br><span class="line">  console.log(foo);  &#x2F;&#x2F; 2</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>上面代码中，严格模式下，<code>eval</code>内部还是改写了外部变量，可见安全风险依然存在。</p>
<p>总之，<code>eval</code>的本质是在当前作用域之中，注入代码。由于安全风险和不利于 JavaScript 引擎优化执行速度，所以一般不推荐使用。通常情况下，<code>eval</code>最常见的场合是解析 JSON 数据的字符串，不过正确的做法应该是使用原生的<code>JSON.parse</code>方法。</p>
<h4 id="eval-的别名调用"><a href="#eval-的别名调用" class="headerlink" title="eval 的别名调用"></a>eval 的别名调用</h4><p>前面说过<code>eval</code>不利于引擎优化执行速度。更麻烦的是，还有下面这种情况，引擎在静态代码分析的阶段，根本无法分辨执行的是<code>eval</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var m &#x3D; eval;</span><br><span class="line">m(&#39;var x &#x3D; 1&#39;);</span><br><span class="line">x &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，变量<code>m</code>是<code>eval</code>的别名。静态代码分析阶段，引擎分辨不出<code>m(&#39;var x = 1&#39;)</code>执行的是<code>eval</code>命令。</p>
<p>为了保证<code>eval</code>的别名不影响代码优化，JavaScript 的标准规定，凡是使用别名执行<code>eval</code>，<code>eval</code>内部一律是全局作用域。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; 1;</span><br><span class="line"></span><br><span class="line">function f() &#123;</span><br><span class="line">  var a &#x3D; 2;</span><br><span class="line">  var e &#x3D; eval;</span><br><span class="line">  e(&#39;console.log(a)&#39;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>eval</code>是别名调用，所以即使它是在函数中，它的作用域还是全局作用域，因此输出的<code>a</code>为全局变量。这样的话，引擎就能确认<code>e()</code>不会对当前的函数作用域产生影响，优化的时候就可以把这一行排除掉。</p>
<p><code>eval</code>的别名调用的形式五花八门，只要不是直接调用，都属于别名调用，因为引擎只能分辨<code>eval()</code>这一种形式是直接调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eval.call(null, &#39;...&#39;)</span><br><span class="line">window.eval(&#39;...&#39;)</span><br><span class="line">(1, eval)(&#39;...&#39;)</span><br><span class="line">(eval, eval)(&#39;...&#39;)</span><br></pre></td></tr></table></figure>

<p>上面这些形式都是<code>eval</code>的别名调用，作用域都是全局作用域。</p>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p>数组（array）是按次序排列的一组值。每个值的位置都有编号（从0开始），整个数组用方括号表示。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br></pre></td></tr></table></figure>

<p>上面代码中的<code>a</code>、<code>b</code>、<code>c</code>就构成一个数组，两端的方括号是数组的标志。<code>a</code>是0号位置，<code>b</code>是1号位置，<code>c</code>是2号位置。</p>
<p>除了在定义时赋值，数组也可以先定义后赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [];</span><br><span class="line"></span><br><span class="line">arr[0] &#x3D; &#39;a&#39;;</span><br><span class="line">arr[1] &#x3D; &#39;b&#39;;</span><br><span class="line">arr[2] &#x3D; &#39;c&#39;;</span><br></pre></td></tr></table></figure>

<p>任何类型的数据，都可以放入数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [</span><br><span class="line">  &#123;a: 1&#125;,</span><br><span class="line">  [1, 2, 3],</span><br><span class="line">  function() &#123;return true;&#125;</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">arr[0] &#x2F;&#x2F; Object &#123;a: 1&#125;</span><br><span class="line">arr[1] &#x2F;&#x2F; [1, 2, 3]</span><br><span class="line">arr[2] &#x2F;&#x2F; function ()&#123;return true;&#125;</span><br></pre></td></tr></table></figure>

<p>上面数组<code>arr</code>的3个成员依次是对象、数组、函数。</p>
<p>如果数组的元素还是数组，就形成了多维数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [[1, 2], [3, 4]];</span><br><span class="line">a[0][1] &#x2F;&#x2F; 2</span><br><span class="line">a[1][1] &#x2F;&#x2F; 4</span><br></pre></td></tr></table></figure>

<h4 id="数组的本质"><a href="#数组的本质" class="headerlink" title="数组的本质"></a>数组的本质</h4><p>本质上，数组属于一种特殊的对象。<code>typeof</code>运算符会返回数组的类型是<code>object</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof [1, 2, 3] &#x2F;&#x2F; &quot;object&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码表明，<code>typeof</code>运算符认为数组的类型就是对象。</p>
<p>数组的特殊性体现在，它的键名是按次序排列的一组整数（0，1，2…）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line"></span><br><span class="line">Object.keys(arr)</span><br><span class="line">&#x2F;&#x2F; [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;]</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>Object.keys</code>方法返回数组的所有键名。可以看到数组的键名就是整数0、1、2。</p>
<p>由于数组成员的键名是固定的（默认总是0、1、2…），因此数组不用为每个元素指定键名，而对象的每个成员都必须指定键名。JavaScript 语言规定，对象的键名一律为字符串，所以，数组的键名其实也是字符串。之所以可以用数值读取，是因为非字符串的键名会被转为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];</span><br><span class="line"></span><br><span class="line">arr[&#39;0&#39;] &#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">arr[0] &#x2F;&#x2F; &#39;a&#39;</span><br></pre></td></tr></table></figure>

<p>上面代码分别用数值和字符串作为键名，结果都能读取数组。原因是数值键名被自动转为了字符串。</p>
<p>注意，这点在赋值时也成立。一个值总是先转成字符串，再作为键名进行赋值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];</span><br><span class="line"></span><br><span class="line">a[1.00] &#x3D; 6;</span><br><span class="line">a[1] &#x2F;&#x2F; 6</span><br></pre></td></tr></table></figure>

<p>上面代码中，由于<code>1.00</code>转成字符串是<code>1</code>，所以通过数字键<code>1</code>可以读取值。</p>
<p>上一章说过，对象有两种读取成员的方法：点结构（<code>object.key</code>）和方括号结构（<code>object[key]</code>）。但是，对于数值的键名，不能使用点结构。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [1, 2, 3];</span><br><span class="line">arr.0 &#x2F;&#x2F; SyntaxError</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arr.0</code>的写法不合法，因为单独的数值不能作为标识符（identifier）。所以，数组成员只能用方括号<code>arr[0]</code>表示（方括号是运算符，可以接受数值）。</p>
<h4 id="length-属性-1"><a href="#length-属性-1" class="headerlink" title="length 属性"></a>length 属性</h4><p>数组的<code>length</code>属性，返回数组的成员数量。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>JavaScript 使用一个32位整数，保存数组的元素个数。这意味着，数组成员最多只有 4294967295 个（232 - 1）个，也就是说<code>length</code>属性的最大值就是 4294967295。</p>
<p>只要是数组，就一定有<code>length</code>属性。该属性是一个动态的值，等于键名中的最大整数加上<code>1</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [&#39;a&#39;, &#39;b&#39;];</span><br><span class="line">arr.length &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">arr[2] &#x3D; &#39;c&#39;;</span><br><span class="line">arr.length &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">arr[9] &#x3D; &#39;d&#39;;</span><br><span class="line">arr.length &#x2F;&#x2F; 10</span><br><span class="line"></span><br><span class="line">arr[1000] &#x3D; &#39;e&#39;;</span><br><span class="line">arr.length &#x2F;&#x2F; 1001</span><br></pre></td></tr></table></figure>

<p>上面代码表示，数组的数字键不需要连续，<code>length</code>属性的值总是比最大的那个整数键大<code>1</code>。另外，这也表明数组是一种动态的数据结构，可以随时增减数组的成员。</p>
<p><code>length</code>属性是可写的。如果人为设置一个小于当前成员个数的值，该数组的成员数量会自动减少到<code>length</code>设置的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];</span><br><span class="line">arr.length &#x2F;&#x2F; 3</span><br><span class="line"></span><br><span class="line">arr.length &#x3D; 2;</span><br><span class="line">arr &#x2F;&#x2F; [&quot;a&quot;, &quot;b&quot;]</span><br></pre></td></tr></table></figure>

<p>上面代码表示，当数组的<code>length</code>属性设为2（即最大的整数键只能是1）那么整数键2（值为<code>c</code>）就已经不在数组中了，被自动删除了。</p>
<p>清空数组的一个有效方法，就是将<code>length</code>属性设为0。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];</span><br><span class="line"></span><br><span class="line">arr.length &#x3D; 0;</span><br><span class="line">arr &#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>如果人为设置<code>length</code>大于当前元素个数，则数组的成员数量会增加到这个值，新增的位置都是空位。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [&#39;a&#39;];</span><br><span class="line"></span><br><span class="line">a.length &#x3D; 3;</span><br><span class="line">a[1] &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>上面代码表示，当<code>length</code>属性设为大于数组个数时，读取新增的位置都会返回<code>undefined</code>。</p>
<p>如果人为设置<code>length</code>为不合法的值，JavaScript 会报错。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; 设置负值</span><br><span class="line">[].length &#x3D; -1</span><br><span class="line">&#x2F;&#x2F; RangeError: Invalid array length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数组元素个数大于等于2的32次方</span><br><span class="line">[].length &#x3D; Math.pow(2, 32)</span><br><span class="line">&#x2F;&#x2F; RangeError: Invalid array length</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 设置字符串</span><br><span class="line">[].length &#x3D; &#39;abc&#39;</span><br><span class="line">&#x2F;&#x2F; RangeError: Invalid array length</span><br></pre></td></tr></table></figure>

<p>值得注意的是，由于数组本质上是一种对象，所以可以为数组添加属性，但是这不影响<code>length</code>属性的值。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [];</span><br><span class="line"></span><br><span class="line">a[&#39;p&#39;] &#x3D; &#39;abc&#39;;</span><br><span class="line">a.length &#x2F;&#x2F; 0</span><br><span class="line"></span><br><span class="line">a[2.1] &#x3D; &#39;abc&#39;;</span><br><span class="line">a.length &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>上面代码将数组的键分别设为字符串和小数，结果都不影响<code>length</code>属性。因为，<code>length</code>属性的值就是等于最大的数字键加1，而这个数组没有整数键，所以<code>length</code>属性保持为<code>0</code>。</p>
<p>如果数组的键名是添加超出范围的数值，该键名会自动转为字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [];</span><br><span class="line">arr[-1] &#x3D; &#39;a&#39;;</span><br><span class="line">arr[Math.pow(2, 32)] &#x3D; &#39;b&#39;;</span><br><span class="line"></span><br><span class="line">arr.length &#x2F;&#x2F; 0</span><br><span class="line">arr[-1] &#x2F;&#x2F; &quot;a&quot;</span><br><span class="line">arr[4294967296] &#x2F;&#x2F; &quot;b&quot;</span><br></pre></td></tr></table></figure>

<p>上面代码中，我们为数组<code>arr</code>添加了两个不合法的数字键，结果<code>length</code>属性没有发生变化。这些数字键都变成了字符串键名。最后两行之所以会取到值，是因为取键值时，数字键名会默认转为字符串。</p>
<h4 id="in-运算符"><a href="#in-运算符" class="headerlink" title="in 运算符"></a>in 运算符</h4><p>检查某个键名是否存在的运算符<code>in</code>，适用于对象，也适用于数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ];</span><br><span class="line">2 in arr  &#x2F;&#x2F; true</span><br><span class="line">&#39;2&#39; in arr &#x2F;&#x2F; true</span><br><span class="line">4 in arr &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组存在键名为<code>2</code>的键。由于键名都是字符串，所以数值<code>2</code>会自动转成字符串。</p>
<p>注意，如果数组的某个位置是空位，<code>in</code>运算符返回<code>false</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; [];</span><br><span class="line">arr[100] &#x3D; &#39;a&#39;;</span><br><span class="line"></span><br><span class="line">100 in arr &#x2F;&#x2F; true</span><br><span class="line">1 in arr &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码中，数组<code>arr</code>只有一个成员<code>arr[100]</code>，其他位置的键名都会返回<code>false</code>。</p>
<h4 id="for…in-循环和数组的遍历"><a href="#for…in-循环和数组的遍历" class="headerlink" title="for…in 循环和数组的遍历"></a>for…in 循环和数组的遍历</h4><p><code>for...in</code>循环不仅可以遍历对象，也可以遍历数组，毕竟数组只是一种特殊对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">  console.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>但是，<code>for...in</code>不仅会遍历数组所有的数字键，还会遍历非数字键。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">a.foo &#x3D; true;</span><br><span class="line"></span><br><span class="line">for (var key in a) &#123;</span><br><span class="line">  console.log(key);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line">&#x2F;&#x2F; foo</span><br></pre></td></tr></table></figure>

<p>上面代码在遍历数组时，也遍历到了非整数键<code>foo</code>。<code style="color=red;">所以，不推荐使用<code>for...in</code>遍历数组。</code></p>
<p>数组的遍历可以考虑使用<code>for</code>循环或<code>while</code>循环。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; for循环</span><br><span class="line">for(var i &#x3D; 0; i &lt; a.length; i++) &#123;</span><br><span class="line">  console.log(a[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; while循环</span><br><span class="line">var i &#x3D; 0;</span><br><span class="line">while (i &lt; a.length) &#123;</span><br><span class="line">  console.log(a[i]);</span><br><span class="line">  i++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var l &#x3D; a.length;</span><br><span class="line">while (l--) &#123;</span><br><span class="line">  console.log(a[l]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面代码是三种遍历数组的写法。最后一种写法是逆向遍历，即从最后一个元素向第一个元素遍历。</p>
<p>数组的<code>forEach</code>方法，也可以用来遍历数组，详见《标准库》的 Array 对象一章。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var colors &#x3D; [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;];</span><br><span class="line">colors.forEach(function (color) &#123;</span><br><span class="line">  console.log(color);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; red</span><br><span class="line">&#x2F;&#x2F; green</span><br><span class="line">&#x2F;&#x2F; blue</span><br></pre></td></tr></table></figure>

<h4 id="数组的空位"><a href="#数组的空位" class="headerlink" title="数组的空位"></a>数组的空位</h4><p>当数组的某个位置是空元素，即两个逗号之间没有任何值，我们称该数组存在空位（hole）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, , 1];</span><br><span class="line">a.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码表明，数组的空位不影响<code>length</code>属性。</p>
<p>需要注意的是，如果最后一个元素后面有逗号，并不会产生空位。也就是说，有没有这个逗号，结果都是一样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3,];</span><br><span class="line"></span><br><span class="line">a.length &#x2F;&#x2F; 3</span><br><span class="line">a &#x2F;&#x2F; [1, 2, 3]</span><br></pre></td></tr></table></figure>

<p>上面代码中，数组最后一个成员后面有一个逗号，这不影响<code>length</code>属性的值，与没有这个逗号时效果一样。</p>
<p>数组的空位是可以读取的，返回<code>undefined</code>。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [, , ,];</span><br><span class="line">a[1] &#x2F;&#x2F; undefined</span><br></pre></td></tr></table></figure>

<p>使用<code>delete</code>命令删除一个数组成员，会形成空位，并且不会影响<code>length</code>属性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [1, 2, 3];</span><br><span class="line">delete a[1];</span><br><span class="line"></span><br><span class="line">a[1] &#x2F;&#x2F; undefined</span><br><span class="line">a.length &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>

<p>上面代码用<code>delete</code>命令删除了数组的第二个元素，这个位置就形成了空位，但是对<code>length</code>属性没有影响。也就是说，<code>length</code>属性不过滤空位。所以，使用<code>length</code>属性进行数组遍历，一定要非常小心。</p>
<p>数组的某个位置是空位，与某个位置是<code>undefined</code>，是不一样的。如果是空位，使用数组的<code>forEach</code>方法、<code>for...in</code>结构、以及<code>Object.keys</code>方法进行遍历，空位都会被跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [, , ,];</span><br><span class="line"></span><br><span class="line">a.forEach(function (x, i) &#123;</span><br><span class="line">  console.log(i + &#39;. &#39; + x);</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 不产生任何输出</span><br><span class="line"></span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 不产生任何输出</span><br><span class="line"></span><br><span class="line">Object.keys(a)</span><br><span class="line">&#x2F;&#x2F; []</span><br></pre></td></tr></table></figure>

<p>如果某个位置是<code>undefined</code>，遍历的时候就不会被跳过。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var a &#x3D; [undefined, undefined, undefined];</span><br><span class="line"></span><br><span class="line">a.forEach(function (x, i) &#123;</span><br><span class="line">  console.log(i + &#39;. &#39; + x);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; 0. undefined</span><br><span class="line">&#x2F;&#x2F; 1. undefined</span><br><span class="line">&#x2F;&#x2F; 2. undefined</span><br><span class="line"></span><br><span class="line">for (var i in a) &#123;</span><br><span class="line">  console.log(i);</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 0</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">Object.keys(a)</span><br><span class="line">&#x2F;&#x2F; [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;]</span><br></pre></td></tr></table></figure>

<p>这就是说，空位就是数组没有这个元素，所以不会被遍历到，而<code>undefined</code>则表示数组有这个元素，值是<code>undefined</code>，所以遍历不会跳过。</p>
<h4 id="类似数组的对象"><a href="#类似数组的对象" class="headerlink" title="类似数组的对象"></a>类似数组的对象</h4><p>如果一个对象的所有键名都是正整数或零，并且有<code>length</code>属性，那么这个对象就很像数组，语法上称为“类似数组的对象”（array-like object）。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  0: &#39;a&#39;,</span><br><span class="line">  1: &#39;b&#39;,</span><br><span class="line">  2: &#39;c&#39;,</span><br><span class="line">  length: 3</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[0] &#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">obj[1] &#x2F;&#x2F; &#39;b&#39;</span><br><span class="line">obj.length &#x2F;&#x2F; 3</span><br><span class="line">obj.push(&#39;d&#39;) &#x2F;&#x2F; TypeError: obj.push is not a function</span><br></pre></td></tr></table></figure>

<p>上面代码中，对象<code>obj</code>就是一个类似数组的对象。但是，“类似数组的对象”并不是数组，因为它们不具备数组特有的方法。对象<code>obj</code>没有数组的<code>push</code>方法，使用该方法就会报错。</p>
<p>“类似数组的对象”的根本特征，就是具有<code>length</code>属性。只要有<code>length</code>属性，就可以认为这个对象类似于数组。但是有一个问题，这种<code>length</code>属性不是动态值，不会随着成员的变化而变化。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  length: 0</span><br><span class="line">&#125;;</span><br><span class="line">obj[3] &#x3D; &#39;d&#39;;</span><br><span class="line">obj.length &#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>

<p>上面代码为对象<code>obj</code>添加了一个数字键，但是<code>length</code>属性没变。这就说明了<code>obj</code>不是数组。</p>
<p>典型的“类似数组的对象”是函数的<code>arguments</code>对象，以及大多数 DOM 元素集，还有字符串。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; arguments对象</span><br><span class="line">function args() &#123; return arguments &#125;</span><br><span class="line">var arrayLike &#x3D; args(&#39;a&#39;, &#39;b&#39;);</span><br><span class="line"></span><br><span class="line">arrayLike[0] &#x2F;&#x2F; &#39;a&#39;</span><br><span class="line">arrayLike.length &#x2F;&#x2F; 2</span><br><span class="line">arrayLike instanceof Array &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; DOM元素集</span><br><span class="line">var elts &#x3D; document.getElementsByTagName(&#39;h3&#39;);</span><br><span class="line">elts.length &#x2F;&#x2F; 3</span><br><span class="line">elts instanceof Array &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 字符串</span><br><span class="line">&#39;abc&#39;[1] &#x2F;&#x2F; &#39;b&#39;</span><br><span class="line">&#39;abc&#39;.length &#x2F;&#x2F; 3</span><br><span class="line">&#39;abc&#39; instanceof Array &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>

<p>上面代码包含三个例子，它们都不是数组（<code>instanceof</code>运算符返回<code>false</code>），但是看上去都非常像数组。</p>
<p>数组的<code>slice</code>方法可以将“类似数组的对象”变成真正的数组。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; Array.prototype.slice.call(arrayLike);</span><br></pre></td></tr></table></figure>

<p>除了转为真正的数组，“类似数组的对象”还有一个办法可以使用数组的方法，就是通过<code>call()</code>把数组的方法放到对象上面。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function print(value, index) &#123;</span><br><span class="line">  console.log(index + &#39; : &#39; + value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Array.prototype.forEach.call(arrayLike, print);</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>arrayLike</code>代表一个类似数组的对象，本来是不可以使用数组的<code>forEach()</code>方法的，但是通过<code>call()</code>，可以把<code>forEach()</code>嫁接到<code>arrayLike</code>上面调用。</p>
<p>下面的例子就是通过这种方法，在<code>arguments</code>对象上面调用<code>forEach</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F; forEach 方法</span><br><span class="line">function logArgs() &#123;</span><br><span class="line">  Array.prototype.forEach.call(arguments, function (elem, i) &#123;</span><br><span class="line">    console.log(i + &#39;. &#39; + elem);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 等同于 for 循环</span><br><span class="line">function logArgs() &#123;</span><br><span class="line">  for (var i &#x3D; 0; i &lt; arguments.length; i++) &#123;</span><br><span class="line">    console.log(i + &#39;. &#39; + arguments[i]);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>字符串也是类似数组的对象，所以也可以用<code>Array.prototype.forEach.call</code>遍历。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Array.prototype.forEach.call(&#39;abc&#39;, function (chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">&#x2F;&#x2F; b</span><br><span class="line">&#x2F;&#x2F; c</span><br></pre></td></tr></table></figure>

<p>注意，这种方法比直接使用数组原生的<code>forEach</code>要慢，所以最好还是先将“类似数组的对象”转为真正的数组，然后再直接调用数组的<code>forEach</code>方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var arr &#x3D; Array.prototype.slice.call(&#39;abc&#39;);</span><br><span class="line">arr.forEach(function (chr) &#123;</span><br><span class="line">  console.log(chr);</span><br><span class="line">&#125;);</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">&#x2F;&#x2F; b</span><br><span class="line">&#x2F;&#x2F; c</span><br></pre></td></tr></table></figure>

<h3 id="什么是ES5"><a href="#什么是ES5" class="headerlink" title="什么是ES5"></a>什么是ES5</h3><p>作为ECMAScript第五个版本（第四版因为过于复杂废弃了，增加特性如下。</p>
<p><strong>1. strict模式</strong></p>
<p>严格模式，限制一些用法，’use strict’;</p>
<p><strong>2.Array增加方法</strong></p>
<p>增加了every、some 、forEach、filter 、indexOf、lastIndexOf、isArray、map、reduce、reduceRight方法 ，还有其他方法 Function.prototype.bind、String.prototype.trim、Date.now</p>
<p><strong>3. Object方法</strong></p>
<p>Object.getPrototypeOf</p>
<p>Object.create</p>
<p>Object.getOwnPropertyNames</p>
<p>Object.defineProperty</p>
<p>Object.getOwnPropertyDescriptor</p>
<p>Object.defineProperties</p>
<p>Object.keys</p>
<p>Object.preventExtensions / Object.isExtensible</p>
<p>Object.seal / Object.isSealed</p>
<p>Object.freeze / Object.isFrozen</p>
<p>PS:具体这些方法是什么，可自行深入了解。</p>
<h3 id="什么是ES6"><a href="#什么是ES6" class="headerlink" title="什么是ES6"></a>什么是ES6</h3><p><a href="http://www.ruanyifeng.com/" target="_blank" rel="noopener">阮一峰</a>大佬通俗易懂ES6入门教程：<a href="https://es6.ruanyifeng.com/" target="_blank" rel="noopener">https://es6.ruanyifeng.com/</a></p>
<p><strong>ES6是什么</strong></p>
<p>ECMAScript 6.0（以下简称ES6）是JavaScript语言（现在是遵循ES5标准）的下一代标准，已经在2015年6月正式发布了。它的目标，是使得JavaScript语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<p><strong>ES6的新特性</strong></p>
<ul>
<li>ES6中的let命令，声明变量，用法和var差不多，但是let是为JavaScript新增了块级作用域，ES5中是没有块级作用域的，并且var有变量提升的概念，但是在let中，使用的变量一定要进行声明。</li>
<li>ES6中变量的解构赋值，比如：var [a,b,c] = [0,1,2];</li>
<li>ES6中不再像ES5一样使用原型链实现继承，而是引入Class这个概念，听起来和Java中的面向对象编程的语法有些像，但是二者是不一样的。</li>
<li>ES6中的函数定义也不再使用关键字function，而是利用了=&gt;来进行定义；</li>
<li>ES6中可以设置默认函数参数，如function A（x,y=9）{};</li>
</ul>
<h3 id="Javascript、TypeScript和ES6的关系与区别"><a href="#Javascript、TypeScript和ES6的关系与区别" class="headerlink" title="Javascript、TypeScript和ES6的关系与区别"></a>Javascript、TypeScript和ES6的关系与区别</h3><p><strong>ECMAScript和JavaScript的关系</strong></p>
<p>由于JavaScript的创造者Netscae公司的版权问题，ECMAScript不能叫Javascript。总之，ECMAScript和JavaScript的关系是，前者是后者的规格（语言规范），后者是前者的一种实现。</p>
<p><strong>JavaScript 与 TypeScript 的关系</strong></p>
<p>TypeScript是Javascript的超集，实现以面向对象编程的方式使用Javascript。当然最后代码还是编译为Javascript。</p>
<p><strong>TypeScript 相比于JavaScript 的优势总结为以下几点:</strong></p>
<p>1.便于开发人员做注释。</p>
<p>2.能帮助开发人员检测出错误并修改。</p>
<p>3.TypeScript工具使重构更变的容易、快捷。</p>
<p>4.TypeScript 引入了 JavaScript 中没有的“类”概念。</p>
<p>5.TypeScript 中引入了模块的概念，可以把声明、数据、函数和类封装在模块中。</p>
<p>6.类型安全功能能在编码期间检测错误，这为开发人员创建了一个更高效的编码和调试过程</p>
<p><strong>TypeScript和ES6的关系</strong></p>
<p>typescript相对于ES6,TypeScript最大的改善是增加了类型系统。</p>
<p>附：typescript相对于ES5有五大改善：</p>
<ul>
<li>类型</li>
<li>类</li>
<li>注解</li>
<li>模块导入</li>
<li>语言工具包（比如，结构）</li>
</ul>
<p>TypeScript是ES6的超集。至于需不需要使用，在于你所需要的场景。比如在Angular2中，用TypeScript明显好于ES6。</p>
<p><strong>总结：</strong></p>
<p>ES6是Javascript语言的标准，typescript是ES6的超集。Angular2是基于typescript来开发的JS框架。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">PanXiaoKang</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/04/30/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/">http://example.com/2021/04/30/JavaScript%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E8%BF%9B%E9%98%B6/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">向阳榆木</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/JavaScript/">JavaScript</a><a class="post-meta__tags" href="/tags/%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF/">前端技术</a><a class="post-meta__tags" href="/tags/%E8%BF%9B%E9%98%B6%E4%B9%8B%E8%B7%AF/">进阶之路</a></div><div class="post_share"><div class="social-share" data-image="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=2674621151,307240708&amp;fm=26&amp;gp=0.jpg" data-sites="qq,wechat,facebook,twitter,weibo"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><a class="reward-button button--primary button--animated"> <i class="fa fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t40mLD.th.png" alt="微信"/><div class="post-qr-code__desc">微信</div></li><li class="reward-item"><img class="lazyload post-qr-code__img" src="https://s1.ax1x.com/2020/06/09/t4czVK.th.jpg" alt="支付宝"/><div class="post-qr-code__desc">支付宝</div></li></ul></div></a></div><nav class="pagination_post" id="pagination"><div class="prev-post pull_left"><a href="/2021/05/04/JavaScript%E4%BB%8E%E8%BF%9B%E9%98%B6%E5%88%B0%E7%86%9F%E6%82%89/"><img class="prev_cover lazyload" data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">②JavaScript从进阶到熟悉</div></div></a></div><div class="next-post pull_right"><a href="/2021/04/24/SpringBoot%E5%85%A5%E9%97%A8/"><img class="next_cover lazyload" data-src="https://ss0.bdstatic.com/70cFuHSh_Q1YnxGkpoWK1HF6hhy/it/u=2589588367,2632593097&amp;fm=26&amp;gp=0.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">SpringBoot入门</div></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2021/08/29/JavaScript教程之标准库/" title="③JavaScript教程之标准库"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-08-29</div><div class="relatedPosts_title">③JavaScript教程之标准库</div></div></a></div><div class="relatedPosts_item"><a href="/2021/05/04/JavaScript从进阶到熟悉/" title="②JavaScript从进阶到熟悉"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-05-04</div><div class="relatedPosts_title">②JavaScript从进阶到熟悉</div></div></a></div><div class="relatedPosts_item"><a href="/2021/11/07/JavaScript教程之网页元素接口/" title=" ⑧JavaScript教程之网页元素接口"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-11-07</div><div class="relatedPosts_title"> ⑧JavaScript教程之网页元素接口</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/17/JavaScript教程之浏览器模型/" title="⑦JavaScript教程之浏览器模型"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-17</div><div class="relatedPosts_title">⑦JavaScript教程之浏览器模型</div></div></a></div><div class="relatedPosts_item"><a href="/2021/10/04/JavaScript教程之事件/" title="⑥JavaScript教程之事件"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-10-04</div><div class="relatedPosts_title">⑥JavaScript教程之事件</div></div></a></div><div class="relatedPosts_item"><a href="/2021/09/21/JavaScript教程之DOM/" title="⑤JavaScript教程之DOM"><img class="relatedPosts_cover lazyload"data-src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1273994899,2704080463&fm=26&gp=0.jpg"><div class="relatedPosts_main is-center"><div class="relatedPosts_date"><i class="fa fa-calendar fa-fw" aria-hidden="true"></i> 2021-09-21</div><div class="relatedPosts_title">⑤JavaScript教程之DOM</div></div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify: true,
  verify: true,
  appId: 'z2GwNsG7RRpWpx5rt7psedl5-MdYXbMMI',
  appKey: 'gI6Yhfwz4JiUIv9546gepko8',
  placeholder: '来吧，造作吧，快活吧，肆无忌惮吧！(～￣▽￣)～',
  avatar: 'monsterid',
  meta: guest_info,
  pageSize: '10',
  lang: 'zh-cn',
  recordIP: false,
  serverURLs: ''
});</script></div></article></main><footer id="footer" data-type="color"><div id="footer-wrap"><div class="copyright">&copy;2019 - 2024 By PanXiaoKang</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">小伙伴们好！欢迎来到<a href="https://panyongkang.github.io/" target="_blank" rel="noopener">向阳榆木</a>的博客！</div><div class="icp"><a href="http://www.beian.miit.gov.cn" target="_blank" rel="noopener"><img class="icp-icon" src="/img/icp.png"/><span>黔ICP备54587259号</span></a></div><div id="running-time"></div><script>setInterval(()=>{let create_time=Math.round(new Date(Date.UTC(2020,01,01,0,0,0)).getTime()/1000);let timestamp=Math.round((new Date().getTime()+8*60*60*1000)/1000);let second=timestamp-create_time;let time=new Array(0,0,0,0,0);if(second>=365*24*3600){time[0]=parseInt(second/(365*24*3600));second%=365*24*3600;}if(second>=24*3600){time[1]=parseInt(second/(24*3600));second%=24*3600;}if(second>=3600){time[2]=parseInt(second/3600);second%=3600;}if(second>=60){time[3]=parseInt(second/60);second%=60;}if(second>0){time[4]=second;}currentTimeHtml='本站已安全运行 '+time[0]+' 年 '+time[1]+' 天 '+time[2]+' 时 '+time[3]+' 分 '+time[4]+' 秒';document.getElementById("running-time").innerHTML=currentTimeHtml;},1000);</script></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><i class="fa fa-book" id="readmode" title="阅读模式"></i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换" target="_self">繁</a><i class="darkmode fa fa-moon-o" id="darkmode" title="夜间模式"></i></div><div id="rightside-config-show"><div id="rightside_config" title="设置"><i class="fa fa-cog" aria-hidden="true"></i></div><a id="to_comment" href="#post-comment" title="直达评论"><i class="scroll_to_comment fa fa-comments">  </i></a><i class="fa fa-list-ul close" id="mobile-toc-button" title="目录" aria-hidden="true"></i><i class="fa fa-arrow-up" id="go-up" title="回到顶部" aria-hidden="true"></i></div></section><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div></div><hr/><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script id="canvas_nest" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="/js/third-party/canvas-nest.js"></script><script src="/js/third-party/activate-power-mode.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
document.body.addEventListener('input', POWERMODE);
</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@latest/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@latest/lazysizes.min.js" async=""></script><script src="/js/third-party/ClickShowText.js"></script><script src="/js/search/local-search.js"></script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/platelet.model.json"},"display":{"position":"right","width":200,"height":500},"mobile":{"show":true},"log":false});</script></body></html>